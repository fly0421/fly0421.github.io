{"meta":{"title":"Fly Blog - ૮꒰ ˶• ༝ •˶꒱ა","subtitle":"","description":"Here is Fly’s Blos","author":"Fly","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-05-11T10:36:11.052Z","updated":"2025-05-11T10:36:11.052Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2025-05-11T10:34:45.620Z","updated":"2025-05-11T10:34:45.620Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-13T12:18:53.032Z","updated":"2025-05-13T12:18:53.032Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-11T10:35:04.551Z","updated":"2025-05-11T10:35:04.551Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-13T13:32:20.570Z","updated":"2025-05-13T13:32:20.570Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于我 梦想是早日暴富，梦想是早日躺平退休有饭吃 时间线 OnGoing… 等待退休ING… 2023.11.24 正式工作 2015.09.01 读高中 2012.09.01 读初中 2006.09.01 读小学 2003.09.01 读幼儿园"},{"title":"","date":"2025-05-12T13:44:01.139Z","updated":"2025-05-12T13:44:01.139Z","comments":true,"path":"html/index.html","permalink":"http://example.com/html/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-05-11T10:34:56.134Z","updated":"2025-05-11T10:34:56.134Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-13T15:21:52.571Z","updated":"2025-05-13T15:21:52.571Z","comments":true,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":"相册 note 相册一 第一张图片第二张图片第三张图片 note 相册二 图片1图片2图片3图片4图片5图片6图片7图片8图片9图片10图片11图片12图片13图片14图片15图片16图片17图片18图片19图片10图片11图片12图片13图片14 note 随机图片 随机风景必应壁纸 note 📍China·珠海 爱情邮局城市阳台日月贝 note 随手拍 · 白云 · 夕阳 · 天空 县城傍晚珠海香洲区夕阳珠科校园珠科校园珠科校园珠科校园练车时候拍的从化河边从化公园从化公园从化公园宿舍阳台宿舍阳台珠海香洲区夕阳珠海"}],"posts":[{"title":"设计模式","slug":"设计模式","date":"2025-05-11T10:05:24.000Z","updated":"2025-05-13T14:39:58.987Z","comments":true,"path":"2025/05/11/设计模式/","permalink":"http://example.com/2025/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1、简单工厂模式简单工厂模式(Simple Factory Pattern) 又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。 在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 1234567891011121314151617181920public class OperationFactory&#123; public static Operation createOperate(string operate)&#123; Operation oper = null; switch(operate)&#123; case &quot;+&quot;: oper = new OperationAdd(); break; case &quot;-&quot;: oper = new OperationSub(); break; case &quot;*&quot;: oper = new OperationMul(); break; case &quot;/&quot;: oper = new OperationDiv(); break; &#125; return oper; &#125;&#125; 12345Operation oper;oper = OperationFactory.createOperate（“+”）;oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult（）; 2、策略模式策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 策略接口interface SortStrategy &#123; void sort(int[] array);&#125;// 具体策略类：快速排序class QuickSortStrategy implements SortStrategy &#123; @Override public void sort(int[] array) &#123; // 快速排序算法实现 System.out.println(&quot;Using Quick Sort&quot;); // 排序逻辑 &#125;&#125;// 具体策略类：冒泡排序class BubbleSortStrategy implements SortStrategy &#123; @Override public void sort(int[] array) &#123; // 冒泡排序算法实现 System.out.println(&quot;Using Bubble Sort&quot;); // 排序逻辑 &#125;&#125;// 上下文类：负责使用策略class SortingContext &#123; private SortStrategy strategy; // 设置策略 public void setStrategy(SortStrategy strategy) &#123; this.strategy = strategy; &#125; // 执行排序 public void executeSort(int[] array) &#123; strategy.sort(array); &#125;&#125;// 测试public class StrategyPatternExample &#123; public static void main(String[] args) &#123; SortingContext context = new SortingContext(); // 使用快速排序策略 context.setStrategy(new QuickSortStrategy()); context.executeSort(new int[]&#123;3, 1, 2&#125;); // 使用冒泡排序策略 context.setStrategy(new BubbleSortStrategy()); context.executeSort(new int[]&#123;3, 1, 2&#125;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"fly"},{"title":"WPF编程基础下（二）","slug":"WPF基础学习下","date":"2025-05-11T10:02:24.000Z","updated":"2025-05-13T15:40:08.477Z","comments":true,"path":"2025/05/11/WPF基础学习下/","permalink":"http://example.com/2025/05/11/WPF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%8B/","excerpt":"","text":"内容控件Control基类Control是许多控件的基类。比如最常见的按钮（Button）、单选(RadioButton)、复选（CheckBox）、文本框（TextBox）、ListBox、DataGrid、日期控件等等。这些控件通常用于展示程序的数据或获取用户输入的数据，我们可以将这一类型的控件称为内容控件或数据控件，它们与前面的布局控件有一定的区别，布局控件更专注于界面，而内容控件更专注于数据（业务）。 Control类虽然可以实例化，但是在界面上是不会有任何显示的。只有那些继承了Control的子类（控件）才会在界面上显示，而且所呈现的样子各不相同，为什么会是这样呢？ 因为Control类提供了一个控件模板（ControlTemplate），而几乎所有的子类都对这个ControlTemplate进行了各自的实现，所以在呈现子类时，我们才会看到Button拥有Button的样子，TextBox拥有TextBox的样子。 Control基类说 我给你们一张白纸(ControlTemplate)，你们可以在上面想画什么就画什么 我们在这一章节并不对模板(Template)进行详细的介绍，只是先阐述模板的概念，接下来，我们先将目光聚焦到Control的结构定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Control : FrameworkElement&#123;public static readonly DependencyProperty BorderBrushProperty;public static readonly RoutedEvent PreviewMouseDoubleClickEvent;public static readonly DependencyProperty TemplateProperty;public static readonly DependencyProperty PaddingProperty;public static readonly DependencyProperty IsTabStopProperty;public static readonly DependencyProperty TabIndexProperty;public static readonly DependencyProperty VerticalContentAlignmentProperty;public static readonly DependencyProperty HorizontalContentAlignmentProperty;public static readonly RoutedEvent MouseDoubleClickEvent;public static readonly DependencyProperty FontStyleProperty;public static readonly DependencyProperty FontStretchProperty;public static readonly DependencyProperty FontSizeProperty;public static readonly DependencyProperty FontFamilyProperty;public static readonly DependencyProperty ForegroundProperty;public static readonly DependencyProperty BackgroundProperty;public static readonly DependencyProperty BorderThicknessProperty;public static readonly DependencyProperty FontWeightProperty; public Control(); public FontStyle FontStyle &#123; get; set; &#125;public FontStretch FontStretch &#123; get; set; &#125;public double FontSize &#123; get; set; &#125;public FontFamily FontFamily &#123; get; set; &#125;public Brush Foreground &#123; get; set; &#125;public Brush Background &#123; get; set; &#125;public Thickness BorderThickness &#123; get; set; &#125;public bool IsTabStop &#123; get; set; &#125;public VerticalAlignment VerticalContentAlignment &#123; get; set; &#125;public int TabIndex &#123; get; set; &#125;public Thickness Padding &#123; get; set; &#125;public ControlTemplate Template &#123; get; set; &#125;public FontWeight FontWeight &#123; get; set; &#125;public Brush BorderBrush &#123; get; set; &#125;public HorizontalAlignment HorizontalContentAlignment &#123; get; set; &#125;protected internal virtual bool HandlesScrolling &#123; get; &#125; public event MouseButtonEventHandler MouseDoubleClick;public event MouseButtonEventHandler PreviewMouseDoubleClick; public override string ToString();protected override Size ArrangeOverride(Size arrangeBounds);protected override Size MeasureOverride(Size constraint);protected virtual void OnMouseDoubleClick(MouseButtonEventArgs e);protected virtual void OnPreviewMouseDoubleClick(MouseButtonEventArgs e);protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate); &#125; 我们先来看看Control基类为它的子类们提供了哪些属性 属性 说明 FontStyle 获取或设置控件的字体结构，类似于Word中字体的常规、斜体或倾斜 FontStretch 获取或设置紧缩或在屏幕上展开一种字体的程度。 FontSize 获取或设置字体大小。 FontFamily 获取或设置控件的字体系列。如：微软雅黑 &#x3D; “Microsoft YaHei UI” Foreground 获取或设置控件的字体颜色，也就是所谓的前景色画笔，它是一个刷子（Brush） Background 获取或设置一个用于描述控件的背景画笔。 BorderThickness 获取或设置控件的边框宽度。 IsTabStop 获取或设置一个值，该值指示控件是否包括在选项卡上的导航窗格中。 VerticalContentAlignment 获取或设置控件的内容的垂直对齐方式。 TabIndex 获取或设置一个值，确定当用户导航控件通过使用 TAB 键元素接收焦点的顺序。 Padding 获取或设置在控件中的填充量。 Template 获取或设置控件模板。 FontWeight 获取或设置指定的字体粗细。 BorderBrush 获取或设置一个用于描述一个控件的边框背景画笔。 HorizontalContentAlignment 获取或设置控件的内容的水平对齐方式。 大部分的属性都比较好理解，这里着重介绍一下Template属性。如果把人比作是一个Control(控件)，那么”着装“就是Template（模板）。在大街上，我们会看到不同着装的人来来往往。 所以Control的Template定义了控件的外观（着装）。 数据模板 与控件模板类似的，还有一个概念叫数据模板。形象地说，还是把人比作控件，那么人体的五脏六腑就是这个控件的数据，而五脏六腑（数据）的外观就是指数据模板。 我们来看一个实际的例子 12345678910111213&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Control Margin=&quot;10&quot;&gt; &lt;/Control&gt; &lt;/Window&gt; 我们在Window窗体中实例化了一个Control类，但是，界面上空无一物。这是因为当前这个Control对象还没有”穿衣服“，也就是说，它的Template并没有内容，实际上，此刻Template属性等于null。 那我们尝试给他穿一件衣服吧。 123456789101112131415161718&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Control Margin=&quot;10&quot;&gt; &lt;Control.Template&gt; &lt;ControlTemplate TargetType=&quot;Control&quot;&gt; &lt;Border Background=&quot;LightBlue&quot;&gt; &lt;TextBlock Text=&quot;WPF中文网&quot; FontSize=&quot;20&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Control.Template&gt; &lt;/Control&gt;&lt;/Window&gt; 我们为Control的Template实例化了一个ControlTemplate对象，并在这个对象中增加了一个Border，在Border中又增加了一个TextBlock子元素，于是Control就有了这样一件新衣服。 在这里，我们要明白一个要点是，Control类的Template属性是ControlTemplate类型的。所以上面的代码才必须这样写才可以。而ControlTemplate又是什么东东？为什么在xaml中实例化时，后面要跟一句TargetType&#x3D;”Control”？关于这一点，我们将在后面专门拿一章节来阐述ControlTemplate以及它的父类。 事件 在这一小节里，您只要能明白Template的概念就行了。除了这个属性，Control类还提供了两个事件，它们分别是PreviewMouseDoubleClick和MouseDoubleClick。 事件名称 说明 PreviewMouseDoubleClick 表示鼠标双击或多次单击时触发的事件 MouseDoubleClick 表示鼠标双击或多次单击时触发的事件 以Preview开头的事件叫隧道事件或预览事件，而MouseDoubleClick没有以Preview开头，所以它叫冒泡事件。 WPF的前端代码其实是一棵树，当我们在某个目标控件上进行鼠标操作时，所引发的事件有两个方向，一是从Winow根节点一直路由到目标控件上，看起来就好像是从外面一直沿着这棵树路由引发至里面，这就像我们开车进入隧道一样，所以Preview开头的事件叫隧道事件。 冒泡事件事件的路由方向相反，是从目标控件位置开始，一直路由引发至最外层的Window窗体。 关于路由事件，我们会在后面拿一章节专门讲解，这里只提一下这个概念。 通常，我们并不会直接实例化Control基类，确实这样做对我们实际帮助不大，我们要使用的——是它膝下各个子控件，而在这众多的子控件中，Button是最常见最简单的控件了。不过，Button的基类是ButtonBase，ButtonBase的基类是ContentControl，ContentControl的基类是Control。如果我们要探讨Button控件，看样子必须要先介绍一下ContentControl基类和ButtonBase基类才行了。 ContentControl类（内容控件）ContentControl是一个神奇的类！ 为什么这么说呢，因为它有一个Content属性，关键是这个属性的类型是object。也就是说，本质上，它可以接收任意引用类型的实例。 但是，通常情况下，Content属性接收UI控件。因为，ContentControl控件最终会把Content属性里面的内容显示到界面上。 我们先看看它的结构定义： 1234567891011121314151617181920212223242526public class ContentControl : Control, IAddChild&#123; public static readonly DependencyProperty ContentProperty; public static readonly DependencyProperty HasContentProperty; public static readonly DependencyProperty ContentTemplateProperty; public static readonly DependencyProperty ContentTemplateSelectorProperty; public static readonly DependencyProperty ContentStringFormatProperty; public ContentControl(); public DataTemplate ContentTemplate &#123; get; set; &#125; public bool HasContent &#123; get; &#125; public object Content &#123; get; set; &#125; public string ContentStringFormat &#123; get; set; &#125; public DataTemplateSelector ContentTemplateSelector &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public virtual bool ShouldSerializeContent(); protected virtual void AddChild(object value); protected virtual void AddText(string text); protected virtual void OnContentChanged(object oldContent, object newContent); protected virtual void OnContentStringFormatChanged(string oldContentStringFormat, string newContentStringFormat); protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate); protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector); &#125; 那么，我如果非要把其它类型的对象（比如字符串）强行塞给Content属性呢？ 123456789101112&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;ContentControl Foreground=&quot;Red&quot; FontSize=&quot;36&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; WPF中文网 &lt;/ContentControl&gt;&lt;/Window&gt; 如上所示，我们在ContentControl 内部只写了一句“WPF中文网”，并设置了Foreground和FontSize等属性，居然不但没报错，还将字符串显示出来了，这真是太神奇了！ 重庆教主友情提示 别忘记了ContentControl 继承于Control 基类，所以我们的ContentControl 也可以设置Foreground和FontSize哦！ ContentTemplate属性（内容模板） 这个属性表示获取或设置用来显示的内容的数据模板，说白了，就是决定“WPF中文网”这几个字的穿着，如果没有设置数据模板，它将以默认的数据模板来显示这几个字。接下来，我们演示一下这个属性的用法，并简要说明其中的关系。 1234567891011121314151617&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;ContentControl Foreground=&quot;Red&quot; FontSize=&quot;36&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;ContentControl.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=&quot;&#123;Binding&#125;&quot; Foreground=&quot;Green&quot; FontSize=&quot;16&quot;/&gt; &lt;/DataTemplate&gt; &lt;/ContentControl.ContentTemplate&gt; WPF中文网 &lt;/ContentControl&gt;&lt;/Window&gt; ContentControl类的ContentTemplate属性是DataTemplate类型，所以我们在xaml中实例化了一个DataTemplate（数据模板）对象，并在其中增加了一个TextBlock控件，将TextBlock控件的Text属性写成了Binding形式，并设置了字体颜色和大小。 最终呈现的效果上图所示，字体颜色为绿色，大小为16。虽然ContentControl也设置了字体颜色为红色，大小为36，但是已经失效了。好比ContentControl给Content提供了一件红色的外衣，但是，我们又特地提供了一件绿色的外衣，于是，ContentControl就被绿了。 关于数据模板中的TextBlock控件的Text属性写成了Binding(绑定)形式，这是指将ContentContent控件的Contnet属性绑定到TextBlock控件的Text属性中，写成伪代码就是： 1TextBlock.Text = ContentContent.Content 这是您第一次在这个系列中看到Binding（绑定）的出现。我们将在后面专门拿一章节进行探讨。这里能理解这个ContentTemplate就行了。 ContentControl控件能不能容纳多个子控件？ 不能！因为ContentControl控件只能显示Content属性里面的内容，而Content属性是object，只能接收一个对象。 HasContent属性：表示ContentControl是否有内容。 ContentStringFormat属性：获取或设置ContentControl要显示字符串的格式。 ContentTemplateSelector属性：模板选择器， 我们会在模板一章节介绍。 常规用法 123456789101112&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;ContentControl Foreground=&quot;Red&quot; FontSize=&quot;60&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;WPF中文网&quot;/&gt; &lt;/ContentControl&gt;&lt;/Window&gt; 这次我们在ContentControl放了一个Button，需要注意一点的是：Button的字号会随着ContentControl的设置而变化，但是字体颜色不会随着ContentControl的设置而变化。 ButtonBase基类按钮，几乎每个具有UI界面的软件都会有它的身影，而按钮的形式也是有多种多样的，我们在这里简单的罗列一下。 按钮名称 说明 Button 普通按钮 CheckBox 复选框按钮 RadioButton 单选框按钮 ToggleButton 是CheckBox、RadioButton的基类，表示可以切换状态 RepeatButton 重复，表示从按下到弹出过程中重复引发Click事件 GridViewColumnHeader 表示GridViewColumn 的列标题，其实它也是一个按钮 DataGridColumnHeader 表示DataGrid 列标题，也是一个按钮 DataGridRowHeader 表示DataGrid 行标题，也是一个按钮 上面便是WPF中的按钮体系，这些按钮都有一个共同的基类ButtonBase，所以，我们了解清楚了ButtonBase，对于学习上面这些按钮，有莫大的帮助。 一、ButtonBase概述 ButtonBase是一个抽象类，所以，它不能被实例化。我们只能在它的子类中去使用它提供的一些属性、事件或方法成员。它只有一个事件，就是Click单击事件，毕竟鼠标双击事件在它的Control基类就有了嘛。另外，它还有一个非常厉害的Command属性，这个属性其实是一个接口，起什么作用呢？就是在单击按钮时，去执行这个Command属性所指定的一个具体命令。 这个Command命令是WPF命令系统里面的角色，也是WPF优于Winform的一个具体表现，Command命令也是MVVM模式中最重要的一环。我们会在后面专门探讨WPF的命令系统。 接下来，我们先看看ButtonBase的结构定义： 1234567891011121314151617181920212223242526272829303132333435public abstract class ButtonBase : ContentControl, ICommandSource&#123; public static readonly RoutedEvent ClickEvent; public static readonly DependencyProperty CommandProperty; public static readonly DependencyProperty CommandParameterProperty; public static readonly DependencyProperty CommandTargetProperty; public static readonly DependencyProperty IsPressedProperty; public static readonly DependencyProperty ClickModeProperty; protected ButtonBase(); public IInputElement CommandTarget &#123; get; set; &#125; public object CommandParameter &#123; get; set; &#125; public ICommand Command &#123; get; set; &#125; public bool IsPressed &#123; get; protected set; &#125; public ClickMode ClickMode &#123; get; set; &#125; protected override bool IsEnabledCore &#123; get; &#125; public event RoutedEventHandler Click; protected override void OnAccessKey(AccessKeyEventArgs e); protected virtual void OnClick(); protected virtual void OnIsPressedChanged(DependencyPropertyChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected override void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e); protected override void OnLostMouseCapture(MouseEventArgs e); protected override void OnMouseEnter(MouseEventArgs e); protected override void OnMouseLeave(MouseEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected internal override void OnRenderSizeChanged(SizeChangedInfo sizeInfo); &#125; 二、ButtonBase的属性 属性名称 说明 CommandTarget 获取或设置要对其引发指定的命令的元素。 CommandParameter 获取或设置一个命令参数，这个参数是传递给Command 属性所指向的命令。 Command 获取或设置要在按此按钮时调用的命令。 IsPressed 获取当前按钮是否处于激活状态。 ClickMode 获取或设置按钮的单击模式 IsEnabledCore 获取的值 System.Windows.ContentElement.IsEnabled 属性。 三、ButtonBase方法 ButtonBase还提供了两个虚方法，分别是OnClick()和OnIsPressedChanged（）。说明这两个方法也是可以重写的，OnClick表示在按钮单击时执行的方法。 Button按钮Button因为继承了ButtonBase，而ButtonBase又继承了ContentControl，所以，Button可以通过设置Content属性来设置要显示的内容。例如 1&lt;Button Content=&quot;WPF中文网&quot;/&gt; 我们使用Button的时机，通常是鼠标点击事件需要有响应操作时，所以，Button的Click事件是最好的选择。接下来，我们先看看它的结构定义： 12345678910111213141516public class Button : ButtonBase&#123; public static readonly DependencyProperty IsDefaultProperty; public static readonly DependencyProperty IsCancelProperty; public static readonly DependencyProperty IsDefaultedProperty; public Button(); public bool IsDefault &#123; get; set; &#125; public bool IsCancel &#123; get; set; &#125; public bool IsDefaulted &#123; get; &#125; protected override void OnClick(); protected override AutomationPeer OnCreateAutomationPeer(); &#125; 属性分析 属性 说明 IsDefault 用户通过按 ENTER 键时调用的默认按钮。 IsCancel 用户可以通过按 ESC 键来激活取消按钮。 IsDefaulted 获取按钮是否为按 ENTER 键时调用的默认按钮。 我们通过一个例子来分析Button控件的用法与特点。 前端代码 1234567891011121314&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;退出&quot; Width=&quot;100&quot; Height=&quot;25&quot; Click=&quot;_button_Click&quot; IsDefault=&quot;True&quot;/&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; this.Close(); &#125; &#125;&#125; ToggleButton基类因为ToggleButton作为CheckBox（复选框）和RadioButton（单选框）的基类，我们在学习CheckBox和RadioButton之前要先了解一下这个基类。 12345678910111213141516171819202122232425public class ToggleButton : ButtonBase&#123; public static readonly RoutedEvent CheckedEvent; public static readonly RoutedEvent UncheckedEvent; public static readonly RoutedEvent IndeterminateEvent; public static readonly DependencyProperty IsCheckedProperty; public static readonly DependencyProperty IsThreeStateProperty; public ToggleButton(); public bool IsThreeState &#123; get; set; &#125; public bool? IsChecked &#123; get; set; &#125; public event RoutedEventHandler Checked; public event RoutedEventHandler Indeterminate; public event RoutedEventHandler Unchecked; public override string ToString(); protected virtual void OnChecked(RoutedEventArgs e); protected override void OnClick(); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnIndeterminate(RoutedEventArgs e); protected virtual void OnUnchecked(RoutedEventArgs e); protected internal virtual void OnToggle();&#125; ToggleButton基类提供了两个属性和三个事件 IsThreeState属性为true表示控件支持3个状态，IsChecked属性为true表示当前控件已被选中。Checked事件表示选中时引发的事件，Unchecked事件表示从选中状态改为未选状态时引发的事件，Indeterminate事件表示不确定状态时引发的事件 CheckBox复选框CheckBox继承于ToggleButton，而ToggleButton才继承于ButtonBase基类。 CheckBox控件的结构定义： 123456789public class CheckBox : ToggleButton&#123; public CheckBox(); protected override void OnAccessKey(AccessKeyEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnKeyDown(KeyEventArgs e); &#125; CheckBox自身没有什么特别内容。一切都使用它的父类提供的属性、方法和事件。我们举例来说明它的用法。 前端代码 12345678910111213141516&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;今晚吃什么菜?&quot; Margin=&quot;5&quot;/&gt; &lt;CheckBox Name=&quot;_checkbox1&quot; Content=&quot;红烧牛肉&quot; Margin=&quot;5&quot;/&gt; &lt;CheckBox Name=&quot;_checkbox2&quot; Content=&quot;麻婆豆腐&quot; Margin=&quot;5&quot;/&gt; &lt;CheckBox Name=&quot;_checkbox3&quot; Content=&quot;夫妻肺片&quot; Margin=&quot;5&quot;/&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;查看菜单&quot; Click=&quot;_button_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; string order = string.Empty; if (_checkbox1.IsChecked == true) order += _checkbox1.Content + &quot;,&quot;; if (_checkbox2.IsChecked == true) order += _checkbox2.Content + &quot;,&quot;; if (_checkbox3.IsChecked == true) order += _checkbox3.Content; if(!string.IsNullOrEmpty(order)) MessageBox.Show(order); &#125; &#125;&#125; 如上图所示，这是前端代码呈现的界面。F5启动后，我们勾选两个选项，然后点击查看菜单，观察结果。 我们通过判断CheckBox的IsChecked属性，来获取前端用户的选择，这通常是CheckBox控件最常用的用法，由于IsChecked是一个依赖属性，它还可以参与绑定，形成MVMM的应用模式，待我们讲到数据绑定章节，还会进一步讲解控件属性的绑定应用。 RadioButton单选框RadioButton也继承于ToggleButton，作用是单项选择，所以被称为单选框。本质上，它依然是一个按钮，一旦被选中，不会清除，除非它”旁边“的单选框被选中。 1234567891011121314public class RadioButton : ToggleButton&#123; public static readonly DependencyProperty GroupNameProperty; public RadioButton(); public string GroupName &#123; get; set; &#125; protected override void OnAccessKey(AccessKeyEventArgs e); protected override void OnChecked(RoutedEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected internal override void OnToggle(); &#125; 这个控件有一个重要属性叫GroupName——分组名称。默认值是一个空字符串。用来指定哪些RadioButton之间是互相排斥的。 我们将前面的例子简单修改一下代码。 前端代码 1234567&lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;今晚吃什么菜?&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton1&quot; Content=&quot;红烧牛肉&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton2&quot; Content=&quot;麻婆豆腐&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton3&quot; Content=&quot;夫妻肺片&quot; Margin=&quot;5&quot;/&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;查看菜单&quot; Click=&quot;_button_Click&quot;/&gt;&lt;/StackPanel&gt; 后端代码 1234567891011121314151617181920212223242526namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; string order = string.Empty; if (_RadioButton1.IsChecked == true) order += _RadioButton1.Content + &quot;,&quot;; if (_RadioButton2.IsChecked == true) order += _RadioButton2.Content + &quot;,&quot;; if (_RadioButton3.IsChecked == true) order += _RadioButton3.Content; if(!string.IsNullOrEmpty(order)) MessageBox.Show(order); &#125; &#125;&#125; F5运行之后，我们会发现，无论我们怎么选，始终只有一个RadioButton按钮被选中。 如果我们希望RadioButton按分组进行单项选择，该怎么办呢？ 我们可以使用GroupName分组属性，两两一组，让用户始终都只能选择一荤一素两个菜，请看代码。 前端代码 12345678&lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;今晚吃什么菜?&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton1&quot; Content=&quot;红烧牛肉&quot; GroupName=&quot;荤菜&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton2&quot; Content=&quot;糖醋排骨&quot; GroupName=&quot;荤菜&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton3&quot; Content=&quot;麻婆豆腐&quot; GroupName=&quot;素菜&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton4&quot; Content=&quot;清炒时蔬&quot; GroupName=&quot;素菜&quot; Margin=&quot;5&quot;/&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;查看菜单&quot; Click=&quot;_button_Click&quot;/&gt;&lt;/StackPanel&gt; 后端代码 123456789101112131415161718192021public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e)&#123; string order = string.Empty; if (_RadioButton1.IsChecked == true) order += _RadioButton1.Content + &quot;,&quot;; if (_RadioButton2.IsChecked == true) order += _RadioButton2.Content + &quot;,&quot;; if (_RadioButton3.IsChecked == true) order += _RadioButton3.Content + &quot;,&quot;; if (_RadioButton4.IsChecked == true) order += _RadioButton4.Content; if (!string.IsNullOrEmpty(order)) MessageBox.Show(order);&#125; 此时再操作时我们发现，红烧牛肉和糖醋排骨只能二选一，麻婆豆腐和清炒时蔬也只能二选一。 RepeatButton重复按钮RepeatButton,顾名思义，重复执行的按钮。就是当按钮被按下时，所订阅的回调函数会不断被执行。那么，多长时间执行一次？ 我们先看看它的结构定义： 123456789101112131415161718192021public class RepeatButton : ButtonBase&#123; public static readonly DependencyProperty DelayProperty; public static readonly DependencyProperty IntervalProperty; public RepeatButton(); public int Delay &#123; get; set; &#125; public int Interval &#123; get; set; &#125; protected override void OnClick(); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected override void OnLostMouseCapture(MouseEventArgs e); protected override void OnMouseEnter(MouseEventArgs e); protected override void OnMouseLeave(MouseEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e); &#125; 一、属性分析 RepeatButton 自身提供了两个整型属性，分别是Delay 和Interval 。 Delay 属性：表示延时重复执行的毫秒数，就是说，RepeatButton被按下后会立即执行一次回调函数，如果您不松开鼠标，在等待Delay 毫秒后，就开始进行重复执行阶段。 Interval 属性：表示重复执行回调函数的时间间隔毫秒数。 接下来，我们观察下面的代码的运行结果。 二、RepeatButton 应用示例 1234&lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;牙膏已在手&quot; Margin=&quot;5 7 5 5&quot;/&gt; &lt;RepeatButton Name=&quot;_Button1&quot; Content=&quot;开始挤牙膏&quot; Delay=&quot;1000&quot; Interval=&quot;500&quot; Click=&quot;_Button1_Click&quot; Margin=&quot;5&quot;/&gt; &lt;/StackPanel&gt; 123456789101112131415161718namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; int count = 1; private void _Button1_Click(object sender, RoutedEventArgs e) &#123; Console.WriteLine($&quot;重复时间:&#123;DateTime.Now.ToLongTimeString()&#125; &#123;DateTime.Now.Millisecond&#125;,重复次数:&#123;count++&#125;&quot;); &#125; &#125;&#125; 我们以生活中挤牙膏为例，当开始挤的动作发生后，我们会持续一小会儿，然后才松开，此时牙膏停止往外溢出。观察下面的输出结果： 12345678重复时间:14:37:28 476,重复次数:1重复时间:14:37:29 548,重复次数:2重复时间:14:37:30 51,重复次数:3重复时间:14:37:30 549,重复次数:4重复时间:14:37:31 89,重复次数:5重复时间:14:37:31 598,重复次数:6重复时间:14:37:32 185,重复次数:7重复时间:14:37:32 718,重复次数:8 结果显示，第一次和第二次输出时间刚好为1000毫秒，也就是Delay属性在起作用。然后，从第2次开始，每两次之间的时间间隔大约为500毫秒，这是因为Interval属性被设置为500。相信通过这个例子，您已明白这个按钮的用法。 Label标签Label控件继承于ContentControl控件，它是一个文本标签，如果您想修改它的标签内容，请设置Content属性。我们曾提过ContentControl的Content属性是object类型，意味着Label的Content也是可以设置为任意的引用类型的。 我们来举个例子。 12345678&lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;Label Content=&quot;这是一个Label标签&quot;/&gt; &lt;Label&gt; &lt;Label.Content&gt; &lt;Button Content=&quot;确定&quot; Click=&quot;_Button1_Click&quot;/&gt; &lt;/Label.Content&gt; &lt;/Label&gt;&lt;/StackPanel&gt; 1234567891011public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _Button1_Click(object sender, RoutedEventArgs e)&#123; this.Close();&#125; 我们给第二个标签的Content属性设置了一个按钮，并对按钮的Click事件做了订阅回调，F5运行，事实证明，此时的Button是可以正常使用 。只不过，通常情况下，我们的Label只是用来显示一段文字，很少在Contnet里面编写其它控件代码。如果要编写其它控件代码以实现更复杂的自定义控件效果，我们建议使用UserControl用户控件。 对于文本的显示，除了可以在Label中显示，我们还有一个控件也可以实现，那就是TextBlock文字块。而且，TextBlock控件直接从FrameworkElement基类继承而来，效率比Label标签更高哦。 TextBlock文字块TextBlock是专业处理文本显示的控件，在功能上比Label更全面。先看结构定义，后举例说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class TextBlock : FrameworkElement, IContentHost, IAddChildInternal, IAddChild, IServiceProvider&#123; public static readonly DependencyProperty BaselineOffsetProperty; public static readonly DependencyProperty IsHyphenationEnabledProperty; public static readonly DependencyProperty TextWrappingProperty; public static readonly DependencyProperty TextAlignmentProperty; public static readonly DependencyProperty PaddingProperty; public static readonly DependencyProperty LineStackingStrategyProperty; public static readonly DependencyProperty LineHeightProperty; public static readonly DependencyProperty TextEffectsProperty; public static readonly DependencyProperty TextDecorationsProperty; public static readonly DependencyProperty TextTrimmingProperty; public static readonly DependencyProperty ForegroundProperty; public static readonly DependencyProperty FontSizeProperty; public static readonly DependencyProperty FontStretchProperty; public static readonly DependencyProperty FontWeightProperty; public static readonly DependencyProperty FontStyleProperty; public static readonly DependencyProperty FontFamilyProperty; public static readonly DependencyProperty TextProperty; public static readonly DependencyProperty BackgroundProperty; public TextBlock(); public TextBlock(Inline inline); public FontWeight FontWeight &#123; get; set; &#125; public FontStyle FontStyle &#123; get; set; &#125; public FontFamily FontFamily &#123; get; set; &#125; public string Text &#123; get; set; &#125; public TextPointer ContentEnd &#123; get; &#125; public Typography Typography &#123; get; &#125; public LineBreakCondition BreakAfter &#123; get; &#125; public LineBreakCondition BreakBefore &#123; get; &#125; public FontStretch FontStretch &#123; get; set; &#125; public double BaselineOffset &#123; get; set; &#125; public double FontSize &#123; get; set; &#125; public TextWrapping TextWrapping &#123; get; set; &#125; public Brush Background &#123; get; set; &#125; public TextDecorationCollection TextDecorations &#123; get; set; &#125; public TextEffectCollection TextEffects &#123; get; set; &#125; public double LineHeight &#123; get; set; &#125; public LineStackingStrategy LineStackingStrategy &#123; get; set; &#125; public Thickness Padding &#123; get; set; &#125; public TextAlignment TextAlignment &#123; get; set; &#125; public TextTrimming TextTrimming &#123; get; set; &#125; public TextPointer ContentStart &#123; get; &#125; public bool IsHyphenationEnabled &#123; get; set; &#125; public Brush Foreground &#123; get; set; &#125; public InlineCollection Inlines &#123; get; &#125; protected virtual IEnumerator&lt;IInputElement&gt; HostedElementsCore &#123; get; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public static double GetBaselineOffset(DependencyObject element); public static FontFamily GetFontFamily(DependencyObject element); public static double GetFontSize(DependencyObject element); public static FontStretch GetFontStretch(DependencyObject element); public static FontStyle GetFontStyle(DependencyObject element); public static FontWeight GetFontWeight(DependencyObject element); public static Brush GetForeground(DependencyObject element); public static double GetLineHeight(DependencyObject element); public static LineStackingStrategy GetLineStackingStrategy(DependencyObject element); public static TextAlignment GetTextAlignment(DependencyObject element); public static void SetBaselineOffset(DependencyObject element, double value); public static void SetFontFamily(DependencyObject element, FontFamily value); public static void SetFontSize(DependencyObject element, double value); public static void SetFontStretch(DependencyObject element, FontStretch value); public static void SetFontStyle(DependencyObject element, FontStyle value); public static void SetFontWeight(DependencyObject element, FontWeight value); public static void SetForeground(DependencyObject element, Brush value); public static void SetLineHeight(DependencyObject element, double value); public static void SetLineStackingStrategy(DependencyObject element, LineStackingStrategy value); public static void SetTextAlignment(DependencyObject element, TextAlignment value); public TextPointer GetPositionFromPoint(Point point, bool snapToText); public bool ShouldSerializeBaselineOffset(); public bool ShouldSerializeInlines(XamlDesignerSerializationManager manager); public bool ShouldSerializeText(); protected sealed override Size ArrangeOverride(Size arrangeSize); protected virtual ReadOnlyCollection&lt;Rect&gt; GetRectanglesCore(ContentElement child); protected override Visual GetVisualChild(int index); protected sealed override HitTestResult HitTestCore(PointHitTestParameters hitTestParameters); protected virtual IInputElement InputHitTestCore(Point point); protected sealed override Size MeasureOverride(Size constraint); protected virtual void OnChildDesiredSizeChangedCore(UIElement child); protected override AutomationPeer OnCreateAutomationPeer(); protected sealed override void OnPropertyChanged(DependencyPropertyChangedEventArgs e); protected sealed override void OnRender(DrawingContext ctx); &#125; TextBlock提供了非常丰富的文本相关的属性。 属性 说明 FontWeight 获取或设置TextBlock的字体粗细 FontStyle 获取或设置TextBlock的字体样式，如斜体字体 FontFamily 获取或设置TextBlock的字体系列，如微软雅黑 Text 获取或设置TextBlock的字体内容。 ContentEnd 表示获取TextBlock内容的最末尾的TextPointer对象 Typography 获取此元素的内容当前有效的版式变体。 FontStretch 获取或设置 TextBlock 的常用字体拉伸特征。 BaselineOffset 获取或设置文本的每个行相对于基线的偏移量。 FontSize 获取或设置TextBlock的字号 TextWrapping 获取或设置TextBlock的文字的换行方式 Background 获取或设置TextBlock控件的背景颜色（画刷） TextEffects 获取或设置要应用于此元素中的文本内容的效果。 LineHeight 获取或设置各行内容的高度。 Padding 指示内容区域的边界之间填充空间的宽度 TextAlignment 指示文本内容的水平对齐方式。 TextTrimming 获取或设置在内容超出内容区域时要采用的文本剪裁行为。 Foreground 获取或设置文本内容的字体颜色（画刷） Inlines 这个属性是一个集合，其中的元素表示内联流内容元素，简单点说，一行文本可以看成是一个Inline元素，而TextBlock可以接受多个Inline。Run继承于Inline，实际使用中，我们会创建多个Run实例，可以单独为每个Run对象设置字体字号颜色等等。 ContentStart 表示获取TextBlock内容的最开始的TextPointer对象 接下来， 我们将上面常用的属性在例子中得以体现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;WrapPanel&gt; &lt;TextBlock Text=&quot;这是一个TextBlock文字块&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;粗体文字&quot; FontWeight=&quot;Bold&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;粗体文字&quot; FontWeight=&quot;Light&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;斜体文字&quot; FontStyle=&quot;Italic&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;微软雅黑&quot; FontFamily=&quot;Microsoft YaHei UI&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;大号字体&quot; FontSize=&quot;30&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;红色文字&quot; Foreground=&quot;Red&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;底色文字&quot; Foreground=&quot;Yellow&quot; Background=&quot;Red&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;内间距文字&quot; Foreground=&quot;Yellow&quot; Background=&quot;Red&quot; Padding=&quot;10&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Background=&quot;LightGray&quot; Height=&quot;25&quot;&gt; &lt;Run Foreground=&quot;Red&quot;&gt;这行文字&lt;/Run&gt; &lt;Run Foreground=&quot;Green&quot;&gt;由三部分&lt;/Run&gt; &lt;Run Foreground=&quot;Blue&quot;&gt;组成&lt;/Run&gt; &lt;/TextBlock&gt; &lt;Grid Width=&quot;150&quot; Height=&quot;100&quot; Margin=&quot;5&quot; Background=&quot;LightGoldenrodYellow&quot;&gt; &lt;TextBlock Text=&quot;这段文字体现了文字的文本换行属性TextWrapping&quot; TextWrapping=&quot;Wrap&quot; Margin=&quot;10&quot;/&gt; &lt;/Grid&gt; &lt;!--使用Run--&gt; &lt;Grid&gt; &lt;TextBlock x:Name=&quot;textblock&quot; Width=&quot;320&quot; Height=&quot;100&quot; FontSize=&quot;15&quot; FontFamily=&quot;微软雅黑&quot; FontWeight=&quot;Black&quot; FontStretch=&quot;Condensed&quot; Foreground=&quot;#dddddd&quot; Background=&quot;Teal&quot; TextAlignment=&quot;Center&quot; TextWrapping=&quot;Wrap&quot; TextTrimming=&quot;CharacterEllipsis&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Center&quot; LineHeight=&quot;30&quot; ToolTip=&quot;《临江仙·滚滚长江东逝水》&quot;&gt; &lt;Run Foreground=&quot;#CDB632&quot; TextDecorations=&quot;Underline&quot;&gt; 滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。 &lt;/Run&gt; &lt;Run Text=&quot;白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。 &quot;&gt; &lt;/Run&gt; &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/WrapPanel&gt;&lt;/Window&gt; TextBlock大多数的属性应用都比较简单，容易理解。Inlines属性是一个比较强大的属性，深入理解后，可以实现意想不到的效果。另外，TextEffects也是一个非常强大的属性，这需要掌握WPF的动画、触发器、关键帧等知识，才能实现文本的动画特效。我们将在学完动画后，再回头探讨这些内容。 与文本相关的还有两个输入控件，即TextBox和PasswordBox。下一节，我们来探讨TextBox。 TextBox文本框一、概述 几乎所有的文本、数字、符号的输入都是用TextBox文本框来完成的。TextBox用来获取用户的键盘输入的信息，这也是一个常用的控件。它继承于TextBoxBase，而TextBoxBase又继承于Control，我们在前面已经介绍过Control基类，我们先看看它及TextBoxBase基类的结构定义： 二、TextBoxBase基类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public abstract class TextBoxBase : Control&#123; public static readonly DependencyProperty IsReadOnlyProperty; public static readonly RoutedEvent SelectionChangedEvent; public static readonly RoutedEvent TextChangedEvent; public static readonly DependencyProperty IsSelectionActiveProperty; public static readonly DependencyProperty CaretBrushProperty; public static readonly DependencyProperty SelectionOpacityProperty; public static readonly DependencyProperty SelectionBrushProperty; public static readonly DependencyProperty AutoWordSelectionProperty; public static readonly DependencyProperty IsInactiveSelectionHighlightEnabledProperty; public static readonly DependencyProperty IsUndoEnabledProperty; public static readonly DependencyProperty VerticalScrollBarVisibilityProperty; public static readonly DependencyProperty HorizontalScrollBarVisibilityProperty; public static readonly DependencyProperty AcceptsTabProperty; public static readonly DependencyProperty AcceptsReturnProperty; public static readonly DependencyProperty IsReadOnlyCaretVisibleProperty; public static readonly DependencyProperty UndoLimitProperty; public double ViewportWidth &#123; get; &#125; public double ExtentHeight &#123; get; &#125; public double ExtentWidth &#123; get; &#125; public ScrollBarVisibility VerticalScrollBarVisibility &#123; get; set; &#125; public bool AcceptsReturn &#123; get; set; &#125; public SpellCheck SpellCheck &#123; get; &#125; public bool AcceptsTab &#123; get; set; &#125; public bool IsReadOnlyCaretVisible &#123; get; set; &#125; public double ViewportHeight &#123; get; &#125; public ScrollBarVisibility HorizontalScrollBarVisibility &#123; get; set; &#125; public double HorizontalOffset &#123; get; &#125; public double SelectionOpacity &#123; get; set; &#125; public bool CanUndo &#123; get; &#125; public bool CanRedo &#123; get; &#125; public bool IsUndoEnabled &#123; get; set; &#125; public int UndoLimit &#123; get; set; &#125; public bool AutoWordSelection &#123; get; set; &#125; public Brush SelectionBrush &#123; get; set; &#125; public bool IsReadOnly &#123; get; set; &#125; public Brush CaretBrush &#123; get; set; &#125; public bool IsSelectionActive &#123; get; &#125; public bool IsInactiveSelectionHighlightEnabled &#123; get; set; &#125; public double VerticalOffset &#123; get; &#125; public event TextChangedEventHandler TextChanged; public event RoutedEventHandler SelectionChanged; public void AppendText(string textData); public void BeginChange(); public void Copy(); public void Cut(); public IDisposable DeclareChangeBlock(); public void EndChange(); public void LineDown(); public void LineLeft(); public void LineRight(); public void LineUp(); public void LockCurrentUndoUnit(); public override void OnApplyTemplate(); public void PageDown(); public void PageLeft(); public void PageRight(); public void PageUp(); public void Paste(); public bool Redo(); public void ScrollToEnd(); public void ScrollToHome(); public void ScrollToHorizontalOffset(double offset); public void ScrollToVerticalOffset(double offset); public void SelectAll(); public bool Undo(); protected override void OnContextMenuOpening(ContextMenuEventArgs e); protected override void OnDragEnter(DragEventArgs e); protected override void OnDragLeave(DragEventArgs e); protected override void OnDragOver(DragEventArgs e); protected override void OnDrop(DragEventArgs e); protected override void OnGiveFeedback(GiveFeedbackEventArgs e); protected override void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected override void OnLostFocus(RoutedEventArgs e); protected override void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e); protected override void OnMouseDown(MouseButtonEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected override void OnMouseUp(MouseButtonEventArgs e); protected override void OnMouseWheel(MouseWheelEventArgs e); protected override void OnPreviewKeyDown(KeyEventArgs e); protected override void OnQueryContinueDrag(QueryContinueDragEventArgs e); protected override void OnQueryCursor(QueryCursorEventArgs e); protected virtual void OnSelectionChanged(RoutedEventArgs e); protected override void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate); protected virtual void OnTextChanged(TextChangedEventArgs e); protected override void OnTextInput(TextCompositionEventArgs e); &#125; 我们看一看TextBoxBase基类都提供了哪些成员 属性成员 属性名称 说明 VerticalScrollBarVisibility 垂直滚动条是否显示 HorizontalScrollBarVisibility 水平滚动条是否显示 AcceptsReturn 表示用户按下回车键时是否插入新行。 AcceptsTab 用来设置用户按下tab键的响应，为true表示插入一个制表符，否则将焦点移动到标记为制表位的下一个控件且不插入制表符。 IsReadOnlyCaretVisible 表示只读文本框是否显示插入符号，用得较少。 SelectionOpacity 用来设置用户选中的文本的透明度。 IsUndoEnabled 表示文本编辑控件是否启用撤消支持。 UndoLimit 获取或设置存储在撤消队列中的操作数目。 AutoWordSelection 表示自动选择字词，默认为false。 SelectionBrush 表示用户选择的文本段落的画笔，比较常用。 IsReadOnly 表示文本框是否只读，这个属性经常使用。 CaretBrush 表示获取或设置用于绘制的文本框中插入符号的画笔。 IsInactiveSelectionHighlightEnabled 表示获取或设置一个值，该值指示当文本框没有焦点时，文本框中是否显示选定的文本。 事件成员 TextBoxBase基类提供了两个事件，分别是TextChanged和SelectionChanged。 TextChanged事件：只要文本框中的内容被修改，将会触发引事件，这通常用来做一些判断业务。比如某个文本框只能输入数字，那就可以去订阅TextChanged事件。 SelectionChanged事件：选中的文本框内容发生改变时引发的事件。 三、TextBox控件 在了解TextBoxBase基类之后，我们来看看这个控件本身提供了哪些属性、方法和事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TextBox : TextBoxBase, IAddChild, ITextBoxViewHost&#123; public static readonly DependencyProperty TextWrappingProperty; public static readonly DependencyProperty MinLinesProperty; public static readonly DependencyProperty MaxLinesProperty; public static readonly DependencyProperty TextProperty; public static readonly DependencyProperty CharacterCasingProperty; public static readonly DependencyProperty MaxLengthProperty; public static readonly DependencyProperty TextAlignmentProperty; public static readonly DependencyProperty TextDecorationsProperty; public TextBox(); public int MinLines &#123; get; set; &#125; public int MaxLines &#123; get; set; &#125; public string Text &#123; get; set; &#125; public CharacterCasing CharacterCasing &#123; get; set; &#125; public int MaxLength &#123; get; set; &#125; public TextAlignment TextAlignment &#123; get; set; &#125; public int CaretIndex &#123; get; set; &#125; public int SelectionLength &#123; get; set; &#125; public int SelectionStart &#123; get; set; &#125; public Typography Typography &#123; get; &#125; public int LineCount &#123; get; &#125; public TextDecorationCollection TextDecorations &#123; get; set; &#125; public string SelectedText &#123; get; set; &#125; public TextWrapping TextWrapping &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public void Clear(); public int GetCharacterIndexFromLineIndex(int lineIndex); public int GetCharacterIndexFromPoint(Point point, bool snapToText); public int GetFirstVisibleLineIndex(); public int GetLastVisibleLineIndex(); public int GetLineIndexFromCharacterIndex(int charIndex); public int GetLineLength(int lineIndex); public string GetLineText(int lineIndex); public int GetNextSpellingErrorCharacterIndex(int charIndex, LogicalDirection direction); public Rect GetRectFromCharacterIndex(int charIndex, bool trailingEdge); public Rect GetRectFromCharacterIndex(int charIndex); public SpellingError GetSpellingError(int charIndex); public int GetSpellingErrorLength(int charIndex); public int GetSpellingErrorStart(int charIndex); public void ScrollToLine(int lineIndex); public void Select(int start, int length); public bool ShouldSerializeText(XamlDesignerSerializationManager manager); protected override Size MeasureOverride(Size constraint); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e); &#125; 属性成员 属性名称 说明 MinLines 获取或设置最小可见的行数。 MaxLines 获取或设置可见行的最大数目。 Text 获取或设置文本框的文本内容。 CharacterCasing 获取或设置文本框字符的大小写形式，默认不转换。 它是一个枚举，Normal表示不转换大小写，Lower表示全部转换成小写，Upper表示全部转换成大写 MaxLength 获取或设置最大可以在文本框中手动输入的字符数。 TextAlignment 获取或设置文本框的内容的水平对齐方式。例如左对齐，右对齐，居在对齐和两端对齐。 CaretIndex 获取或设置插入点移动的插入位置索引。 SelectionLength 获取或设置一个值，该值在文本框中当前所选内容中的字符数。 SelectionStart 获取或设置当前所选内容的起始位置的字符索引。 Typography 获取文本框中的文本内容的当前有效的版式变体。 LineCount 获取文本框中的总行数。 TextDecorations 获取要应用于文本框中的文本修饰。 SelectedText 获取或设置文本框中当前选择的内容。 TextWrapping 获取或设置文本框中文本的换行方式。这个属性比较常用，在较长的文字段落显示时可以设置为Wrap，这样自动换行，界面呈现的效果比较令人满意。 TextBox文本框本身没有任务事件，都是继承父类的事件。我们先看一下它的简单使用示例。 前端代码 1234567891011121314&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;用户名&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;_textbox&quot; Width=&quot;100&quot; Height=&quot;25&quot; MaxLength=&quot;10&quot; CharacterCasing=&quot;Upper&quot;/&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;确定&quot; Height=&quot;25&quot; Margin=&quot;5 0&quot; Click=&quot;_button_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; MessageBox.Show($&quot;您的用户名：&#123;_textbox.Text&#125;&quot;); &#125; &#125;&#125; 我们使用了CharacterCasing&#x3D;”Upper”这个设置，可以看到图片中的显示效果，虽然我在输入时是小写的china字符，但是，TextBox会转换成大写的CHINA，另外，总长度不能超过10个字符。 最后要获取TextBox文本框的内容，使用Text属性即可。当我们在学习了样式之后，我们还会回过头来，对TextBox控件进行深入学习。另外，TextBox还有一个大哥，也是继承于TextBoxBase基类，它叫RichTextBox 类。这个控件的功能更加强大，能够对FlowDocument流文档进行操作。如果您想开发类似Word的桌面软件，RichTextBox 和FlowDocument搭配组合是非常好的选择。 RichTextBox富文本框RichTextBox继承于TextBoxBase基类，所以很大程度上与TextBox控件类似，两者在某些情况下可以互相替换。但是，如果要为用户提供更强大的文档编辑功能，非RichTextBox莫属。在学习这个控件之前，请参阅FlowDocument（流文档）一节。 首先，我们来看看RichTextBox的结构定义： 1234567891011121314151617181920212223public class RichTextBox : TextBoxBase, IAddChild&#123; public static readonly DependencyProperty IsDocumentEnabledProperty; public RichTextBox(); public RichTextBox(FlowDocument document); public FlowDocument Document &#123; get; set; &#125; public bool IsDocumentEnabled &#123; get; set; &#125; public TextSelection Selection &#123; get; &#125; public TextPointer CaretPosition &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public TextPointer GetNextSpellingErrorPosition(TextPointer position, LogicalDirection direction); public TextPointer GetPositionFromPoint(Point point, bool snapToText); public SpellingError GetSpellingError(TextPointer position); public TextRange GetSpellingErrorRange(TextPointer position); public bool ShouldSerializeDocument(); protected override Size MeasureOverride(Size constraint); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo); &#125; RichTextBox控件有一个带参数的构造函数，参数的类型是FlowDocument类，另外，它还有一个Document属性，类型也是FlowDocument类，说明RichTextBox控件的元素必须且只能是FlowDocument类，如果您试图将RichTextBox.Document&#x3D;null，会发现它会报错。 我们假定您对FlowDocument类有一定的了解，所以，我们直接看一下示例。 前端代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;360&quot; Width=&quot;500&quot;&gt; &lt;StackPanel&gt; &lt;RichTextBox x:Name=&quot;_richTextBox&quot; Margin=&quot;10 5&quot; Height=&quot;270&quot;&gt; &lt;FlowDocument&gt; &lt;Paragraph&gt;RichTextBox富文本框控件到底有什么强大的功能? &lt;Bold Foreground=&quot;DarkRed&quot;&gt;请看下面.&lt;/Bold&gt; &lt;/Paragraph&gt; &lt;Paragraph Foreground=&quot;Blue&quot;&gt;RichTextBox唯一的子元素是FlowDocument&lt;/Paragraph&gt; &lt;Paragraph Foreground=&quot;DarkGreen&quot;&gt; FlowDocument是指流文档,一个流文档由一个或多个Block构成， 所以它有一个Blocks属性。Block只是一个抽象基类， 所以流文档的子元素其实是继承了Block的子类，例如： &lt;/Paragraph&gt; &lt;List MarkerOffset=&quot;25&quot; MarkerStyle=&quot;Decimal&quot; StartIndex=&quot;1&quot;&gt; &lt;ListItem&gt; &lt;Paragraph&gt;BlockUIContainer（UI元素容器）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;ListItem&gt; &lt;Paragraph&gt;List（有序列表）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;ListItem&gt; &lt;Paragraph&gt;Paragraph（段落）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;ListItem&gt; &lt;Paragraph&gt;Section（分组）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;ListItem&gt; &lt;Paragraph&gt;Table（网格）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;/List&gt; &lt;/FlowDocument&gt; &lt;/RichTextBox&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;确定&quot; Margin=&quot;10,5&quot; Click=&quot;_button_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 12345678910111213141516171819202122232425namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; TextRange textRange = new TextRange(_richTextBox.Document.ContentStart, _richTextBox.Document.ContentEnd); MessageBox.Show(textRange.Text); Paragraph paragraph = new Paragraph(); Run run = new Run($&quot;当前时间：&#123;DateTime.Now&#125;&quot;); //手动加换行 run.Foreground = Brushes.Black; paragraph.Inlines.Add(run); _richTextBox.Document.Blocks.Add(paragraph); &#125; &#125;&#125; 如上所示，我们在窗体中实例化了一个RichTextBox控件，并实例化了一个FlowDocument对象。RichTextBox唯一的子元素是FlowDocument， FlowDocument是指流文档,一个流文档由一个或多个Block构成，所以它有一个Blocks属性。Block只是一个抽象基类，FlowDocument流文档的子元素都继承了Block抽象基类，例如： BlockUIContainer（UI元素容器） List（有序列表） Paragraph（段落） Section（分组） Table（网格） BlockUIContainer是一个非常强大的段落元素，因为它可以直接包含WPF的控件。这样一来，我们就可以将设计的UI写入到流文档中显示或打印。 上面这五个元素继承了TextElement、FrameworkContentElement和ContentElement三个父素，所以实际上这五个子元素就拥有了许多字体属性的设置、资源、样式、数据绑定、以及各种事件的应用。 如果要获取RichTextBox的文本信息，可以使用TextRange类。FlowDocument类有两个属性，分别ContentStart和ContentEnd，表示文字内容的开始和结束。 所以通过TextRange类的Text，我们就能访问到RichTextBox控件的内容。 ToolTip控件（提示工具）ToolTip控件继承于ContentControl，它不能有逻辑或视觉父级，意思是说，它不能单独存在于WPF的视觉树上（不能以控件的形式实例化），它必须依附于某个控件。因为它的功能被设计成提示信息，当鼠标移动到某个控件上方时，悬停一会儿，就会显示这个ToolTip的内容。 通常ToolTip会显示一句话，用来阐述某个控件的说明。这个控件存在于FrameworkElement基类中，也就是ToolTip属性，这个属性在FrameworkElement虽然被声明成object，而不是ToolTip类型，但是，我们仍然可以自定义ToolTip的内容。重点：WPF几乎所有控件都可以拥有ToolTip小型提示弹窗！ 因为ToolTip继承于ContentControl控件，所以，ToolTip拥有的Content属性就可以显示任何类型，比如字符串、图像、其它控件组合布局。 123456789101112131415161718192021222324252627282930313233343536public class ToolTip : ContentControl&#123; public static readonly DependencyProperty HorizontalOffsetProperty; public static readonly RoutedEvent OpenedEvent; public static readonly DependencyProperty StaysOpenProperty; public static readonly DependencyProperty CustomPopupPlacementCallbackProperty; public static readonly DependencyProperty PlacementProperty; public static readonly RoutedEvent ClosedEvent; public static readonly DependencyProperty PlacementTargetProperty; public static readonly DependencyProperty HasDropShadowProperty; public static readonly DependencyProperty IsOpenProperty; public static readonly DependencyProperty VerticalOffsetProperty; public static readonly DependencyProperty PlacementRectangleProperty; public ToolTip(); public bool IsOpen &#123; get; set; &#125; public bool StaysOpen &#123; get; set; &#125; public CustomPopupPlacementCallback CustomPopupPlacementCallback &#123; get; set; &#125; public PlacementMode Placement &#123; get; set; &#125; public Rect PlacementRectangle &#123; get; set; &#125; public UIElement PlacementTarget &#123; get; set; &#125; public double HorizontalOffset &#123; get; set; &#125; public double VerticalOffset &#123; get; set; &#125; public bool HasDropShadow &#123; get; set; &#125; public event RoutedEventHandler Closed; public event RoutedEventHandler Opened; protected virtual void OnClosed(RoutedEventArgs e); protected override void OnContentChanged(object oldContent, object newContent); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnOpened(RoutedEventArgs e); protected internal override void OnVisualParentChanged(DependencyObject oldParent); &#125; 简单使用 1&lt;Button Content=&quot;确定&quot; ToolTip=&quot;WPF中文网之控件课程&quot;/&gt; 自定义ToolTip内容 1234567891011121314&lt;Button x:Name=&quot;button2&quot; Content=&quot;网站&quot; Width=&quot;100&quot; Height=&quot;30&quot; Margin=&quot;5&quot; Click=&quot;button2_Click&quot;&gt; &lt;Button.ToolTip&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;官方网站&quot; FontWeight=&quot;Bold&quot; /&gt; &lt;TextBlock Text=&quot;点击这个按钮，进入WPF中文网站&quot;/&gt; &lt;Border BorderBrush=&quot;Silver&quot; BorderThickness=&quot;0,1,0,0&quot; Margin=&quot;0,4&quot;/&gt; &lt;TextBlock Text=&quot;http://www.wpfsoft.com&quot; FontStyle=&quot;Italic&quot;/&gt; &lt;/StackPanel&gt; &lt;/Button.ToolTip&gt;&lt;/Button&gt;private void button2_Click(object sender, RoutedEventArgs e)&#123; Process.Start(&quot;http://www.wpfsoft.com&quot;);&#125; 虽然ToolTip可以自定义内容，但是，ToolTip的内容无法接收焦点。 与ToolTip有点类似的控件，还有一个叫Popup控件，也是一个弹出窗口，并可以在这个窗口内任意布局。我们在下一节来探讨它。 Popup弹出窗口Popup类似于ToolTip，在指定的元素或窗体中弹出一个具有任意内容的窗口。Popup继承于FrameworkElement，算得上是独门独户的控件，因为大多数控件都是从Shape、Control或Panel三个类继承而来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Popup : FrameworkElement, IAddChild&#123; public static readonly DependencyProperty ChildProperty; public static readonly DependencyProperty IsOpenProperty; public static readonly DependencyProperty PlacementProperty; public static readonly DependencyProperty CustomPopupPlacementCallbackProperty; public static readonly DependencyProperty StaysOpenProperty; public static readonly DependencyProperty HorizontalOffsetProperty; public static readonly DependencyProperty VerticalOffsetProperty; public static readonly DependencyProperty PlacementTargetProperty; public static readonly DependencyProperty PlacementRectangleProperty; public static readonly DependencyProperty PopupAnimationProperty; public static readonly DependencyProperty AllowsTransparencyProperty; public static readonly DependencyProperty HasDropShadowProperty; public Popup(); public bool HasDropShadow &#123; get; &#125; public bool AllowsTransparency &#123; get; set; &#125; public PopupAnimation PopupAnimation &#123; get; set; &#125; public Rect PlacementRectangle &#123; get; set; &#125; public UIElement PlacementTarget &#123; get; set; &#125; public double VerticalOffset &#123; get; set; &#125; public double HorizontalOffset &#123; get; set; &#125; public bool StaysOpen &#123; get; set; &#125; public UIElement Child &#123; get; set; &#125; public bool IsOpen &#123; get; set; &#125; public PlacementMode Placement &#123; get; set; &#125; public CustomPopupPlacementCallback CustomPopupPlacementCallback &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public event EventHandler Closed; public event EventHandler Opened; public static void CreateRootPopup(Popup popup, UIElement child); protected override Size MeasureOverride(Size availableSize); protected virtual void OnClosed(EventArgs e); protected virtual void OnOpened(EventArgs e); protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e); protected override void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e); protected override void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e); protected internal override DependencyObject GetUIParentCore(); &#125; 属性成员 属性名称 说明 HasDropShadow 只读属性，控件是否有投影效果。 AllowsTransparency 获取或设置控件是否包含透明内容。 PopupAnimation 获取或设置控件打开或关闭时的动画效果，None表示没有动画，Fade表示逐渐显示或淡出，Slide表示向上向下滑入，Scroll表示滚动效果。 PlacementRectangle 获取或设置控件打开时的矩形位置 。 PlacementTarget 获取或设置Popup控件在哪个控件身边打开（重点）。 VerticalOffset 获取或设置目标原点和 popup 对齐点之间的垂直距离。 HorizontalOffset 获取或设置目标原点和弹出项对齐之间的水平距离点。 StaysOpen 默认值为true，表示Popup打开后，如果失去焦点，Popup是否继续显示（重点）。 Child 获取或设置控件的内容，类似于ContentControl的Content属性，只能拥有一个元素（重点）。 IsOpen 获取或设置Popup控件是否可见。 Placement 枚举类，表示Popup 控件显示时的对齐方式。 事件成员 Opened事件：Popup控件打开时引发的事件。 Closed事件：Popup控件关闭时引发的事件 12345678910111213141516171819202122232425&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;CheckBox x:Name=&quot;checkbox&quot; Content=&quot;WPF中文网&quot; Height=&quot;30&quot; Margin=&quot;5&quot; ToolTip=&quot;WPF中文网之控件课程&quot;/&gt; &lt;Popup Name=&quot;myPopup&quot; IsOpen=&quot;&#123;Binding IsChecked, ElementName=checkbox&#125;&quot; PlacementTarget=&quot;&#123;Binding ElementName=checkbox&#125;&quot; StaysOpen=&quot;True&quot;&gt; &lt;Border BorderThickness=&quot;1&quot; Background=&quot;LightBlue&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;官方网站&quot; FontWeight=&quot;Bold&quot; /&gt; &lt;TextBlock Text=&quot;点击这个按钮，进入WPF中文网站&quot;/&gt; &lt;Border BorderBrush=&quot;Silver&quot; BorderThickness=&quot;0,1,0,0&quot; Margin=&quot;0,4&quot;/&gt; &lt;TextBlock Text=&quot;http://www.wpfsoft.com&quot; FontStyle=&quot;Italic&quot;/&gt; &lt;/StackPanel&gt; &lt;/Border&gt; &lt;/Popup&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 代码分析 我们分别实例化了名叫checkbox和myPopup控件，myPopup的IsOpen属性绑定了checkbox的IsChecked，意思是， 当用户点击checkbox时，checkbox的IsChecked属性为true，myPopup的IsOpen属性也为true，于是就可以显示myPopup的内容了。 同时，myPopup的PlacementTarget属性也绑定到了checkbox控件，意味着myPopup将显示在checkbox控件身边，至于具体位置，可以设置Placement属性，有兴趣的小伙伴可以去尝试一下。 这里我们用到了Binding这个类，可以把它看成是一座桥梁，我们会在后面专门详细讲解Binding的用法。 Image图像控件Image也算是独门独户的控件，因为它也是直接继承于FrameworkElement基类。Image控件，顾名思义，就是图像显示控件。Image类能够加载显示的图片格式有.bmp、.gif、.ico、.jpg、.png、.wdp 和 .tiff。要注意的是，加载.gif动画图片时，仅显示第一帧。如果要显示gif图片，可以在nuget服务器中下载WpfAnimatedGif组件。 一、Image类的定义 12345678910111213141516171819202122232425public class Image : FrameworkElement, IUriContext, IProvidePropertyFallback&#123; public static readonly DependencyProperty SourceProperty; public static readonly RoutedEvent DpiChangedEvent; public static readonly DependencyProperty StretchProperty; public static readonly DependencyProperty StretchDirectionProperty; public static readonly RoutedEvent ImageFailedEvent; public Image(); public StretchDirection StretchDirection &#123; get; set; &#125; public Stretch Stretch &#123; get; set; &#125; public ImageSource Source &#123; get; set; &#125; protected virtual Uri BaseUri &#123; get; set; &#125; public event DpiChangedEventHandler DpiChanged; public event EventHandler&lt;ExceptionRoutedEventArgs&gt; ImageFailed; protected override Size ArrangeOverride(Size arrangeSize); protected override Size MeasureOverride(Size constraint); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi); protected override void OnRender(DrawingContext dc); &#125; 二、属性成员 属性名称 说明 StretchDirection 枚举型，表示图像缩放的条件，UpOnly表示内容仅在小于父级时缩放；DownOnly表示内容仅大于父级时缩放；Both表示兼容前面两种缩放条件。 Stretch 枚举型，表示图像缩放的模式，None表示内容保持其原始大小；Fill表示调整内容大小以填充目标尺寸，且不保留纵横比；Uniform表示在保留纵横比基础上缩放；UniformToFill表示在保留纵横比基础上缩放，同时具有裁剪功能。 Source 图像源，其类型为ImageSource。 BaseUri 获取或设置基 统一资源标识符 (URI) 为 System.Windows.Controls.Image。 三、事件成员 事件名称 说明 DpiChanged 显示图像的屏幕的 DPI 发生更改后触发。 ImageFailed 在图像中失败时触发。 四、Image控件分析 Image控件最关键的就是Source属性——即ImageSource类型。ImageSource是一个抽象类，表示具有高度、宽度及ImageMetadata对象的图像数据源。ImageSource有多个子类，如BitmapFrame、BitmapSource和DrawingImage。所以，我们如果要显示一张图片，需要将图片转化成BitmapSource或DrawingImage实例，赋值给Image控件的Source属性就行了。 4.1常规图片加载 例如：http://www.wpfsoft.com/wp-content/uploads/2023/08/2023080309592548.png 我们将上面这张图片下载后，导到入HelloWorld项目的Images目录中，然后就可以在前端代码中显示。 1&lt;Image Source=&quot;/Images/logo.png&quot; Width=&quot;120&quot; Height=&quot;120&quot;/&gt; 或者 统一资源标识Uri WPF引入了统一资源标识Uri(Unified Resource Identifier)来标识和访问资源。其中较为常见的情况是用Uri加载图像。Uri表达式的一般形式为：协议+授权+路径，协议：pack:&#x2F;&#x2F;，授权：有两种。一种用于访问编译时已经知道的文件，用application:&#x2F;&#x2F;&#x2F;一种用于访问编译时不知道、运行时才知道的文件，用siteoforigin:&#x2F;&#x2F;&#x2F;一般用逗号代替斜杠，也就是改写作application:,和pack:,路径：分为绝对路径和相对路径。一般选用相对路径，普适性更强 1&lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;120&quot; Height=&quot;120&quot;/&gt; 明明Source是ImageSource类型，为什么可以接受一个代表图片路径的字符串呢？因为ImageSource类中有一个ToString()重载成员。 4.2本地图片加载 接下来，我们把这个张图片放到Debug目录中，试试用另一种方式加载本地图片。 此时，这张图片并没有导入到项目中，我们来看一下如何加载本地图片。 前端代码 1234&lt;WrapPanel&gt; &lt;Image Source=&quot;/Images/logo.png&quot; Width=&quot;120&quot; Height=&quot;120&quot;/&gt; &lt;Image x:Name=&quot;image2&quot; Width=&quot;120&quot; Height=&quot;120&quot;/&gt;&lt;/WrapPanel&gt; 后端代码 12345678910public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); var path = Environment.CurrentDirectory + &quot;\\\\&quot; + &quot;logo.png&quot;; var imageSource = BitmapFrame.Create(new Uri(path), BitmapCreateOptions.None, BitmapCacheOption.OnLoad); image2.Source = imageSource; &#125;&#125; 在主窗体的构造函数中，我们获取了图片的完整地址，然后利用BitmapFrame类Create方法成员将本地图片加载进来并返回一个BitmapFrame对象，BitmapFrame对象继承于BitmapSource，所以我们可以将这个实例通过C#代码的方式赋值给image2的Source属性。 GroupBox标题容器控件GroupBox控件的功能是提供一个带标题的内容容器，它继承于HeaderedContentControl类，HeaderedContentControl继承于ContentControl类。通常它用来做一些局部的布局。由于GroupBox本身并没有什么成员，所以我们直接观察它的基类。 一、HeaderedContentControl基类 123456789101112131415161718192021222324public class HeaderedContentControl : ContentControl&#123; public static readonly DependencyProperty HeaderProperty; public static readonly DependencyProperty HasHeaderProperty; public static readonly DependencyProperty HeaderTemplateProperty; public static readonly DependencyProperty HeaderTemplateSelectorProperty; public static readonly DependencyProperty HeaderStringFormatProperty; public HeaderedContentControl(); public DataTemplateSelector HeaderTemplateSelector &#123; get; set; &#125; public DataTemplate HeaderTemplate &#123; get; set; &#125; public string HeaderStringFormat &#123; get; set; &#125; public bool HasHeader &#123; get; &#125; public object Header &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public override string ToString(); protected virtual void OnHeaderChanged(object oldHeader, object newHeader); protected virtual void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat); protected virtual void OnHeaderTemplateChanged(DataTemplate oldHeaderTemplate, DataTemplate newHeaderTemplate); protected virtual void OnHeaderTemplateSelectorChanged(DataTemplateSelector oldHeaderTemplateSelector, DataTemplateSelector newHeaderTemplateSelector); &#125; 在这个基类中，我们可以看到他继承于ContentControl基类，所以GroupBox要显示的内容都会放到Content属性中，而GroupBox的标题则放在Header属性中，注意，Header属性也是object。这足以说明GroupBox在私人定制方面的强大扩展性。 再加上HeaderTemplate属性，可以定制标题的外观。待我们在后面学了模板和样式，再回头来探讨这一类的属性的应用。 GroupBox的简单用法如下： 12345678910111213141516171819202122232425262728293031323334&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;GroupBox Header=&quot;缩略图&quot; Margin=&quot;5&quot;&gt; &lt;WrapPanel&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;/WrapPanel&gt; &lt;/GroupBox&gt;&lt;/Window&gt; 因为GroupBox的Content属性只能显示一个内容对象，如果要显示多个对象，那把给Content一个集合控件，比如上面的WrapPanel控件，这样就可以在WrapPanel控件中放多个子元素了。 在使用上，有一个集合控件与GroupBox类似，因为GroupBox只能显示一个区域，如果区域过大，在有限的窗体无法全部显示出来，该怎么办呢？ScrollViewer可以做到这一点。 下一节，我们来探讨一下ScrollViewer控件的用法。 ScrollViewer控件如果某个控件的尺寸太大，当前界面无法全部显示，则可以将这个控件包含在ScrollViewer中，因为ScrollViewer控件封装了一个水平滚动条ScrollBar和一个垂直滚动条ScrollBar，所以，ScrollViewer就是一个包含其它可视元素的可滚动区域控件。 ScrollViewer继承于ContentControl，所以它也是一个内容控件，只能在Content属性中设置一个子元素，如果要在ScrollViewer中显示多个子元素，请设置一个集合控件。 ScrollViewer 控件既响应鼠标命令，也响应键盘命令，并定义许多可用于按预设的增量滚动内容的方法。 可以使用 ScrollChanged 事件来检测 ScrollViewer 状态的变化。 一、ScrollViewer类的定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class ScrollViewer : ContentControl&#123; public static readonly DependencyProperty CanContentScrollProperty; public static readonly DependencyProperty PanningRatioProperty; public static readonly DependencyProperty PanningDecelerationProperty; public static readonly DependencyProperty PanningModeProperty; public static readonly RoutedEvent ScrollChangedEvent; public static readonly DependencyProperty IsDeferredScrollingEnabledProperty; public static readonly DependencyProperty ViewportWidthProperty; public static readonly DependencyProperty ScrollableHeightProperty; public static readonly DependencyProperty ScrollableWidthProperty; public static readonly DependencyProperty ExtentHeightProperty; public static readonly DependencyProperty ViewportHeightProperty; public static readonly DependencyProperty ContentHorizontalOffsetProperty; public static readonly DependencyProperty ContentVerticalOffsetProperty; public static readonly DependencyProperty HorizontalOffsetProperty; public static readonly DependencyProperty ExtentWidthProperty; public static readonly DependencyProperty VerticalOffsetProperty; public static readonly DependencyProperty ComputedVerticalScrollBarVisibilityProperty; public static readonly DependencyProperty ComputedHorizontalScrollBarVisibilityProperty; public static readonly DependencyProperty VerticalScrollBarVisibilityProperty; public static readonly DependencyProperty HorizontalScrollBarVisibilityProperty; public ScrollViewer(); public bool CanContentScroll &#123; get; set; &#125; public ScrollBarVisibility HorizontalScrollBarVisibility &#123; get; set; &#125; public ScrollBarVisibility VerticalScrollBarVisibility &#123; get; set; &#125; public Visibility ComputedHorizontalScrollBarVisibility &#123; get; &#125; public Visibility ComputedVerticalScrollBarVisibility &#123; get; &#125; public double HorizontalOffset &#123; get; &#125; public double VerticalOffset &#123; get; &#125; public double ExtentWidth &#123; get; &#125; public double ExtentHeight &#123; get; &#125; public double PanningDeceleration &#123; get; set; &#125; public double ScrollableHeight &#123; get; &#125; public double ViewportWidth &#123; get; &#125; public double ViewportHeight &#123; get; &#125; public double ContentVerticalOffset &#123; get; &#125; public double ContentHorizontalOffset &#123; get; &#125; public bool IsDeferredScrollingEnabled &#123; get; set; &#125; public PanningMode PanningMode &#123; get; set; &#125; public double ScrollableWidth &#123; get; &#125; public double PanningRatio &#123; get; set; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; protected internal IScrollInfo ScrollInfo &#123; get; set; &#125; public event ScrollChangedEventHandler ScrollChanged; public static bool GetCanContentScroll(DependencyObject element); public static ScrollBarVisibility GetHorizontalScrollBarVisibility(DependencyObject element); public static bool GetIsDeferredScrollingEnabled(DependencyObject element); public static double GetPanningDeceleration(DependencyObject element); public static PanningMode GetPanningMode(DependencyObject element); public static double GetPanningRatio(DependencyObject element); public static ScrollBarVisibility GetVerticalScrollBarVisibility(DependencyObject element); public static void SetCanContentScroll(DependencyObject element, bool canContentScroll); public static void SetHorizontalScrollBarVisibility(DependencyObject element, ScrollBarVisibility horizontalScrollBarVisibility); public static void SetIsDeferredScrollingEnabled(DependencyObject element, bool value); public static void SetPanningDeceleration(DependencyObject element, double value); public static void SetPanningMode(DependencyObject element, PanningMode panningMode); public static void SetPanningRatio(DependencyObject element, double value); public static void SetVerticalScrollBarVisibility(DependencyObject element, ScrollBarVisibility verticalScrollBarVisibility); public void InvalidateScrollInfo(); public void LineDown(); public void LineLeft(); public void LineRight(); public void LineUp(); public override void OnApplyTemplate(); public void PageDown(); public void PageLeft(); public void PageRight(); public void PageUp(); public void ScrollToBottom(); public void ScrollToEnd(); public void ScrollToHome(); public void ScrollToHorizontalOffset(double offset); public void ScrollToLeftEnd(); public void ScrollToRightEnd(); public void ScrollToTop(); public void ScrollToVerticalOffset(double offset); protected override Size ArrangeOverride(Size arrangeSize); protected override HitTestResult HitTestCore(PointHitTestParameters hitTestParameters); protected override Size MeasureOverride(Size constraint); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnKeyDown(KeyEventArgs e); protected override void OnManipulationCompleted(ManipulationCompletedEventArgs e); protected override void OnManipulationDelta(ManipulationDeltaEventArgs e); protected override void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e); protected override void OnManipulationStarting(ManipulationStartingEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseWheel(MouseWheelEventArgs e); protected virtual void OnScrollChanged(ScrollChangedEventArgs e); protected override void OnStylusSystemGesture(StylusSystemGestureEventArgs e); &#125; 二、属性成员 HorizontalScrollBarVisibility：是否隐藏水平滚动条，为true表示隐藏，此时水平方向不可滚动。 VerticalScrollBarVisibility：是否隐藏垂直滚动条，为true表示隐藏，此时垂直方向不可滚动。 三、事件成员 ScrollChanged：当控件的滚动位置发生变化时将触发此事件。 四、示例 前端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;ScrollViewer&gt; &lt;WrapPanel&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;/WrapPanel&gt; &lt;/ScrollViewer&gt;&lt;/Window&gt; 如上所示，我们在WrapPanel中增加了许多子元素，然后在外面套了一层ScrollViewer，由于WrapPanel是自动换行显示所有子元素（图片），所以，ScrollViewer会做出相应适配，只显示垂直滚动条。 既然ScrollViewer类封装了两个滚动条（ScrollBar），那我们就必须要了解一下ScrollBar的特性与用法，以加强我们对WPF控件的运用能力。下一节，我们将介绍ScrollBar。 ScrollBar滚动条ScrollBar表示一个滚动条，该滚动条具有一个滑动 Thumb，其位置对应于一个值。它继承于RangeBase抽象基类，RangeBase基类继承于Control基类。带滚动特质的还有两个控件，也继承于RangeBase抽象基类，它们分别是ProgressBar（进度条）和Slider（滑动条）。待我们探讨完ScrollBar，再来探讨ProgressBar和Slider。 一、RangeBase抽象基类定义 12345678910111213141516171819202122232425public abstract class RangeBase : Control&#123; public static readonly RoutedEvent ValueChangedEvent; public static readonly DependencyProperty MinimumProperty; public static readonly DependencyProperty MaximumProperty; public static readonly DependencyProperty ValueProperty; public static readonly DependencyProperty LargeChangeProperty; public static readonly DependencyProperty SmallChangeProperty; protected RangeBase(); public double LargeChange &#123; get; set; &#125; public double SmallChange &#123; get; set; &#125; public double Value &#123; get; set; &#125; public double Maximum &#123; get; set; &#125; public double Minimum &#123; get; set; &#125; public event RoutedPropertyChangedEventHandler&lt;double&gt; ValueChanged; public override string ToString(); protected virtual void OnMaximumChanged(double oldMaximum, double newMaximum); protected virtual void OnMinimumChanged(double oldMinimum, double newMinimum); protected virtual void OnValueChanged(double oldValue, double newValue); &#125; RangeBase 只有5个属性 属性名称 说明 LargeChange 表示给Value属性加减的最大值。默认为1 SmallChange 表示给Value属性加减的最小值。默认为0.1 Value 获取或设置范围控件的当前数量。默认为0 Maximum 获取或设置Value属性的最大值 Minimum 获取或设置Value属性的最小值 RangeBase事件成员 ValueChanged：当前Value属性发生改变时触发的事件。 总结，ScrollBar、ProgressBar和Slider都将继承上面的属性、方面与事件成员。 二、ScrollBar类定义 123456789101112131415161718192021222324252627282930313233343536373839404142public class ScrollBar : RangeBase&#123; public static readonly RoutedEvent ScrollEvent; public static readonly RoutedCommand ScrollHereCommand; public static readonly RoutedCommand DeferScrollToVerticalOffsetCommand; public static readonly RoutedCommand DeferScrollToHorizontalOffsetCommand; public static readonly RoutedCommand ScrollToVerticalOffsetCommand; public static readonly RoutedCommand ScrollToHorizontalOffsetCommand; public static readonly RoutedCommand ScrollToTopCommand; public static readonly RoutedCommand ScrollToLeftEndCommand; public static readonly RoutedCommand ScrollToRightEndCommand; public static readonly RoutedCommand ScrollToHomeCommand; public static readonly RoutedCommand ScrollToEndCommand; public static readonly RoutedCommand ScrollToBottomCommand; public static readonly RoutedCommand PageLeftCommand; public static readonly RoutedCommand PageDownCommand; public static readonly RoutedCommand PageUpCommand; public static readonly RoutedCommand LineRightCommand; public static readonly RoutedCommand PageRightCommand; public static readonly RoutedCommand LineLeftCommand; public static readonly RoutedCommand LineDownCommand; public static readonly RoutedCommand LineUpCommand; public static readonly DependencyProperty ViewportSizeProperty; public static readonly DependencyProperty OrientationProperty; public ScrollBar(); public Orientation Orientation &#123; get; set; &#125; public double ViewportSize &#123; get; set; &#125; public Track Track &#123; get; &#125; protected override bool IsEnabledCore &#123; get; &#125; public event ScrollEventHandler Scroll; public override void OnApplyTemplate(); protected override void OnContextMenuClosing(ContextMenuEventArgs e); protected override void OnContextMenuOpening(ContextMenuEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e); &#125; ScrollBar自身有两个属性是我们必须要掌握的，那就是Orientation 和ViewportSize 。 Orientation ：表示当前滚动条是水平的还是垂直的。 ViewportSize：获取或设置当前可见的可滚动内容的数量。默认值为0。 另外，它还有一个滚动事件Scroll可以使用。我们还是以实际的例子来说明它的用法吧。 前端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid x:Name=&quot;viewport&quot; &gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;115&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Canvas&gt; &lt;StackPanel x:Name=&quot;element&quot; Orientation=&quot;Horizontal&quot; Canvas.Left=&quot;&#123;Binding CanvasLeft&#125;&quot;&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;/Canvas&gt; &lt;ScrollBar Grid.Row=&quot;1&quot; Orientation=&quot;Horizontal&quot; Maximum=&quot;&#123;Binding Maximum&#125;&quot; Value=&quot;&#123;Binding X&#125;&quot; ViewportSize=&quot;&#123;Binding ElementName=viewport,Path=ActualWidth&#125;&quot;/&gt; &lt;TextBlock Grid.Row=&quot;2&quot; Text=&quot;ScrollBar&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; FontSize=&quot;24&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 观察这个UI设计，我们故意在StackPanel控件中增加了多张图片，使其不能完全在Canvas中显示出来，然后在下面实例化了一根水平滚动条。注意滚动条的其中三个参数使用了绑定，不熟悉的小伙伴可参阅数据绑定那一章节。 Maximum：表示这根滚动条的最大值。 Value：表示滚动条的当前值。 ViewportSize：表示滚动条要作用于某个控件的宽度（这里实际上指Grid的宽度）。 最后，我们将StackPanel控件的Canvas.Left依赖属性绑定到一个CanvasLeft属性。只要CanvasLeft属性的值发生改变，那么StackPanel相对于Canvas水平位置就发生改变。 那么CanvasLeft属性是怎样发生改变的呢？这一切将在后台代码中实现。 后端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System.ComponentModel;using System.Windows; namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window,INotifyPropertyChanged &#123; public MainWindow() &#123; InitializeComponent(); DataContext = this;//将当前窗体作为ViewModel赋值给当前窗体的DataContext Loaded += (s, e) =&gt; &#123; //计算滚动条的最大值 Maximum = element.ActualWidth - viewport.ActualWidth; &#125;; &#125; private double maximum = 0; /// &lt;summary&gt; /// 滚动条的最大值 /// &lt;/summary&gt; public double Maximum &#123; get &#123; return maximum; &#125; set &#123; maximum = value; NotifyPropertyChanged(&quot;Maximum&quot;); &#125; &#125; private double x = 0; /// &lt;summary&gt; /// 滚动条的当前值 /// &lt;/summary&gt; public double X &#123; get &#123; return x; &#125; set &#123; x = value; CanvasLeft = -x; NotifyPropertyChanged(&quot;X&quot;); &#125; &#125; private double canvasLeft = 0; /// &lt;summary&gt; /// 相对于Canvas控件Left边距 /// &lt;/summary&gt; public double CanvasLeft &#123; get &#123; return canvasLeft; &#125; set &#123; canvasLeft = value; NotifyPropertyChanged(&quot;CanvasLeft&quot;); &#125; &#125; public event PropertyChangedEventHandler PropertyChanged; /// &lt;summary&gt; /// 属性通知方法 /// &lt;/summary&gt; /// &lt;param name=&quot;propertyName&quot;&gt;&lt;/param&gt; protected virtual void NotifyPropertyChanged(string propertyName) &#123; if (this.PropertyChanged != null) &#123; this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); &#125; &#125; &#125;&#125; 如上所示，我们获取到滚动条的值X，然后取反后赋值给CanvasLeft属性，而CanvasLeft属性拥有“属性通知”功能，故而前端StackPanel的相对位置会随着用户拖动滚动条而变化。 关于属性通知及INotifyPropertyChanged接口，我们将在数据绑定一章讲解。 掌握了ScrollBar的用法后，Slider控件也基本就掌握了，下一节，我们来探讨Slider。对了，如果把下面这段代码换成Slider控件，也是可以用的哦。 更换前 1234&lt;ScrollBar Grid.Row=&quot;1&quot; Orientation=&quot;Horizontal&quot; Maximum=&quot;&#123;Binding Maximum&#125;&quot; Value=&quot;&#123;Binding X&#125;&quot; ViewportSize=&quot;&#123;Binding ElementName=viewport,Path=ActualWidth&#125;&quot;/&gt; 更换后 1&lt;Slider Grid.Row=&quot;1&quot; Maximum=&quot;&#123;Binding Maximum&#125;&quot; Value=&quot;&#123;Binding X&#125;&quot;/&gt; Slider滑动条Slider滑动条与ScrollBar滚动条有点相似，甚至某些情况下，两者还可以互换使用。Slider也继承于RangeBase基类，其功能是提供一个可以滑动取值的控件。 一、Slider类定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Slider : RangeBase&#123; public static readonly DependencyProperty OrientationProperty; public static readonly DependencyProperty IsMoveToPointEnabledProperty; public static readonly DependencyProperty SelectionEndProperty; public static readonly DependencyProperty SelectionStartProperty; public static readonly DependencyProperty IsSelectionRangeEnabledProperty; public static readonly DependencyProperty TickFrequencyProperty; public static readonly DependencyProperty TickPlacementProperty; public static readonly DependencyProperty TicksProperty; public static readonly DependencyProperty AutoToolTipPrecisionProperty; public static readonly DependencyProperty AutoToolTipPlacementProperty; public static readonly DependencyProperty IntervalProperty; public static readonly DependencyProperty DelayProperty; public static readonly DependencyProperty IsDirectionReversedProperty; public static readonly DependencyProperty IsSnapToTickEnabledProperty; public Slider(); public static RoutedCommand MinimizeValue &#123; get; &#125; public static RoutedCommand IncreaseSmall &#123; get; &#125; public static RoutedCommand DecreaseSmall &#123; get; &#125; public static RoutedCommand MaximizeValue &#123; get; &#125; public static RoutedCommand DecreaseLarge &#123; get; &#125; public static RoutedCommand IncreaseLarge &#123; get; &#125; public bool IsSnapToTickEnabled &#123; get; set; &#125; public int AutoToolTipPrecision &#123; get; set; &#125; public AutoToolTipPlacement AutoToolTipPlacement &#123; get; set; &#125; public int Interval &#123; get; set; &#125; public int Delay &#123; get; set; &#125; public bool IsDirectionReversed &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; public double TickFrequency &#123; get; set; &#125; public DoubleCollection Ticks &#123; get; set; &#125; public double SelectionStart &#123; get; set; &#125; public TickPlacement TickPlacement &#123; get; set; &#125; public bool IsSelectionRangeEnabled &#123; get; set; &#125; public bool IsMoveToPointEnabled &#123; get; set; &#125; public double SelectionEnd &#123; get; set; &#125; public override void OnApplyTemplate(); protected override Size ArrangeOverride(Size finalSize); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnDecreaseLarge(); protected virtual void OnDecreaseSmall(); protected virtual void OnIncreaseLarge(); protected virtual void OnIncreaseSmall(); protected virtual void OnMaximizeValue(); protected override void OnMaximumChanged(double oldMaximum, double newMaximum); protected virtual void OnMinimizeValue(); protected override void OnMinimumChanged(double oldMinimum, double newMinimum); protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e); protected virtual void OnThumbDragCompleted(DragCompletedEventArgs e); protected virtual void OnThumbDragDelta(DragDeltaEventArgs e); protected virtual void OnThumbDragStarted(DragStartedEventArgs e); protected override void OnValueChanged(double oldValue, double newValue); &#125; 二、属性成员 属性名称 说明 IsSnapToTickEnabled Slider会有一些刻度线，如果要求Thumb移动到最近的刻度线，则可将该值设置为true。 AutoToolTipPrecision 获取或设置Slider的值的小数点位数。 AutoToolTipPlacement 获取或设置按下Thumb时是否显示提示工具。 Interval 获取或设置用户按下RepeatButton时执行增加减少命令的时间间隔（毫秒）。 Delay 获取或设置用户按下RepeatButton时延时多少毫秒后执行命令 IsDirectionReversed 获取或设置增加值的方向。 Orientation 获取或设置Slider的方向。水平或垂直。 TickFrequency 获取或设置刻度线之间的间隔。默认为1.0 Ticks 获取或设置为 System.Windows.Controls.Slider 显示的刻度线的位置。 SelectionStart 获取或设置 System.Windows.Controls.Slider 的指定选择内容的最大值。 TickPlacement 获取或设置刻度线的位置 IsSelectionRangeEnabled 获取或设置显示选择范围 IsMoveToPointEnabled 如果Thumb 立即移动到鼠标单击的位置，则为true。 SelectionEnd 获取或设置 System.Windows.Controls.Slider 的指定选择内容的最大值。 三、Slider示例 观察下面的例子，看看Slider如何通过拖动去改变元素的尺寸。 123456789101112131415161718192021222324252627&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid x:Name=&quot;viewport&quot; &gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Canvas&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Height=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot;/&gt; &lt;/Border&gt; &lt;/Canvas&gt; &lt;DockPanel Grid.Row=&quot;1&quot;&gt; &lt;TextBlock Text=&quot;滑动改变图片大小&quot; Margin=&quot;3&quot; FontSize=&quot;14&quot;/&gt; &lt;Slider x:Name=&quot;slider&quot; Minimum=&quot;50&quot; Maximum=&quot;500&quot; Value=&quot;50&quot; Margin=&quot;3&quot;/&gt; &lt;/DockPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; ProgressBar进度条ProgressBar进度条通常在我们执行某个任务需要花费大量时间时使用，这时可以采用进度条显示任务或线程的执行进度，以便给用户良好的使用体验。 一、ProgressBar类定义 1234567891011121314151617public class ProgressBar : RangeBase&#123; public static readonly DependencyProperty IsIndeterminateProperty; public static readonly DependencyProperty OrientationProperty; public ProgressBar(); public bool IsIndeterminate &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; public override void OnApplyTemplate(); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnMaximumChanged(double oldMaximum, double newMaximum); protected override void OnMinimumChanged(double oldMinimum, double newMinimum); protected override void OnValueChanged(double oldValue, double newValue); &#125; ProgressBar自身只有两个属性，分别是IsIndeterminate和Orientation 。 IsIndeterminate属性：如果为true，表示以动画从左到右滑动的方式展示进度效果。 Orientation属性：表示进度条的方式，水平时从左至右增长，垂直时从下到上增长。 二、ProgressBar例子 前端代码 12345678910111213141516171819202122&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel VerticalAlignment=&quot;Center&quot;&gt; &lt;ProgressBar x:Name=&quot;_ProgressBar&quot; IsIndeterminate=&quot;False&quot; Value=&quot;50&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; Orientation=&quot;Horizontal&quot; Height=&quot;10&quot; Margin=&quot;15&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlock&quot; Text=&quot;50%&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718192021222324public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); Loaded += (s, e) =&gt; &#123; Task.Factory.StartNew(() =&gt; &#123; for (int i = 0; i &lt;= 100; i++) &#123; Dispatcher.Invoke(() =&gt; &#123; _TextBlock.Text = $&quot;&#123;i&#125;%&quot;; _ProgressBar.Value = i; &#125;); Task.Delay(25).Wait(); &#125; &#125;); &#125;; &#125; &#125; 三、代码分析 我们在主窗体的Loaded事件中增加了一个子线程，需要注意的是，在子线程中不可以直接更新UI线程的控件，所以我们利用Dispatcher类，将访问UI线程的代码成成一个匿名函数，交给Dispatcher去执行。F5运行后，您将看到一个进度条从0增长到100。 Calendar日历控件Calendar提供一个日历界面，供用户选择日期，它继承于Control基类。 一、Calendar类的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Calendar : Control&#123; public static readonly RoutedEvent SelectedDatesChangedEvent; public static readonly DependencyProperty SelectionModeProperty; public static readonly DependencyProperty SelectedDateProperty; public static readonly DependencyProperty FirstDayOfWeekProperty; public static readonly DependencyProperty DisplayModeProperty; public static readonly DependencyProperty DisplayDateStartProperty; public static readonly DependencyProperty IsTodayHighlightedProperty; public static readonly DependencyProperty DisplayDateProperty; public static readonly DependencyProperty CalendarItemStyleProperty; public static readonly DependencyProperty CalendarDayButtonStyleProperty; public static readonly DependencyProperty CalendarButtonStyleProperty; public static readonly DependencyProperty DisplayDateEndProperty; public Calendar(); public DateTime? DisplayDateStart &#123; get; set; &#125; public Style CalendarItemStyle &#123; get; set; &#125; public Style CalendarDayButtonStyle &#123; get; set; &#125; public Style CalendarButtonStyle &#123; get; set; &#125; public CalendarBlackoutDatesCollection BlackoutDates &#123; get; &#125; public CalendarMode DisplayMode &#123; get; set; &#125; public DateTime? DisplayDateEnd &#123; get; set; &#125; public bool IsTodayHighlighted &#123; get; set; &#125; public DateTime? SelectedDate &#123; get; set; &#125; public SelectedDatesCollection SelectedDates &#123; get; &#125; public CalendarSelectionMode SelectionMode &#123; get; set; &#125; public DateTime DisplayDate &#123; get; set; &#125; public DayOfWeek FirstDayOfWeek &#123; get; set; &#125; public event EventHandler&lt;SelectionChangedEventArgs&gt; SelectedDatesChanged; public event EventHandler&lt;CalendarDateChangedEventArgs&gt; DisplayDateChanged; public event EventHandler&lt;EventArgs&gt; SelectionModeChanged; public event EventHandler&lt;CalendarModeChangedEventArgs&gt; DisplayModeChanged; public override void OnApplyTemplate(); public override string ToString(); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnDisplayDateChanged(CalendarDateChangedEventArgs e); protected virtual void OnDisplayModeChanged(CalendarModeChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected virtual void OnSelectedDatesChanged(SelectionChangedEventArgs e); protected virtual void OnSelectionModeChanged(EventArgs e); &#125; 二、属性成员 属性名称 说明 DisplayDateStart 获取或设置可在日历中的第一个日期。 CalendarItemStyle 获取或设置CalendarItem的样式 CalendarDayButtonStyle 获取或设置CalendarDayButton的样式 CalendarButtonStyle 获取或设置CalendarButton的样式 BlackoutDates 获取标记为不可选择的日期的集合。 DisplayMode 获取或设置一个值，该值指示是否日历显示月、 年或十年。 DisplayDateEnd 获取或设置可在日历中的日期范围内的最后日期。 IsTodayHighlighted 获取或设置一个值，该值指示是否突出显示当前日期。默认true。 SelectedDate 获取或设置当前选定的日期。[重要] SelectedDates 获取选定日期的集合。 SelectionMode 获取或设置一个值，指示允许包含什么样的选择。如果是多选的号，就可以从SelectedDates属性获取所有已选的日期。 DisplayDate 获取或设置要显示的日期。 FirstDayOfWeek 获取或设置在一天中被视为周的开始。 三、事件成员 事件名称 说明 SelectedDatesChanged 开启多选后，当所选集合的元素数量发生变化时引发 DisplayDateChanged DisplayDate属性被修改后引发 SelectionModeChanged SelectionMode属性（选择模式）发生改变后引发 DisplayModeChanged DisplayMode属性（显示模式）发生改变后引发 四、Calendar示例 前端代码 12345678910111213141516171819&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel HorizontalAlignment=&quot;Center&quot; Margin=&quot;30&quot;&gt; &lt;Calendar x:Name=&quot;_Calendar&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot; Margin=&quot;0,15&quot; DisplayDateStart=&quot;2020/1/1 00:00:00&quot; DisplayDateEnd=&quot;2030/1/1 00:00:00&quot; SelectionMode=&quot;MultipleRange&quot;/&gt; &lt;Button Content=&quot;选择&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 1234567891011121314public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; var list = _Calendar.SelectedDates; var current = _Calendar.SelectedDate; MessageBox.Show($&quot;当前日期数量:&#123;list.Count&#125;,当前日期：&#123;current&#125;&quot;); &#125; &#125; 我们设置了Calendar的DisplayDateStart和DisplayDateEnd属性，这样将日期的可选范围限制在2020年-2030年之间，同时开启了Calendar多项选择，最后在后端去获取所选的日期集合与当前日期。 当前日期是多选时的第一个日期。 在WPF中还有一个选择日期控件——DatePicker，它对当前这个Calendar控件进行了封装，通常DatePicker会更常用一些。下一节，我们来看看DatePicker控件的用法。 DatePicker日期控件DatePicker与Calender在某些属性上很相似，只是为了方便显示和操作，DatePicker将Calender进行了封装。 一、DatePicker定义 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DatePicker : Control&#123; public static readonly RoutedEvent SelectedDateChangedEvent; public static readonly DependencyProperty TextProperty; public static readonly DependencyProperty SelectedDateFormatProperty; public static readonly DependencyProperty IsTodayHighlightedProperty; public static readonly DependencyProperty IsDropDownOpenProperty; public static readonly DependencyProperty SelectedDateProperty; public static readonly DependencyProperty DisplayDateStartProperty; public static readonly DependencyProperty DisplayDateEndProperty; public static readonly DependencyProperty DisplayDateProperty; public static readonly DependencyProperty CalendarStyleProperty; public static readonly DependencyProperty FirstDayOfWeekProperty; public DatePicker(); public CalendarBlackoutDatesCollection BlackoutDates &#123; get; &#125; public DateTime? DisplayDateStart &#123; get; set; &#125; public DateTime? DisplayDateEnd &#123; get; set; &#125; public DateTime DisplayDate &#123; get; set; &#125; public Style CalendarStyle &#123; get; set; &#125; public bool IsTodayHighlighted &#123; get; set; &#125; public bool IsDropDownOpen &#123; get; set; &#125; public DatePickerFormat SelectedDateFormat &#123; get; set; &#125; public string Text &#123; get; set; &#125; public DayOfWeek FirstDayOfWeek &#123; get; set; &#125; public DateTime? SelectedDate &#123; get; set; &#125; protected internal override bool HasEffectiveKeyboardFocus &#123; get; &#125; public event RoutedEventHandler CalendarClosed; public event RoutedEventHandler CalendarOpened; public event EventHandler&lt;SelectionChangedEventArgs&gt; SelectedDateChanged; public event EventHandler&lt;DatePickerDateValidationErrorEventArgs&gt; DateValidationError; public override void OnApplyTemplate(); public override string ToString(); protected virtual void OnCalendarClosed(RoutedEventArgs e); protected virtual void OnCalendarOpened(RoutedEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnDateValidationError(DatePickerDateValidationErrorEventArgs e); protected virtual void OnSelectedDateChanged(SelectionChangedEventArgs e); &#125; 二、属性成员 属性成员 说明 BlackoutDates 获取或设置为不可选择的日期的标记集合。不常用。 DisplayDateStart 获取或设置要显示的第一个日期。 DisplayDateEnd 获取或设置要显示的最后日期。 DisplayDate 获取或设置要显示的日期。 CalendarStyle 获取或设置呈现日历时所使用的样式。 IsTodayHighlighted 获取或设置一个值，该值指示是否将突出显示当前日期。 IsDropDownOpen 获取或设置一个值，该值指示Calendar 下拉列表是打开还是关闭。 SelectedDateFormat 获取或设置用于显示所选的日期的格式。 Text 获取DatePicker显示文本，或设置选定的日期 FirstDayOfWeek 获取或设置在一天中被视为周的开始。 SelectedDate 获取或设置当前选定的日期。 HasEffectiveKeyboardFocus 获取一个值，该值指示DatePicker 是否 具有焦点。 三、事件成员 事件名称 说明 CalendarClosed DatePicker下拉列表关闭时引发此事件 CalendarOpened DatePicker下拉列表打开时引发此事件 SelectedDateChanged SelectedDate属性发生改变时引发此事件 DateValidationError 当Text属性不是日期形式的字符串时引发此事件 接下来，我们以一个例子来说明它的用法 四、DatePicker示例 前端代码 123456789101112131415161718192021&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel HorizontalAlignment=&quot;Center&quot; Margin=&quot;30&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;开始日期&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;10,0&quot;/&gt; &lt;DatePicker x:Name=&quot;_DatePickerStart&quot; VerticalAlignment=&quot;Center&quot; Width=&quot;120&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;结束日期&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;10,0&quot;/&gt; &lt;DatePicker x:Name=&quot;_DatePickerEnd&quot; VerticalAlignment=&quot;Center&quot; Width=&quot;120&quot;/&gt; &lt;/StackPanel&gt; &lt;Button Content=&quot;查询&quot; Click=&quot;Button_Click&quot; Margin=&quot;10,0&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 1234567891011121314public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; var selectedDate = $&quot;查询日期:&#123;_DatePickerStart.SelectedDate&#125; &#123;_DatePickerEnd.SelectedDate&#125;\\r\\n&quot;; var text = $&quot;文本值:&#123;_DatePickerStart.Text&#125; &#123;_DatePickerEnd.Text&#125;&quot;; MessageBox.Show($&quot;&#123;selectedDate&#125; &#123;text&#125;&quot;); &#125; &#125; 需要注意一点的是，DatePicker的SelectedDate属性是一个DateTime?日期型，而Text属性是一个string类型，所以两者的内容是不相等的。看一下运行结果： SelectedDate属性后面会带上时分秒信息。 Expander折叠控件Expander也是一个内容控件，它有一个标题属性和内容属性。我们曾在前面讲解GroupBox时提到过父类HeaderedContentControl（标题内容控件）。所以，感兴趣的小伙伴可以单击其链接前往复习。在这里，我们只关注Expander的基本功能，也就是可折叠。 一、Expander类的定义 123456789101112131415161718192021public class Expander : HeaderedContentControl&#123; public static readonly DependencyProperty ExpandDirectionProperty; public static readonly DependencyProperty IsExpandedProperty; public static readonly RoutedEvent ExpandedEvent; public static readonly RoutedEvent CollapsedEvent; public Expander(); public ExpandDirection ExpandDirection &#123; get; set; &#125; public bool IsExpanded &#123; get; set; &#125; public event RoutedEventHandler Expanded; public event RoutedEventHandler Collapsed; public override void OnApplyTemplate(); protected virtual void OnCollapsed(); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnExpanded(); &#125; Expander自身只提供了两个属性，分别是ExpandDirection和IsExpanded。 ExpandDirection属性定义了Expander的内容在打开时的方向。它是一个枚举值，分别有Down、Up、Left和Right四个方向，默认方向为Down。 IsExpanded属性用来获取或设置内容窗口是否可见。比如在后端代码中，将这个属性赋值true，意味着展开Expander。 它还有两个事件成员，分别是Expanded和Collapsed，也就是其内容在展开和隐藏时触发。 二、Expander示例 前端代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel Margin=&quot;15&quot;&gt; &lt;TextBlock Text=&quot;控件课程&quot;/&gt; &lt;Expander Header=&quot;Button控件&quot; ExpandDirection=&quot;Down&quot; Expanded=&quot;Expander_Expanded&quot; Collapsed=&quot;Expander_Collapsed&quot;&gt; &lt;Grid Background=&quot;#FFE5E5E5&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot;&gt; 表示 Windows 按钮控件，该按钮对 Click 事件做出反应。 Button类 直接从 System.Windows.Controls.Primitives.ButtonBase 类继承。 Button是内容模型ContentControl的子类。ContentControl内容属性为 Content。 在用户单击 Button时做出响应的事件叫ButtonBase.Click 。 &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/Expander&gt; &lt;Expander Header=&quot;TextBox控件&quot; ExpandDirection=&quot;Left&quot;&gt; &lt;Grid Background=&quot;#FFE5E5E5&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot;&gt; TextBox控件是WPF的文本输入控件，使用户输入录入系统数据的入口之一。 有了此控件，用户可以将数据按照软件的流程录入进去。它允许用户输入一行或多行数据。 &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/Expander&gt; &lt;Expander Header=&quot;ListBox控件&quot; ExpandDirection=&quot;Right&quot;&gt; &lt;Grid Background=&quot;#FFE5E5E5&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot;&gt; ListBox控件继承自ContentControl类，是一个容器类的控件， 向ListBox控件中包含ListBoxItem元素向容器中添加成分， 也可以添加其他任意的控件。 &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/Expander&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Expander_Expanded(object sender, RoutedEventArgs e) &#123; MessageBox.Show(&quot;Expander展开&quot;); &#125; private void Expander_Collapsed(object sender, RoutedEventArgs e) &#123; MessageBox.Show(&quot;Expander隐藏&quot;); &#125; &#125; MediaElement媒体播放器MediaElement，一个可以播放音频或视频的控件，继承于FrameworkElement基类。MediaElement包含了常见的音频或视频格式，如果您需要更强大的功能，可以考虑使用VLC库。 官方说明 MediaElement 可以在两种不同的模式下使用，具体取决于驱动控件的内容：独立模式或时钟模式。 在独立模式下使用 时， MediaElement 类似于图像， Source 可以直接指定 URI。 在时钟模式下， MediaElement 可以将 视为动画的目标，因此它将在计时树中具有相应的 Timeline 和 Clock 条目。 一、MediaElement的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MediaElement : FrameworkElement, IUriContext&#123; public static readonly DependencyProperty SourceProperty; public static readonly RoutedEvent ScriptCommandEvent; public static readonly RoutedEvent BufferingEndedEvent; public static readonly RoutedEvent BufferingStartedEvent; public static readonly RoutedEvent MediaOpenedEvent; public static readonly RoutedEvent MediaFailedEvent; public static readonly DependencyProperty StretchDirectionProperty; public static readonly RoutedEvent MediaEndedEvent; public static readonly DependencyProperty LoadedBehaviorProperty; public static readonly DependencyProperty UnloadedBehaviorProperty; public static readonly DependencyProperty ScrubbingEnabledProperty; public static readonly DependencyProperty IsMutedProperty; public static readonly DependencyProperty BalanceProperty; public static readonly DependencyProperty VolumeProperty; public static readonly DependencyProperty StretchProperty; public MediaElement(); public MediaState LoadedBehavior &#123; get; set; &#125; public bool CanPause &#123; get; &#125; public bool IsBuffering &#123; get; &#125; public double DownloadProgress &#123; get; &#125; public double BufferingProgress &#123; get; &#125; public int NaturalVideoHeight &#123; get; &#125; public Duration NaturalDuration &#123; get; &#125; public bool HasAudio &#123; get; &#125; public bool HasVideo &#123; get; &#125; public TimeSpan Position &#123; get; set; &#125; public double SpeedRatio &#123; get; set; &#125; public MediaState UnloadedBehavior &#123; get; set; &#125; public int NaturalVideoWidth &#123; get; &#125; public bool ScrubbingEnabled &#123; get; set; &#125; public MediaClock Clock &#123; get; set; &#125; public double Balance &#123; get; set; &#125; public double Volume &#123; get; set; &#125; public StretchDirection StretchDirection &#123; get; set; &#125; public Stretch Stretch &#123; get; set; &#125; public Uri Source &#123; get; set; &#125; public bool IsMuted &#123; get; set; &#125; public event RoutedEventHandler BufferingEnded; public event RoutedEventHandler BufferingStarted; public event RoutedEventHandler MediaOpened; public event EventHandler&lt;ExceptionRoutedEventArgs&gt; MediaFailed; public event RoutedEventHandler MediaEnded; public event EventHandler&lt;MediaScriptCommandRoutedEventArgs&gt; ScriptCommand; public void Close(); public void Pause(); public void Play(); public void Stop(); protected override Size ArrangeOverride(Size finalSize); protected override Size MeasureOverride(Size availableSize); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnRender(DrawingContext drawingContext); &#125; 二、属性成员 属性名称 说明 LoadedBehavior 获取或设置加载媒体的行为，如果加载希望手动控制播放，请设置为Manual。 CanPause 获取一个值，该值指示是否可以暂停媒体。 IsBuffering 获取一个值，该值指示是否缓冲媒体。 DownloadProgress 获取一个百分比值，该值为位于远程服务器上的内容完成的下载量。 BufferingProgress 获取一个值，该值指示缓冲进度的百分比。0-1之间 NaturalVideoHeight 获取与媒体关联的视频的高度。 NaturalDuration 获取介质的自然持续时间。也就是视频播放总时长。 HasAudio 获取一个值，该值指示媒体是否具有音频。 HasVideo 获取一个值，该值指示媒体是否具有视频。 Position 通过媒体的播放时间获取或设置进度的当前位置。 SpeedRatio 获取或设置媒体的速率。也就是按几倍播放视频。 UnloadedBehavior 获取或设置卸载媒体的行为。 NaturalVideoWidth 获取与媒体关联的视频的宽度。 ScrubbingEnabled 获取或设置一个值，该值指示MediaElement 是否将更新帧的查找操作在暂停状态。 Clock 获取或设置MediaElement 媒体播放相关联的时钟。 Balance 获取或设置扬声器的音量比。 Volume 获取或设置媒体的音量。0-1之间，默认0.5 StretchDirection 获取或设置一个值，确定扩展的限制应用于映像。 Stretch 获取或设置MediaElement媒体的拉伸方式。 Source 获取或设置MediaElement媒体源[重点] IsMuted 是否静音 三、事件成员 事件名称 说明 BufferingEnded 媒体缓冲结束时发生。 BufferingStarted 媒体缓冲开始时发生。 MediaOpened 媒体加载已完成时发生。 MediaFailed 遇到错误时发生。 MediaEnded 媒体结束时发生。 ScriptCommand 在媒体中遇到的脚本命令时发生。 四、MediaElement示例 我们以MediaElement的独立模式为例，开发一个基础版本的视频播放器，该项目将会用到MediaElement、Gird、Border、TextBlock、Button、Slider、ProgressBar等控件，也算是对之前学过的控件章节一次总结和回顾。 前端代码 12345678910111213141516171819202122232425262728293031323334353637&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;400&quot; Width=&quot;550&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid&gt; &lt;MediaElement x:Name=&quot;_MediaElement&quot; LoadedBehavior=&quot;Manual&quot; /&gt; &lt;Border x:Name=&quot;_Border&quot; Background=&quot;Black&quot;&gt; &lt;TextBlock x:Name=&quot;_TextBlock&quot; Text=&quot;MediaElement | 媒体播放器&quot; Foreground=&quot;LightCoral&quot; FontSize=&quot;20&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/Grid&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Grid.Row=&quot;1&quot;&gt; &lt;Button Content=&quot;打开&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;OpenMedia&quot;/&gt; &lt;Button Content=&quot;播放&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;PlayMedia&quot;/&gt; &lt;Button Content=&quot;停止&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;StopMedia&quot;/&gt; &lt;Button Content=&quot;后退&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;BackMedia&quot;/&gt; &lt;Button Content=&quot;前进&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;ForwardMedia&quot;/&gt; &lt;TextBlock Text=&quot;音量&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;5&quot;/&gt; &lt;Slider x:Name=&quot;_Slider&quot; Width=&quot;120&quot; VerticalAlignment=&quot;Center&quot; Maximum=&quot;100&quot; Value=&quot;50&quot; ValueChanged=&quot;_Slider_ValueChanged&quot;/&gt; &lt;/StackPanel&gt; &lt;Grid Grid.Row=&quot;2&quot;&gt; &lt;ProgressBar x:Name=&quot;_ProgressBar&quot; Height=&quot;10&quot; Margin=&quot;5&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283using System;using System.Windows;using System.Windows.Threading; namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; private string file = string.Empty; public MainWindow() &#123; InitializeComponent(); DispatcherTimer timer = new DispatcherTimer(); timer.Interval = TimeSpan.FromMilliseconds(1000); timer.Tick += (s, e) =&gt; &#123; var ts = _MediaElement.Position; _ProgressBar.Value = ts.TotalMilliseconds;//更新当前播放进度 &#125;; timer.Start(); &#125; private void OpenMedia(object sender, RoutedEventArgs e) &#123; var openFileDialog = new Microsoft.Win32.OpenFileDialog() &#123; Filter = &quot;视频文件 (.mp4)|*.mp4&quot;, Multiselect = true &#125;; var result = openFileDialog.ShowDialog(); if (result == true) &#123; file = openFileDialog.FileName; _MediaElement.MediaOpened += _MediaElement_MediaOpened; _MediaElement.Source = new System.Uri(file); this.Title = file; _TextBlock.Text = file; &#125; &#125; private void _MediaElement_MediaOpened(object sender, RoutedEventArgs e) &#123; if (_MediaElement.NaturalDuration.HasTimeSpan) &#123; var ts = _MediaElement.NaturalDuration.TimeSpan; _ProgressBar.Maximum = ts.TotalMilliseconds;//设置播放进度条总长 &#125; &#125; private void PlayMedia(object sender, RoutedEventArgs e) &#123; _MediaElement.Play();//播放 _Border.Visibility = Visibility.Collapsed; &#125; private void StopMedia(object sender, RoutedEventArgs e) &#123; _MediaElement.Pause();//暂停 &#125; private void BackMedia(object sender, RoutedEventArgs e) &#123; _MediaElement.Position = _MediaElement.Position - TimeSpan.FromSeconds(10);//快退10秒 &#125; private void ForwardMedia(object sender, RoutedEventArgs e) &#123; _MediaElement.Position = _MediaElement.Position + TimeSpan.FromSeconds(10);//快进10秒 &#125; private void _Slider_ValueChanged(object sender, RoutedPropertyChangedEventArgs&lt;double&gt; e) &#123; _MediaElement.Volume = _Slider.Value;//设置音量 &#125; &#125;&#125; 如图所示，我们将前面所学的控件知识综合利用起来，设计出一款播放界面。MediaElement控件没有Background属性，所以我们放了一个Border控件（黑色背景）在MediaElement控件的上方，待加载视频并播放时，将Border隐藏起来。 在后端C#语言中，我们在构造函数里通过DispatcherTimer 开启了一个子线程，用以更新当前播放进度。DispatcherTimer是运行在UI线程上的定时器,可以直接更新UI元素，不会引发跨线程调用的异常。 在打开视频业务中，我们采用Microsoft.Win32.OpenFileDialog去获取视频文件地址，然后创建一个Uri实例，最后把这个实例赋值给MediaElement的Source属性。 最后，我们只需要调用MediaElement提供的一系列方法成员，比如Play()、Pause()、或设置播放位置的Position属性。好，关于MediaElement控件就先介绍到这里啦。 集合控件ItemsControl基类一、集合控件概述 很多时候，我们需要显示大量的数据，这些数据虽然众多，但是数据类型结构相同的，由于内容控件只能显示单个元素，要显示或操作多个元素组成的集合，那么，集合控件就派上用场了。WPF中的集合控件种类丰富，有类似表格的DataGrid，有单列表的ListBox，也有介于两者之前的ListView，还有，软件的菜单通常也是一个集合控件，以及软件下方的状态栏，同样也是一个集合控件。 这些集合控件都有一个共同的基类控件，那就是ItemsControl类，下面我们以表格的形式展示一下即将要学习的集合控件。 控件名 说明 ItemsControl 集合控件的基类，本身也是一个可以实例化的控件 ListBox 一个列表集合控件 ListView 表示用于显示数据项列表的控件，它可以有列头标题 DataGrid 表示可自定义的网格中显示数据的控件。 ComboBox 表示带有下拉列表的选择控件，通过单击控件上的箭头可显示或隐藏下拉列表。 TabControl 表示包含多个共享相同的空间在屏幕上的项的控件。 TreeView 用树结构(其中的项可以展开和折叠)中显示分层数据的控件 Menu 表示一个 Windows 菜单控件，该控件可用于按层次组织与命令和事件处理程序关联的元素。 ContextMenu 表示使控件能够公开特定于控件的上下文的功能的弹出菜单。 StatusBar 表示应用程序窗口中的水平栏中显示项和信息的控件。 二、ItemsControl类定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ItemsControl : Control, IAddChild, IGeneratorHost, IContainItemStorage&#123; public static readonly DependencyProperty ItemsSourceProperty; public static readonly DependencyProperty HasItemsProperty; public static readonly DependencyProperty DisplayMemberPathProperty; public static readonly DependencyProperty ItemTemplateProperty; public static readonly DependencyProperty ItemTemplateSelectorProperty; public static readonly DependencyProperty ItemStringFormatProperty; public static readonly DependencyProperty ItemBindingGroupProperty; public static readonly DependencyProperty ItemContainerStyleProperty; public static readonly DependencyProperty ItemContainerStyleSelectorProperty; public static readonly DependencyProperty ItemsPanelProperty; public static readonly DependencyProperty IsGroupingProperty; public static readonly DependencyProperty GroupStyleSelectorProperty; public static readonly DependencyProperty AlternationCountProperty; public static readonly DependencyProperty AlternationIndexProperty; public static readonly DependencyProperty IsTextSearchEnabledProperty; public static readonly DependencyProperty IsTextSearchCaseSensitiveProperty; public ItemsControl(); public int AlternationCount &#123; get; set; &#125; public GroupStyleSelector GroupStyleSelector &#123; get; set; &#125; public ObservableCollection&lt;GroupStyle&gt; GroupStyle &#123; get; &#125; public bool IsGrouping &#123; get; &#125; public ItemsPanelTemplate ItemsPanel &#123; get; set; &#125; public StyleSelector ItemContainerStyleSelector &#123; get; set; &#125; public Style ItemContainerStyle &#123; get; set; &#125; public BindingGroup ItemBindingGroup &#123; get; set; &#125; public string ItemStringFormat &#123; get; set; &#125; public DataTemplateSelector ItemTemplateSelector &#123; get; set; &#125; public DataTemplate ItemTemplate &#123; get; set; &#125; public string DisplayMemberPath &#123; get; set; &#125; public bool HasItems &#123; get; &#125; public ItemContainerGenerator ItemContainerGenerator &#123; get; &#125; public IEnumerable ItemsSource &#123; get; set; &#125; public ItemCollection Items &#123; get; &#125; public bool IsTextSearchCaseSensitive &#123; get; set; &#125; public bool IsTextSearchEnabled &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public static DependencyObject ContainerFromElement(ItemsControl itemsControl, DependencyObject element); public static int GetAlternationIndex(DependencyObject element); public static ItemsControl GetItemsOwner(DependencyObject element); public static ItemsControl ItemsControlFromItemContainer(DependencyObject container); public override void BeginInit(); public DependencyObject ContainerFromElement(DependencyObject element); public override void EndInit(); public bool IsItemItsOwnContainer(object item); public bool ShouldSerializeGroupStyle(); public bool ShouldSerializeItems(); public override string ToString(); protected virtual void AddChild(object value); protected virtual void AddText(string text); protected virtual void ClearContainerForItemOverride(DependencyObject element, object item); protected virtual DependencyObject GetContainerForItemOverride(); protected virtual bool IsItemItsOwnContainerOverride(object item); protected virtual void OnAlternationCountChanged(int oldAlternationCount, int newAlternationCount); protected virtual void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath); protected virtual void OnGroupStyleSelectorChanged(GroupStyleSelector oldGroupStyleSelector, GroupStyleSelector newGroupStyleSelector); protected virtual void OnItemBindingGroupChanged(BindingGroup oldItemBindingGroup, BindingGroup newItemBindingGroup); protected virtual void OnItemContainerStyleChanged(Style oldItemContainerStyle, Style newItemContainerStyle); protected virtual void OnItemContainerStyleSelectorChanged(StyleSelector oldItemContainerStyleSelector, StyleSelector newItemContainerStyleSelector); protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected virtual void OnItemsPanelChanged(ItemsPanelTemplate oldItemsPanel, ItemsPanelTemplate newItemsPanel); protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue); protected virtual void OnItemStringFormatChanged(string oldItemStringFormat, string newItemStringFormat); protected virtual void OnItemTemplateChanged(DataTemplate oldItemTemplate, DataTemplate newItemTemplate); protected virtual void OnItemTemplateSelectorChanged(DataTemplateSelector oldItemTemplateSelector, DataTemplateSelector newItemTemplateSelector); protected override void OnKeyDown(KeyEventArgs e); protected override void OnTextInput(TextCompositionEventArgs e); protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item); protected virtual bool ShouldApplyItemContainerStyle(DependencyObject container, object item); &#125; 二、ItemsControl类分析 由于我们还没有讲模板、样式、数据绑定等内容，所以关于ItemsControl类的分析，我们先关注一些与模板样式和数据绑定无关的内容，先讲讲ItemsControl最基础的内容。 2.Items属性 ItemsControl类作为集合控件的基类，它提供了一个非常重要的属性，那就是Items属性。这个属性的类型是ItemCollection，也就是一个集合列表，那么这个列表的元素内容是什么呢？ 答案是object。 说明我们可以在集合控件中放任意引用类型的元素。 2.2DisplayMemberPath属性 这个属性用来获取或设置要显示的内容，它通常指某个数据源的某个属性名称，所以它是string类型。 2.3HasItems属性 这个属性用来判断当前集合控件是否有元素。 24.IsTextSearchCaseSensitive属性 这个属性如果为true，则搜索元素时区分大小写。 2.5 IsTextSearchEnabled属性 表示是否启用文字搜索。 好，接下来的几个属性将在后续进行学习，不过，我们先在这里了解一下它们的用途。 2.6 ItemsPanel属性[重要] 由于一个集合控件里面会显示多个数据项（一个数据代表一个家），那么这些数据项怎么排版？是像StackPanel一样水平或垂直排列，还是像WrapPanel瀑布流一样排例？这个ItemsPanel属性来决定。 2.7 ItemTemplate属性[重要] 在集合控件里，数据项有可能是一个复杂的实体，那么这些数据以什么样的UI布局界面呈现？也就是说，数据本身穿什么衣服？ItemTemplate属性就是来决定数据的外观的。如果把每个Item元素看成一个家，那么前面的ItemsPanel属性就是来决定邻里之间的实际距离以及房子和房子的排例走势。 2.8 ItemContainerStyle属性[重要] ItemTemplate属性只能决定数据的外观，相当于这个家的内部装修以及家电家具的样式，而这个家外墙的装饰，则必须由ItemContainerStyle属性来承包。 2.9 ItemContainerStyleSelector属性[重要] 当我们选中这个集合控件中的某一项，并希望突出这一项，那就可以在ItemTemplateSelector属性中进行定义，也就是说，选择了某一项，某一项的外墙装饰发生改变。那同时要改变内部的样式呢？ 2.10 ItemTemplateSelector属性[重要] 如果选中了某一项，并希望它的数据模块被重新定义，以突出这一项被选中，可以设置ItemTemplateSelector属性 2.11 Template属性[重要] 还记得吗？ItemsControl类继承于Control类，而Control类中有一个叫Template的属性，所以ItemsControl类自然也就拥有了这个属性，这是一个什么属性？它是ControlTemplate类，也就是控件模板，所以，如果我们希望把ItemsControl类本身的外观进行重定义，那就需要去设置Template属性 重庆教主友情提示 上面我们一口气讲了这么多的模板概念，虽然看起来是在学习ItemsControl类的属性，但是别忘记了，将来要学习的那些集合子控件全都继承于ItemsControl类，意味着它们也都有这些模板属性可以使用呢，是不是有一种事半功倍的感觉呢！ 接下来，我们来举个例子 三、ItemsControl示例 前端代码 12345678910111213141516171819202122232425262728&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;ItemsControl&gt; &lt;Button Content=&quot;content&quot; Margin=&quot;0,5&quot;/&gt; &lt;Border Height=&quot;30&quot; Background=&quot;LightPink&quot; Margin=&quot;0,5&quot;/&gt; &lt;TextBlock Text=&quot;WPF中文网 www.wpfsoft.com&quot; Background=&quot;LightGray&quot; Margin=&quot;0,5&quot;/&gt; &lt;ItemsControl Height=&quot;35&quot; Background=&quot;AliceBlue&quot;/&gt; &lt;CheckBox Content=&quot;CheckBox元素&quot;/&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;0,5&quot;&gt; &lt;RadioButton Content=&quot;初级&quot;/&gt; &lt;RadioButton Content=&quot;中级&quot;/&gt; &lt;RadioButton Content=&quot;高级&quot;/&gt; &lt;/StackPanel&gt; 这是一串字符串 &lt;Label Content=&quot;这是Label控件&quot; Margin=&quot;0,5&quot;/&gt; &lt;Control Background=&quot;Red&quot; Height=&quot;30&quot;/&gt; &lt;ProgressBar Value=&quot;50&quot; Height=&quot;20&quot; Maximum=&quot;100&quot; /&gt; &lt;/ItemsControl&gt; &lt;/Grid&gt;&lt;/Window&gt; 首先，我们在XMAL中实例化了一个ItemsControl控件，然后在ItemsControl里面实例化了一系列子控件，它们分别是Button、Border、TextBlock、ItemsControl、CheckBox、StackPanel、RadioButton、字符串、Label、Control和ProgressBar。 除了Control没有显示出来，其它全部都呈现在ItemsControl控件之中，因为这些子控件全部都在ItemsControl类的Items集合里面，那么，Control虽然能实例化，为什么没有显示出来呢？就连没有控件的字符串都能显示出来，这里面肯定有原因。 是的，这里我们引出一个知识点，那就是控件模板，因为Control基类虽然有Background属性，但是我们并没有给Control基类的Template属性设置一个控件模板，所以Control能实例化，但是不能显示。只能看到一个高度为30的空白区域。 而Border在设置Background属性后，为什么能显示？因为Border是一个装饰器，它继承于Decorator基类。 为什么单纯的字符串也能显示呢？因为实际上这个字符串外面被包裹了一层ContentPresenter实例，这个字符串是被赋值到了ContentPresenter的Content属性上，而ContentPresenter的ContentTemplate有一个默认模板。 四、总结 ItemsControl集合基类可以显示绝大多数控件，也就意味着，ListBox，ListView，DataGrid，ComboBox，TabControl，TreeView，Menu，ContextMenu，StatusBar这些子控件在显示集合元素时，每一个元素的外观可以呈现出更复杂、更漂亮的UI效果，从而可以设计出更友好的交互界面。 有了这样一个基调，那接下来我们来一一细说各个子控件的基础功能，待学习模板和样式章节后，进一步探索这些子控件的强大功能。另外，ListBox，ListView，DataGrid，ComboBox，TabControl这5个控件又都有一个共同的基类——Selector类，Selector继承于ItemsControl基类。Selector基类又是一个怎样的类？它会给我们提供哪些功能呢？ 下一节，我们先从Selector基类说起。 Selector基类Selector继承于ItemsControl，但它是一个抽象类，所以不能被实例化。从命名上看，它是一个选择器。 一、Selector类定义 123456789101112131415161718192021222324252627282930313233343536373839public abstract class Selector : ItemsControl&#123; public static readonly RoutedEvent SelectionChangedEvent; public static readonly RoutedEvent SelectedEvent; public static readonly RoutedEvent UnselectedEvent; public static readonly DependencyProperty IsSelectionActiveProperty; public static readonly DependencyProperty IsSelectedProperty; public static readonly DependencyProperty IsSynchronizedWithCurrentItemProperty; public static readonly DependencyProperty SelectedIndexProperty; public static readonly DependencyProperty SelectedItemProperty; public static readonly DependencyProperty SelectedValueProperty; public static readonly DependencyProperty SelectedValuePathProperty; protected Selector(); public object SelectedValue &#123; get; set; &#125; public object SelectedItem &#123; get; set; &#125; public int SelectedIndex &#123; get; set; &#125; public bool? IsSynchronizedWithCurrentItem &#123; get; set; &#125; public string SelectedValuePath &#123; get; set; &#125; public event SelectionChangedEventHandler SelectionChanged; public static void AddSelectedHandler(DependencyObject element, RoutedEventHandler handler); public static void AddUnselectedHandler(DependencyObject element, RoutedEventHandler handler); public static bool GetIsSelected(DependencyObject element); public static bool GetIsSelectionActive(DependencyObject element); public static void RemoveSelectedHandler(DependencyObject element, RoutedEventHandler handler); public static void RemoveUnselectedHandler(DependencyObject element, RoutedEventHandler handler); public static void SetIsSelected(DependencyObject element, bool isSelected); protected override void ClearContainerForItemOverride(DependencyObject element, object item); protected override void OnInitialized(EventArgs e); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue); protected virtual void OnSelectionChanged(SelectionChangedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); &#125; 接下来，我们来看看它提供了哪些可用的属性。 二、Selector类的属性 属性名称 说明 SelectedValue 获取或设置SelectedValuePath属性指定的元素的属性值 SelectedItem 获取或设置当前所选内容中的第一项或如果所选内容为空则返回 null SelectedIndex 获取或设置当前所选内容或返回的第一项的索引为负一 (-1) 如果所选内容为空。 SelectedValuePath 获取或设置SelectedItem当前元素的某个属性名，这个元素属性名将决定SelectedValue的值 IsSynchronizedWithCurrentItem 是否同步当前项。 SelectedItem和SelectedValue有点类似，都是object类型。但是，他们俩不一定指同一个内容。比如，我们将有这样一个数据实体类。 123456public class Person&#123; public string Name &#123; get; set; &#125; public string Address &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125; 然后我们实例化多个Person组成一个集合绑定到Items属性中，这个时候选中某一个元素，SelectedItem便等于这个Person元素，但是SelectedValue是什么，要看SelectedValuePath的值，如果SelectedValuePath的值指向的是Person.Name，那么SelectedValue就是一个字符串，如果SelectedValuePath指向的是Person的Age ，那么SelectedValue就是一个int整数，**只有*不设置*SelectedValuePath时，SelectedValue和SelectedItem两者才相等，即Person实例。 具体关于这一个重点，我们在下一节讨论ListBox控件时进行演示和讲解。 ListBox列表控件ListBox是一个列表控件，用于显示条目类的数据，默认每行只能显示一个内容项，当然，我们可以通过修改它的数据模板，来自定义每一行（元素）的数据外观，达到显示更多数据的目的。 一、ListBox的定义 1234567891011121314151617181920212223242526public class ListBox : Selector&#123; public static readonly DependencyProperty SelectionModeProperty; public static readonly DependencyProperty SelectedItemsProperty; public ListBox(); public IList SelectedItems &#123; get; &#125; public SelectionMode SelectionMode &#123; get; set; &#125; protected object AnchorItem &#123; get; set; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public void ScrollIntoView(object item); public void SelectAll(); public void UnselectAll(); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected override void OnSelectionChanged(SelectionChangedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); protected bool SetSelectedItems(IEnumerable selectedItems); &#125; 二、属性分析 ListBox自身的属性比较少，SelectionMode 属性比较重要，它可以决定当前的ListBox控件是单选还是多选，它的值为Extended时，表示用户需要按下shift键才能多选。如果SelectionMode为多选状态，那么多选的结果保存在哪去了？ 答案是SelectedItems 属性。 另外，ListBox还自带了滚动条，如果内容超出显示区域，这时滚动条便起作用。 我们在上一章节提过DisplayMemberPath、SelectedValuePath、SelectedItem和SelectedValue，那么，我们以一个实际的例子来说明这几个属性的用途。 三、ListBox示例 前端代码 1234567891011121314151617&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel&gt; &lt;ListBox x:Name=&quot;listbox&quot; MinHeight=&quot;100&quot; DisplayMemberPath=&quot;Name&quot; SelectedValuePath=&quot;Age&quot;/&gt; &lt;Button Content=&quot;查看结果&quot; Click=&quot;Button_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlock&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 12345678910111213141516171819202122232425262728293031323334353637using System;using System.Windows;using System.Windows.Controls;using System.Windows.Threading; namespace HelloWorld&#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Address &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); listbox.Items.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;); listbox.Items.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;); listbox.Items.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; var selectedItem = listbox.SelectedItem; var selectedValue = listbox.SelectedValue; _TextBlock.Text = $&quot;&#123;selectedItem&#125;,&#123;selectedValue&#125;&quot;; &#125; &#125;&#125; 代码分析 在前端代码中，我们设置了DisplayMemberPath属性值为“Name”，而SelectedValuePath属性值为“Age”，这两个值实际上是Person类的两个属性，F5启动调试后，我们可以在界面上看到张三、李四和王五的名字，但是看不到他们的年龄和地址，这是因为ListBox默认每行只能显示一个内容项，而且这里我们设置了DisplayMemberPath属性，只能显示名字。 我们选中ListBox中的李四，然后单点查看结果按钮，SelectedItem属性得到了一个Person类，所以输出的值为HelloWorld.Person，而SelectedValue属性得到了李四的年龄，所以输出的结果是23。 重庆教主说 如果把SelectionMode属性设为多选Multiple或Extended，试试看，会发生什么效果呢？ Items属性是一个只读属性，所以我们只能能过Items的Add方法向集合增加元素。 四、ListBoxItem子项 其实，ListBox还有它专门配合业务开发的子项控件——ListBoxItem。ListBoxItem继承于ContentControl内容控件，仔细想，这意味着什么？还记得我们在分享ContentControl提过”它有一个叫Content属性“一嘴吗？Content属性可以容纳任意引用类型，也就是说，ListBoxItem也可以容纳任意引用类型，也就是说，ListBox的子项也可以容纳任意的引用类型。 这么一说，感觉ListBoxr还蛮强大的呢！ 所以，ListBoxItem可以这样使用 123456789101112131415161718192021222324252627282930313233&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel&gt; &lt;ListBox x:Name=&quot;listbox&quot;&gt; &lt;ListBoxItem&gt; &lt;Button Content=&quot;这是一个按钮&quot;/&gt; &lt;/ListBoxItem&gt; &lt;ListBoxItem&gt; &lt;Border Height=&quot;30&quot; Background=&quot;Red&quot;/&gt; &lt;/ListBoxItem&gt; &lt;ListBoxItem Content=&quot;这是一个字符串&quot;/&gt; &lt;ListBoxItem&gt; &lt;ProgressBar Maximum=&quot;100&quot; Value=&quot;50&quot; Height=&quot;25&quot; Width=&quot;450&quot;/&gt; &lt;/ListBoxItem&gt; 这里直接写字符串 &lt;ListBoxItem&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;CheckBox Content=&quot;复选框&quot;/&gt; &lt;RadioButton Content=&quot;单选框 &quot;/&gt; &lt;/StackPanel&gt; &lt;/ListBoxItem&gt; &lt;/ListBox&gt; &lt;Button Content=&quot;查看结果&quot; Click=&quot;Button_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;textblock&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后台代码 123456789101112131415161718192021public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; try &#123; var selectedItem = listbox.SelectedItem; var content = ((ContentControl)selectedItem).Content; textblock.Text = $&quot;selectedItem=&#123;selectedItem&#125;\\r\\ncontent=&#123;content&#125;&quot;; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; &#125; &#125; 如上所示，我们在ListBoxj控件里面实例化了好几个ListBoxItem，但是每个ListBoxItem的Content属性都不一样，有Button，Border ，ProgressBar ，字符串，最后，我们来获取这些选中项的内容。 除了直接写的字符串不能转换之外，其它项的结果，SelectedItem属性总是ListBoxItem，而Content可以是我们设置的其它控制。 要全面了解ListBoxItem，不能不看看它的定义。 1234567891011121314151617181920212223public class ListBoxItem : ContentControl&#123; public static readonly DependencyProperty IsSelectedProperty; public static readonly RoutedEvent SelectedEvent; public static readonly RoutedEvent UnselectedEvent; public ListBoxItem(); public bool IsSelected &#123; get; set; &#125; public event RoutedEventHandler Selected; public event RoutedEventHandler Unselected; protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnMouseEnter(MouseEventArgs e); protected override void OnMouseLeave(MouseEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseRightButtonDown(MouseButtonEventArgs e); protected virtual void OnSelected(RoutedEventArgs e); protected virtual void OnUnselected(RoutedEventArgs e); protected internal override void OnVisualParentChanged(DependencyObject oldParent); &#125; 如上所示，可以看到ListBoxItem有一个叫IsSelected属性，表示该项是否被选中，同时，它还有两个事件，分别是Selected选中和Unselected未选中，我们可以去订阅这两个事件，以此来做一些业务。 关于ListBox以及ListBoxItem，我们就先介绍这么多，实际上它的用法远不止这些，如果加上模板、样式、数据绑定、触发器，它还可以实现许多意想不到的效果。关于这部分的内容，请参阅模板样式章节关于ListBox控件的用法。 所以，ListBox列表控件默认情况下，只能显示一个数据项，那如果我想把Person类的Name、Age、Address三个属性值都显示出来呢？有办法——ListView控件可以做到。 ListView数据列表控件ListView继承于ListBox，在ListBox控件的基础上增加了数据视图。从而让我们可以很轻松的设置每一列的标题，以显示某个数据表结构及内容。 一、ListView定义 12345678910111213141516public class ListView : ListBox&#123; public static readonly DependencyProperty ViewProperty; public ListView(); public ViewBase View &#123; get; set; &#125; protected override void ClearContainerForItemOverride(DependencyObject element, object item); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); &#125; ListView类增加了一个叫View的属性，这个属性用来定义控件的数据样式，决定数据怎样显示。View属性的类型是ViewBase，但是，我们真正在使用View属性时，实际上实例化的是GridView类，因为GridView类是ViewBase的子类。所以，我们要看了解一下GridView的定义。 1234567891011121314151617181920212223242526272829303132333435363738public class GridView : ViewBase, IAddChild&#123; public static readonly DependencyProperty ColumnCollectionProperty; public static readonly DependencyProperty ColumnHeaderContainerStyleProperty; public static readonly DependencyProperty ColumnHeaderTemplateProperty; public static readonly DependencyProperty ColumnHeaderTemplateSelectorProperty; public static readonly DependencyProperty ColumnHeaderStringFormatProperty; public static readonly DependencyProperty AllowsColumnReorderProperty; public static readonly DependencyProperty ColumnHeaderContextMenuProperty; public static readonly DependencyProperty ColumnHeaderToolTipProperty; public GridView(); public static ResourceKey GridViewItemContainerStyleKey &#123; get; &#125; public static ResourceKey GridViewStyleKey &#123; get; &#125; public static ResourceKey GridViewScrollViewerStyleKey &#123; get; &#125; public string ColumnHeaderStringFormat &#123; get; set; &#125; public DataTemplateSelector ColumnHeaderTemplateSelector &#123; get; set; &#125; public DataTemplate ColumnHeaderTemplate &#123; get; set; &#125; public Style ColumnHeaderContainerStyle &#123; get; set; &#125; public GridViewColumnCollection Columns &#123; get; &#125; public object ColumnHeaderToolTip &#123; get; set; &#125; public bool AllowsColumnReorder &#123; get; set; &#125; public ContextMenu ColumnHeaderContextMenu &#123; get; set; &#125; protected internal override object ItemContainerDefaultStyleKey &#123; get; &#125; protected internal override object DefaultStyleKey &#123; get; &#125; public static GridViewColumnCollection GetColumnCollection(DependencyObject element); public static void SetColumnCollection(DependencyObject element, GridViewColumnCollection collection); public static bool ShouldSerializeColumnCollection(DependencyObject obj); public override string ToString(); protected virtual void AddChild(object column); protected virtual void AddText(string text); protected internal override void ClearItem(ListViewItem item); protected internal override IViewAutomationPeer GetAutomationPeer(ListView parent); protected internal override void PrepareItem(ListViewItem item); &#125; GridView提供了一些可供设置的模板和样式属性，这些我们先放一边，在WPF基础章节的内容学习中，我们先学习它的Columns 属性，它是一个集合属性，而集合中元素的类型是GridViewColumn。 GridViewColumn最关键的只有两个属性，分别是标题和要显示的成员（指向了Person实体的某个属性名）。 好了，我们以上一节中的Person实体为例。 二、ListView示例 前端代码 123456789101112131415161718192021222324252627282930313233343536373839&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition Width=&quot;200&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;ListView Grid.Column=&quot;0&quot; x:Name=&quot;listview&quot; SelectionChanged=&quot;listview_SelectionChanged&quot;&gt; &lt;ListView.View&gt; &lt;GridView&gt; &lt;GridViewColumn Header=&quot;姓名&quot; DisplayMemberBinding=&quot;&#123;Binding Name&#125;&quot;/&gt; &lt;GridViewColumn Header=&quot;年龄&quot; DisplayMemberBinding=&quot;&#123;Binding Age&#125;&quot;/&gt; &lt;GridViewColumn Header=&quot;地址&quot; DisplayMemberBinding=&quot;&#123;Binding Address&#125;&quot;/&gt; &lt;/GridView&gt; &lt;/ListView.View&gt; &lt;/ListView&gt; &lt;StackPanel Grid.Column=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;姓名:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockName&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;年龄:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAge&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;地址:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAddress&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 12345678910111213141516171819202122232425262728293031323334353637namespace HelloWorld&#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Address &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); listview.Items.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;); listview.Items.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;); listview.Items.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); &#125; private void listview_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; ListView listView = sender as ListView; if (listView == null) return; var person = listView.SelectedItem as Person; if (person == null) return; _TextBlockName.Text = person.Name; _TextBlockAge.Text = person.Age + &quot;岁&quot;; _TextBlockAddress.Text = person.Address; &#125; &#125;&#125; 三、代码分析 首先，我们在前端实例化了一个ListView控件，并为View属性实例化了一个GridView对象（注意xaml语法的写法）,最后为GridView对象实例化了3列GridViewColumn ，分别设置为姓名年龄和地址，特别需要注意的是DisplayMemberBinding属性的写法，这里采用了数据绑定的写法，意思是将ListView控件的数据源的Name属性显示在姓名那一列，Age属性显示在年龄那一列，Address属性显示在地址那一列（我们明确知道ListView数据源的类型就是Person的实例集合）。 事件处理 在ListView控件的SelectionChanged事件中，我们先将sender转成ListView ，再从中获取当前选中项（即person），最后显示详细信息在界面上即可。这样就演示了数据怎么加载显示到ListView，又怎么样从ListView上获取的过程。 而类似于ListView的效果效果，还有一个专门用来显示数据的控件，它叫DataGrid，从某种意义上来说，它甚至可以开发类似Excel表格的效果。不过，我们在下一节，还是以学习它的基础功能先。 DataGrid数据表格控件DataGrid是一个可以多选的数据表格控件。所以，它继承一个支持多选的父类——MultiSelector。 1234567891011121314public abstract class MultiSelector : Selector&#123; protected MultiSelector(); public IList SelectedItems &#123; get; &#125; protected bool CanSelectMultipleItems &#123; get; set; &#125; protected bool IsUpdatingSelectedItems &#123; get; &#125; public void SelectAll(); public void UnselectAll(); protected void BeginUpdateSelectedItems(); protected void EndUpdateSelectedItems(); &#125; 从上面的定义来看，DataGrid多选的结果会保存在SelectedItems 只读属性中，CanSelectMultipleItems 属性用来设置是否开启多选。好，然后我们来看看DataGrid控件的定义，虽然它的属性众多，在学习模板样式之后，我们还会进一步学习这个控件的用法。 一、DataGrid定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208public class DataGrid : MultiSelector&#123; public static readonly DependencyProperty CanUserResizeColumnsProperty; public static readonly DependencyProperty CurrentItemProperty; public static readonly DependencyProperty CurrentColumnProperty; public static readonly DependencyProperty CurrentCellProperty; public static readonly DependencyProperty CanUserAddRowsProperty; public static readonly DependencyProperty CanUserDeleteRowsProperty; public static readonly DependencyProperty RowDetailsVisibilityModeProperty; public static readonly DependencyProperty AreRowDetailsFrozenProperty; public static readonly DependencyProperty RowDetailsTemplateProperty; public static readonly DependencyProperty RowDetailsTemplateSelectorProperty; public static readonly DependencyProperty CanUserResizeRowsProperty; public static readonly DependencyProperty NewItemMarginProperty; public static readonly DependencyProperty SelectionModeProperty; public static readonly DependencyProperty SelectionUnitProperty; public static readonly DependencyProperty CanUserSortColumnsProperty; public static readonly DependencyProperty AutoGenerateColumnsProperty; public static readonly DependencyProperty FrozenColumnCountProperty; public static readonly DependencyProperty NonFrozenColumnsViewportHorizontalOffsetProperty; public static readonly DependencyProperty EnableColumnVirtualizationProperty; public static readonly DependencyProperty CanUserReorderColumnsProperty; public static readonly DependencyProperty DragIndicatorStyleProperty; public static readonly DependencyProperty DropLocationIndicatorStyleProperty; public static readonly DependencyProperty ClipboardCopyModeProperty; public static readonly DependencyProperty CellsPanelHorizontalOffsetProperty; public static readonly DependencyProperty IsReadOnlyProperty; public static readonly RoutedCommand CancelEditCommand; public static readonly DependencyProperty EnableRowVirtualizationProperty; public static readonly RoutedCommand BeginEditCommand; public static readonly RoutedCommand CommitEditCommand; public static readonly DependencyProperty ColumnWidthProperty; public static readonly DependencyProperty MinColumnWidthProperty; public static readonly DependencyProperty MaxColumnWidthProperty; public static readonly DependencyProperty HorizontalGridLinesBrushProperty; public static readonly DependencyProperty VerticalGridLinesBrushProperty; public static readonly DependencyProperty RowStyleProperty; public static readonly DependencyProperty RowValidationErrorTemplateProperty; public static readonly DependencyProperty RowStyleSelectorProperty; public static readonly DependencyProperty RowBackgroundProperty; public static readonly DependencyProperty AlternatingRowBackgroundProperty; public static readonly DependencyProperty RowHeightProperty; public static readonly DependencyProperty GridLinesVisibilityProperty; public static readonly DependencyProperty RowHeaderWidthProperty; public static readonly DependencyProperty VerticalScrollBarVisibilityProperty; public static readonly DependencyProperty MinRowHeightProperty; public static readonly DependencyProperty HorizontalScrollBarVisibilityProperty; public static readonly DependencyProperty RowHeaderTemplateProperty; public static readonly DependencyProperty RowHeaderStyleProperty; public static readonly DependencyProperty RowHeaderTemplateSelectorProperty; public static readonly DependencyProperty CellStyleProperty; public static readonly DependencyProperty HeadersVisibilityProperty; public static readonly DependencyProperty ColumnHeaderHeightProperty; public static readonly DependencyProperty RowHeaderActualWidthProperty; public static readonly DependencyProperty ColumnHeaderStyleProperty; public DataGrid(); public static ComponentResourceKey FocusBorderBrushKey &#123; get; &#125; public static RoutedUICommand SelectAllCommand &#123; get; &#125; public static IValueConverter HeadersVisibilityConverter &#123; get; &#125; public static IValueConverter RowDetailsScrollingConverter &#123; get; &#125; public static RoutedUICommand DeleteCommand &#123; get; &#125; public DataTemplate RowHeaderTemplate &#123; get; set; &#125; public DataTemplateSelector RowHeaderTemplateSelector &#123; get; set; &#125; public ScrollBarVisibility VerticalScrollBarVisibility &#123; get; set; &#125; public ScrollBarVisibility HorizontalScrollBarVisibility &#123; get; set; &#125; public bool CanUserAddRows &#123; get; set; &#125; public object CurrentItem &#123; get; set; &#125; public DataGridColumn CurrentColumn &#123; get; set; &#125; public DataGridCellInfo CurrentCell &#123; get; set; &#125; public bool CanUserDeleteRows &#123; get; set; &#125; public Style RowHeaderStyle &#123; get; set; &#125; public DataGridRowDetailsVisibilityMode RowDetailsVisibilityMode &#123; get; set; &#125; public bool IsReadOnly &#123; get; set; &#125; public Style ColumnHeaderStyle &#123; get; set; &#125; public Style RowStyle &#123; get; set; &#125; public DataGridHeadersVisibility HeadersVisibility &#123; get; set; &#125; public bool AreRowDetailsFrozen &#123; get; set; &#125; public Brush AlternatingRowBackground &#123; get; set; &#125; public Brush RowBackground &#123; get; set; &#125; public StyleSelector RowStyleSelector &#123; get; set; &#125; public ObservableCollection&lt;ValidationRule&gt; RowValidationRules &#123; get; &#125; public ControlTemplate RowValidationErrorTemplate &#123; get; set; &#125; public Brush VerticalGridLinesBrush &#123; get; set; &#125; public Brush HorizontalGridLinesBrush &#123; get; set; &#125; public DataGridGridLinesVisibility GridLinesVisibility &#123; get; set; &#125; public double MaxColumnWidth &#123; get; set; &#125; public double MinColumnWidth &#123; get; set; &#125; public DataGridLength ColumnWidth &#123; get; set; &#125; public bool CanUserResizeColumns &#123; get; set; &#125; public ObservableCollection&lt;DataGridColumn&gt; Columns &#123; get; &#125; public double RowHeaderWidth &#123; get; set; &#125; public double RowHeaderActualWidth &#123; get; &#125; public double ColumnHeaderHeight &#123; get; set; &#125; public Style CellStyle &#123; get; set; &#125; public DataTemplate RowDetailsTemplate &#123; get; set; &#125; public double MinRowHeight &#123; get; set; &#125; public bool CanUserResizeRows &#123; get; set; &#125; public double RowHeight &#123; get; set; &#125; public DataTemplateSelector RowDetailsTemplateSelector &#123; get; set; &#125; public double CellsPanelHorizontalOffset &#123; get; &#125; public DataGridClipboardCopyMode ClipboardCopyMode &#123; get; set; &#125; public Style DropLocationIndicatorStyle &#123; get; set; &#125; public bool CanUserReorderColumns &#123; get; set; &#125; public bool EnableColumnVirtualization &#123; get; set; &#125; public bool EnableRowVirtualization &#123; get; set; &#125; public Style DragIndicatorStyle &#123; get; set; &#125; public double NonFrozenColumnsViewportHorizontalOffset &#123; get; &#125; public int FrozenColumnCount &#123; get; set; &#125; public bool AutoGenerateColumns &#123; get; set; &#125; public Thickness NewItemMargin &#123; get; &#125; public bool CanUserSortColumns &#123; get; set; &#125; public DataGridSelectionUnit SelectionUnit &#123; get; set; &#125; public DataGridSelectionMode SelectionMode &#123; get; set; &#125; public IList&lt;DataGridCellInfo&gt; SelectedCells &#123; get; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public event DataGridSortingEventHandler Sorting; public event EventHandler AutoGeneratedColumns; public event EventHandler&lt;DataGridAutoGeneratingColumnEventArgs&gt; AutoGeneratingColumn; public event EventHandler&lt;DragDeltaEventArgs&gt; ColumnHeaderDragDelta; public event EventHandler&lt;DragStartedEventArgs&gt; ColumnHeaderDragStarted; public event EventHandler&lt;DragCompletedEventArgs&gt; ColumnHeaderDragCompleted; public event SelectedCellsChangedEventHandler SelectedCellsChanged; public event EventHandler&lt;DataGridColumnReorderingEventArgs&gt; ColumnReordering; public event EventHandler&lt;DataGridRowDetailsEventArgs&gt; RowDetailsVisibilityChanged; public event EventHandler&lt;DataGridRowEventArgs&gt; UnloadingRow; public event EventHandler&lt;DataGridRowDetailsEventArgs&gt; LoadingRowDetails; public event InitializingNewItemEventHandler InitializingNewItem; public event EventHandler&lt;DataGridPreparingCellForEditEventArgs&gt; PreparingCellForEdit; public event EventHandler&lt;DataGridBeginningEditEventArgs&gt; BeginningEdit; public event EventHandler&lt;EventArgs&gt; CurrentCellChanged; public event EventHandler&lt;DataGridCellEditEndingEventArgs&gt; CellEditEnding; public event EventHandler&lt;DataGridRowEditEndingEventArgs&gt; RowEditEnding; public event EventHandler&lt;DataGridRowEventArgs&gt; LoadingRow; public event EventHandler&lt;DataGridColumnEventArgs&gt; ColumnDisplayIndexChanged; public event EventHandler&lt;DataGridRowDetailsEventArgs&gt; UnloadingRowDetails; public event EventHandler&lt;AddingNewItemEventArgs&gt; AddingNewItem; public event EventHandler&lt;DataGridRowClipboardEventArgs&gt; CopyingRowClipboardContent; public event EventHandler&lt;DataGridColumnEventArgs&gt; ColumnReordered; public static Collection&lt;DataGridColumn&gt; GenerateColumns(IItemProperties itemProperties); public bool BeginEdit(); public bool BeginEdit(RoutedEventArgs editingEventArgs); public bool CancelEdit(); public bool CancelEdit(DataGridEditingUnit editingUnit); public void ClearDetailsVisibilityForItem(object item); public DataGridColumn ColumnFromDisplayIndex(int displayIndex); public bool CommitEdit(); public bool CommitEdit(DataGridEditingUnit editingUnit, bool exitEditingMode); public Visibility GetDetailsVisibilityForItem(object item); public override void OnApplyTemplate(); public void ScrollIntoView(object item); public void ScrollIntoView(object item, DataGridColumn column); public void SelectAllCells(); public void SetDetailsVisibilityForItem(object item, Visibility detailsVisibility); public void UnselectAllCells(); protected override void ClearContainerForItemOverride(DependencyObject element, object item); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override Size MeasureOverride(Size availableSize); protected virtual void OnAddingNewItem(AddingNewItemEventArgs e); protected virtual void OnAutoGeneratedColumns(EventArgs e); protected virtual void OnAutoGeneratingColumn(DataGridAutoGeneratingColumnEventArgs e); protected virtual void OnBeginningEdit(DataGridBeginningEditEventArgs e); protected virtual void OnCanExecuteBeginEdit(CanExecuteRoutedEventArgs e); protected virtual void OnCanExecuteCancelEdit(CanExecuteRoutedEventArgs e); protected virtual void OnCanExecuteCommitEdit(CanExecuteRoutedEventArgs e); protected virtual void OnCanExecuteCopy(CanExecuteRoutedEventArgs args); protected virtual void OnCanExecuteDelete(CanExecuteRoutedEventArgs e); protected virtual void OnCellEditEnding(DataGridCellEditEndingEventArgs e); protected override void OnContextMenuOpening(ContextMenuEventArgs e); protected virtual void OnCopyingRowClipboardContent(DataGridRowClipboardEventArgs args); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnCurrentCellChanged(EventArgs e); protected virtual void OnExecutedBeginEdit(ExecutedRoutedEventArgs e); protected virtual void OnExecutedCancelEdit(ExecutedRoutedEventArgs e); protected virtual void OnExecutedCommitEdit(ExecutedRoutedEventArgs e); protected virtual void OnExecutedCopy(ExecutedRoutedEventArgs args); protected virtual void OnExecutedDelete(ExecutedRoutedEventArgs e); protected virtual void OnInitializingNewItem(InitializingNewItemEventArgs e); protected override void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue); protected override void OnKeyDown(KeyEventArgs e); protected virtual void OnLoadingRow(DataGridRowEventArgs e); protected virtual void OnLoadingRowDetails(DataGridRowDetailsEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected virtual void OnRowEditEnding(DataGridRowEditEndingEventArgs e); protected virtual void OnSelectedCellsChanged(SelectedCellsChangedEventArgs e); protected override void OnSelectionChanged(SelectionChangedEventArgs e); protected virtual void OnSorting(DataGridSortingEventArgs eventArgs); protected override void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate); protected override void OnTextInput(TextCompositionEventArgs e); protected virtual void OnUnloadingRow(DataGridRowEventArgs e); protected virtual void OnUnloadingRowDetails(DataGridRowDetailsEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); protected internal virtual void OnColumnDisplayIndexChanged(DataGridColumnEventArgs e); protected internal virtual void OnColumnHeaderDragCompleted(DragCompletedEventArgs e); protected internal virtual void OnColumnHeaderDragDelta(DragDeltaEventArgs e); protected internal virtual void OnColumnHeaderDragStarted(DragStartedEventArgs e); protected internal virtual void OnColumnReordered(DataGridColumnEventArgs e); protected internal virtual void OnColumnReordering(DataGridColumnReorderingEventArgs e); protected internal virtual void OnPreparingCellForEdit(DataGridPreparingCellForEditEventArgs e); protected internal virtual void OnRowDetailsVisibilityChanged(DataGridRowDetailsEventArgs e); &#125; 二、属性分析 DataGrid提供了大量的依赖属性，合理充分利用这些属性，在开发ERP、CMS、报表等软件时可达到事半功倍的效果。下面我们以表格的形式，先了解一下各属性的功能，然后在本节中学习一些基础属性，以掌握该控件的基本用法，剩下的属性放到模板样式的章节中学习。 属性名称 说明 备注 FocusBorderBrushKey 获取引用焦点的单元格的默认边框画笔的键。 SelectAllCommand 表示指示想要选择的所有单元格的命令 HeadersVisibilityConverter 获取标题显示隐藏的转换器，即HeadersVisibility属性的转换器 RowDetailsScrollingConverter 获取将转换为一个布尔值转换器 DeleteCommand 表示指示想要删除当前行的命令。 RowHeaderTemplate 获取或设置行标题的模板。 重要 RowHeaderTemplateSelector 获取或设置行标题的模板选择器。 VerticalScrollBarVisibility 是否显示垂直滚动条 HorizontalScrollBarVisibility 是否显示水平滚动条 CanUserAddRows 是否可以添加新行 重要 CurrentItem 当前选中行（一般指绑定的数据源的某一个元素） 常用 CurrentColumn 获取或设置包含当前单元格的列。 CurrentCell 获取或设置具有焦点的单元格。 CanUserDeleteRows 是否可以删除行 重要 RowHeaderStyle 获取或设置应用于所有行标题的样式。 重要 RowDetailsVisibilityMode 获取或设置一个值，该值指示何时显示某行的详细信息部分。 IsReadOnly 当前控件是否只读 常用 ColumnHeaderStyle 获取或设置所有列标题的样式 重要 RowStyle 获取或设置应用到的所有行的样式。 重要 HeadersVisibility 获取或设置用于指定行和列标题的可见性的值。 AreRowDetailsFrozen 获取或设置一个值，该值指示是否可水平滚动行详细信息。 AlternatingRowBackground 获取或设置交替行上使用的背景画笔。 重要 RowBackground 获取或设置用于行背景的默认画笔。 RowStyleSelector 获取或设置行的样式选择器。 RowValidationRules 获取用于验证每个行中的数据的规则。 RowValidationErrorTemplate 获取或设置用于以可视方式指示行验证中的错误的模板。 VerticalGridLinesBrush 获取或设置用于绘制垂直网格线的画笔。 常用 HorizontalGridLinesBrush 获取或设置用于绘制水平网格线的画笔。 GridLinesVisibility 获取或设置一个值，该值指示显示哪些网格线。 MaxColumnWidth 获取或设置列和标头中的最大宽度约束 MinColumnWidth 获取或设置列和标头中的最小宽度约束 ColumnWidth 获取或设置标准宽度和列和中的标头的大小调整模式 CanUserResizeColumns 获取或设置用户是否可以通过使用鼠标调整列的宽度。 Columns 获取一个集合中的所有列 常用 RowHeaderWidth 获取或设置行标题列的宽度。 RowHeaderActualWidth 获取呈现的行标题列的宽度。 ColumnHeaderHeight 获取或设置列标题行的高度。 CellStyle 获取或设置所有单元格的样式 常用 RowDetailsTemplate 获取或设置用于显示行详细信息的模板。 MinRowHeight 获取或设置行和中的标头的最小高度约束 CanUserResizeRows 获取或设置用户是否可以通过使用鼠标调整行的高度。 RowHeight 获取或设置的所有行的建议的高度。 RowDetailsTemplateSelector 获取或设置用于行详细信息的模板选择器。 CellsPanelHorizontalOffset 获取DataGridCellsPanel的水平偏移量 ClipboardCopyMode 获取或设置一个值，指示如何将内容复制到剪贴板。 NonFrozenColumns ViewportHorizontalOffset 获取在视区的可滚动列的水平偏移量。 FrozenColumnCount 获取或设置非滚动列的数量。 常用 AutoGenerateColumns 获取或设置一个值，该值指示是否自动创建列。 常用 NewItemMargin 获取或设置新的项目行的边距。 CanUserSortColumns 是否可以单击列标题来对列排序。 常用 SelectionUnit 选择行的模式 SelectionMode 是否支持多选 重要 SelectedCells 获取当前选定的单元格的列表。 HandlesScrolling 是否支持自定义键盘滚动。 在上述表格中，Columns属性是DataGrid最基本的一个属性。它是一个ObservableCollection类型的集合，表示DataGrid的列的集合。其实DataGridColumn只是一个抽象基类，我们真正在实例化时，是实例化DataGridColumn的子类，然后放到Columns属性中。 那么DataGridColumn有哪些子类呢？ DataGridTextColumn 表示文本内容的列 DataGridCheckBoxColumn 表示复选框的列 DataGridComboBoxColumn 表示下拉框的列 DataGridTemplateColumn 表示模板的列（万金油） 在本列中，我们将以最简单的DataGridTextColumn 为例。 三、事件成员 DataGrid一共有23个事件成员，它们分别如下所示 事件名称 说明 Sorting 对列进行排序时发生。 AutoGeneratedColumns 所有列的自动生成完成后发生。 AutoGeneratingColumn 自动生成单独的列时出现。 ColumnHeaderDragDelta 每次鼠标位置发生更改时在用户拖动列标题时发生。 ColumnHeaderDragStarted 当用户开始使用鼠标拖动列标题时发生。 ColumnHeaderDragCompleted 当用户使用鼠标拖动后释放列标题时发生。 SelectedCellsChanged 发生时 DataGrid.SelectedCells 集合更改。 ColumnReordering 在列移至的显示顺序中的新位置之前发生。 RowDetailsVisibilityChanged 当某一行的可见性详细信息元素更改时发生。 UnloadingRow 发生时 DataGridRow 对象将成为可供重用。 LoadingRowDetails 新的行的详细信息模板应用于行时发生。 InitializingNewItem 创建一个新项时出现。 PreparingCellForEdit 在单元格进入编辑模式时发生。 BeginningEdit 发生行或单元格进入编辑模式之前。 CurrentCellChanged 在 DataGrid.CurrentCell 属性的值更改后发生。 CellEditEnding 在单元格的编辑将在提交或取消前发生。 RowEditEnding 在提交或取消行编辑之前发生。 LoadingRow 加载row时 ColumnDisplayIndexChanged 其中一个列更改属性时 UnloadingRowDetails 行详细信息元素成为可供重用时发生。 AddingNewItem 新项添加到DataGrid之前发生 CopyingRowClipboardContent 默认行内容准备好之后发生。 ColumnReordered 在列移至的显示顺序中的新位置时发生。 四、基本示例 前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition Width=&quot;200&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;DataGrid x:Name=&quot;datagrid&quot; SelectionMode=&quot;Extended&quot; IsReadOnly=&quot;True&quot; SelectionChanged=&quot;datagrid_Selected&quot;&gt; &lt;DataGrid.Columns&gt; &lt;DataGridTextColumn Header=&quot;姓名&quot; Binding=&quot;&#123;Binding Name&#125;&quot; /&gt; &lt;DataGridTextColumn Header=&quot;年龄&quot; Binding=&quot;&#123;Binding Age&#125;&quot; /&gt; &lt;DataGridTextColumn Header=&quot;地址&quot; Binding=&quot;&#123;Binding Address&#125;&quot; /&gt; &lt;/DataGrid.Columns&gt; &lt;/DataGrid&gt; &lt;StackPanel Grid.Column=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;姓名:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockName&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;年龄:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAge&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;地址:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAddress&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526272829303132333435363738namespace HelloWorld&#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Address &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); datagrid.Items.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;); datagrid.Items.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;); datagrid.Items.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); &#125; private void datagrid_Selected(object sender, RoutedEventArgs e) &#123; DataGrid datagrid = sender as DataGrid; if (datagrid == null) return; var person = datagrid.SelectedItem as Person; if (person == null) return; _TextBlockName.Text = person.Name; _TextBlockAge.Text = person.Age + &quot;岁&quot;; _TextBlockAddress.Text = person.Address; &#125; &#125;&#125; 在这个例子中，我们尽量还原了与ListView控件一致的功能， 需要注意的细节是：我们将DataGrid的IsReadOnly&#x3D;”True”，这是因为我们直接将数据元素一条一条的加入到DataGrid的Items属性中，而Items属性本身是一个只读属性，不支持写入。这样的话，当鼠标双击时会报错。错误提示为： 如何解决这个问题呢？这就要用到ItemsControl基类中的ItemsSource数据源属性。 我们需要采用DataGrid另外一种赋值方式——数据源赋值。即把一个集合绑定到该属性上，这样在前端就可以编辑数据源，从而不会引发报错。 只需要改动一点点代码。 1234567List&lt;Person&gt; list = new List&lt;Person&gt;(); list.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;);list.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;);list.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); datagrid.ItemsSource = list; 前端代码也可以修改如下，AutoGenerateColumns属性设为不可自动创建列。 1234567891011&lt;DataGrid x:Name=&quot;datagrid&quot; SelectionMode=&quot;Extended&quot; IsReadOnly=&quot;False&quot; AutoGenerateColumns=&quot;False&quot; SelectionChanged=&quot;datagrid_Selected&quot;&gt; &lt;DataGrid.Columns&gt; &lt;DataGridTextColumn Header=&quot;姓名&quot; Binding=&quot;&#123;Binding Name&#125;&quot; /&gt; &lt;DataGridTextColumn Header=&quot;年龄&quot; Binding=&quot;&#123;Binding Age&#125;&quot; /&gt; &lt;DataGridTextColumn Header=&quot;地址&quot; Binding=&quot;&#123;Binding Address&#125;&quot; /&gt; &lt;/DataGrid.Columns&gt;&lt;/DataGrid&gt; 如此，我们便可以在DataGrid中新增一行，并输入新的数据。 ComboBox下拉框控件ComboBox表示带有下拉列表的控件，实际上您可以把它看成两个部分组成，一个类似TextBox文本输入框，所以它有一个Text文本属性，用于获取ComboBox框的文本值，另一个是类似ListBox的列表框，用于显示ComboBox绑定的所有数据源。 ComboBox继承于Selector，所以，它只能是单选操作。由于这个控件由两个部分构成，所以在用法上，我们也可以有两种主要用法——类似TextBox用法和类似ListBox用法。 我们在使用这个控件之前，先熟悉一下它的定义 一、ComboBox定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[Localizability(LocalizationCategory.ComboBox)] [StyleTypedProperty(Property = &quot;ItemContainerStyle&quot;, StyleTargetType = typeof(ComboBoxItem))] [TemplatePart(Name = &quot;PART_EditableTextBox&quot;, Type = typeof(TextBox))] [TemplatePart(Name = &quot;PART_Popup&quot;, Type = typeof(Popup))]public class ComboBox : Selector&#123; public static readonly DependencyProperty MaxDropDownHeightProperty; public static readonly DependencyProperty IsDropDownOpenProperty; public static readonly DependencyProperty ShouldPreserveUserEnteredPrefixProperty; public static readonly DependencyProperty IsEditableProperty; public static readonly DependencyProperty TextProperty; public static readonly DependencyProperty IsReadOnlyProperty; public static readonly DependencyProperty SelectionBoxItemProperty; public static readonly DependencyProperty SelectionBoxItemTemplateProperty; public static readonly DependencyProperty SelectionBoxItemStringFormatProperty; public static readonly DependencyProperty StaysOpenOnEditProperty; public ComboBox(); public bool ShouldPreserveUserEnteredPrefix &#123; get; set; &#125; public bool IsEditable &#123; get; set; &#125; public string Text &#123; get; set; &#125; public bool IsReadOnly &#123; get; set; &#125; public object SelectionBoxItem &#123; get; &#125; public double MaxDropDownHeight &#123; get; set; &#125; public string SelectionBoxItemStringFormat &#123; get; &#125; public bool StaysOpenOnEdit &#123; get; set; &#125; public bool IsSelectionBoxHighlighted &#123; get; &#125; public bool IsDropDownOpen &#123; get; set; &#125; public DataTemplate SelectionBoxItemTemplate &#123; get; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; protected internal override bool HasEffectiveKeyboardFocus &#123; get; &#125; public event EventHandler DropDownClosed; public event EventHandler DropDownOpened; public override void OnApplyTemplate(); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnDropDownClosed(EventArgs e); protected virtual void OnDropDownOpened(EventArgs e); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e); protected override void OnPreviewKeyDown(KeyEventArgs e); protected override void OnSelectionChanged(SelectionChangedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); &#125; 二、属性成员 属性名称 说明 ShouldPreserveUserEnteredPrefix 是否保留用户的输入，或者输入替换匹配项。 IsEditable 是否启用或禁用编辑文本框中文本 Text 获取或设置当前选定项的文本。 IsReadOnly 文本内容是否只读 SelectionBoxItem 获取在选择框中显示的项。 MaxDropDownHeight 获取或设置一个组合框下拉列表的最大高度。 SelectionBoxItemStringFormat 指定选择框中文本的显示格式 StaysOpenOnEdit 在编辑输入框文本时，希望下拉框保持打开，则为true IsSelectionBoxHighlighted 是否突出显示SelectionBoxItem IsDropDownOpen 是否打开组合框下拉列表。 SelectionBoxItemTemplate 获取选择框内容的项模板。 接下来，我们还是一个实际的例子来说明combobox控件的用法。 三、ComboBox示例 前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition Width=&quot;200&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;StackPanel&gt; &lt;ComboBox x:Name=&quot;combobox1&quot; IsEditable=&quot;True&quot; Height=&quot;30&quot; Margin=&quot;20,10&quot; TextBoxBase.TextChanged=&quot;combobox1_TextChanged&quot;/&gt; &lt;ComboBox x:Name=&quot;combobox2&quot; StaysOpenOnEdit=&quot;True&quot; VerticalAlignment=&quot;Top&quot; SelectionChanged=&quot;combobox2_SelectionChanged&quot; Height=&quot;30&quot; Margin=&quot;20,10&quot; DisplayMemberPath=&quot;Name&quot;&gt; &lt;/ComboBox&gt; &lt;/StackPanel&gt; &lt;StackPanel Grid.Column=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;电话:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockTel&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;姓名:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockName&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;年龄:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAge&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;地址:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAddress&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647namespace HelloWorld&#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Address &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); List&lt;Person&gt; list = new List&lt;Person&gt;(); list.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;); list.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;); list.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); combobox2.ItemsSource = list; &#125; private void combobox1_TextChanged(object sender, TextChangedEventArgs e) &#123; _TextBlockTel.Text = combobox1.Text; &#125; private void combobox2_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; ComboBox combobox = sender as ComboBox; if (combobox == null) return; var person = combobox.SelectedItem as Person; if (person == null) return; _TextBlockName.Text = person.Name; _TextBlockAge.Text = person.Age + &quot;岁&quot;; _TextBlockAddress.Text = person.Address; &#125; &#125;&#125; 我们在xaml中实例化了两个ComboBox，第一个直接当成了TextBox来使用；第二个则绑定了一个数据源，并在Xaml中指定了DisplayMemberPath属性显示Person的Name，最后在后端代码中，依然使用SelectedItem 属性获取当前选中项，转化成Person，以获取实际的选中数据。 这些就是该控件的基本用法。 TabControl控件TabControl表示包含多个共享相同的空间在屏幕上的项的控件。它也是继承于Selector基类，所以TabControl也只支持单选操作。另外，TabControl的元素只能是TabItem，这个TabItem继承于HeaderedContentControl类，所以TabControl的元素实际上是一个带标题的ContentControl内容控件。 我们曾经在聊GroupBox控件和Expander折叠控件时都曾提到过这个HeaderedContentControl类，原来大家都用了这个带标题的内容控件。所以TabControl控件看起来就像是多个GroupBox组合而来。 一、TabControl的定义 1234567891011121314151617181920212223242526272829303132public class TabControl : Selector&#123; public static readonly DependencyProperty TabStripPlacementProperty; public static readonly DependencyProperty SelectedContentProperty; public static readonly DependencyProperty SelectedContentTemplateProperty; public static readonly DependencyProperty SelectedContentTemplateSelectorProperty; public static readonly DependencyProperty SelectedContentStringFormatProperty; public static readonly DependencyProperty ContentTemplateProperty; public static readonly DependencyProperty ContentTemplateSelectorProperty; public static readonly DependencyProperty ContentStringFormatProperty; public TabControl(); public DataTemplate ContentTemplate &#123; get; set; &#125; public string SelectedContentStringFormat &#123; get; &#125; public DataTemplateSelector SelectedContentTemplateSelector &#123; get; &#125; public DataTemplate SelectedContentTemplate &#123; get; &#125; public object SelectedContent &#123; get; &#125; public Dock TabStripPlacement &#123; get; set; &#125; public string ContentStringFormat &#123; get; set; &#125; public DataTemplateSelector ContentTemplateSelector &#123; get; set; &#125; public override void OnApplyTemplate(); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnInitialized(EventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnSelectionChanged(SelectionChangedEventArgs e); &#125; 二、属性成员 属性名称 说明 ContentTemplate 表示TabItem元素的内容模板 SelectedContentStringFormat 当前所选内容的格式 SelectedContentTemplateSelector 获取当前选定的TabItem项的模板选择器 SelectedContentTemplate 当前选定的TabItem项的模板 SelectedContent 当前选定的TabItem项里面的内容（也是一些控件） TabStripPlacement 获取或设置选项卡标题相对于选项卡上内容的对齐方式。 ContentStringFormat 指定如何设置内容的格式 ContentTemplateSelector 获取或设置内容模板选择器 TabControl的SelectedContent可能是我们比较常用的一个属性，事实上，TabControl通常被当成布局控件来使用。 三、TabControl示例 前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;50&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;TabControl x:Name=&quot;_tabControl&quot; Grid.Row=&quot;0&quot; SelectionChanged=&quot;_tabControl_SelectionChanged&quot;&gt; &lt;TabItem Header=&quot;首页&quot;&gt; &lt;Border Background=&quot;LightBlue&quot;&gt; &lt;TextBlock Text=&quot;首页的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;TabItem Header=&quot;WPF目录&quot;&gt; &lt;Border Background=&quot;LightCoral&quot;&gt; &lt;TextBlock Text=&quot;WPF目录的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;TabItem Header=&quot;官方文档&quot;&gt; &lt;Border Background=&quot;LightCyan&quot;&gt; &lt;TextBlock Text=&quot;官方文档的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;TabItem Header=&quot;付费课程&quot;&gt; &lt;Border Background=&quot;LightGoldenrodYellow&quot;&gt; &lt;TextBlock Text=&quot;付费课程的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;TabItem Header=&quot;统计&quot;&gt; &lt;Border Background=&quot;LightGreen&quot;&gt; &lt;TextBlock Text=&quot;统计的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;/TabControl&gt; &lt;TextBlock x:Name=&quot;_textBlock&quot; TextWrapping=&quot;Wrap&quot; Grid.Row=&quot;1&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 123456789101112131415public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _tabControl_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; var tab = sender as TabControl; var item = tab.SelectedItem as TabItem; var content = tab.SelectedContent; _textBlock.Text = &quot;标题:&quot; + item.Header.ToString() + &quot; 内容:&quot; + content; &#125;&#125; 我们订阅了TabControl控件的SelectionChanged事件，并在回调函数中获取了当前选中的TabItem对象以及它里面的内容。 TreeView树控件TreeView其实是一个比较复杂的控件，像操作系统的资源管理器就是一个TreeView。所以它常用于显示文件夹、目录等具有层级结构的数据。TreeView由节点和分支构成，每个节点可以包含零个或多个子节点，分支表示父子关系。在TreeView中，每个节点表示为TreeViewItem对象，可以通过TreeView的Items属性来获取或设置TreeViewItem对象集合。 在使用TreeView加载节点时，需要掌握一些递归思想。 一、TreeViewItem元素简介 TreeViewItem作为TreeView唯一的元素类型，它继承于HeaderedItemsControl（带标题），而HeaderedItemsControl又继承于ItemsControl，由此可见，TreeViewItem元素本身也是一个集合控件。 TreeViewItem有两个常用的属性，分别是IsSelected属性和IsExpanded属性，IsSelected表示当前元素是否选中，IsExpanded表示当前元素是否展开。 二、TreeView类的定义 123456789101112131415161718192021222324252627public class TreeView : ItemsControl&#123; public static readonly DependencyProperty SelectedItemProperty; public static readonly DependencyProperty SelectedValueProperty; public static readonly DependencyProperty SelectedValuePathProperty; public static readonly RoutedEvent SelectedItemChangedEvent; public TreeView(); public string SelectedValuePath &#123; get; set; &#125; public object SelectedValue &#123; get; &#125; public object SelectedItem &#123; get; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public event RoutedPropertyChangedEventHandler&lt;object&gt; SelectedItemChanged; protected virtual bool ExpandSubtree(TreeViewItem container); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnGotFocus(RoutedEventArgs e); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected virtual void OnSelectedItemChanged(RoutedPropertyChangedEventArgs&lt;object&gt; e); &#125; SelectedValuePath属性：获取或设置SelectedItem或SelectedValue的路径。 SelectedValue属性：获取SelectedItem的值 SelectedItem属性：获取当前选中的项 三、TreeView示例 接下来，我们以一个简单的示例，模仿操作系统的资源管理器的目录加载。 前端代码 12345678910111213141516171819202122&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;根目录&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;3&quot;/&gt; &lt;TextBox x:Name=&quot;_TextBox&quot; Width=&quot;380&quot; Height=&quot;25&quot; Margin=&quot;3&quot;/&gt; &lt;Button Content=&quot;选择...&quot; MinWidth=&quot;45&quot; Margin=&quot;3&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;TreeView x:Name=&quot;_TreeView&quot; Grid.Row=&quot;1&quot; SelectedItemChanged=&quot;_TreeView_SelectedItemChanged&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; System.Windows.Forms.FolderBrowserDialog dialog = new System.Windows.Forms.FolderBrowserDialog(); if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK) &#123; _TextBox.Text = dialog.SelectedPath; LoadTreeView(dialog.SelectedPath); &#125; &#125; private void LoadTreeView(string rootPath) &#123; // 设置根节点 TreeViewItem rootNode = new TreeViewItem(); rootNode.Header = &quot;根目录&quot;; // 加载子文件夹和文件 LoadSubDirectory(rootNode, rootPath); // 将根节点添加到TreeView中 _TreeView.Items.Add(rootNode); &#125; private void LoadSubDirectory(TreeViewItem node, string path) &#123; try &#123; DirectoryInfo dirInfo = new DirectoryInfo(path); // 加载子文件夹 foreach (DirectoryInfo subDirInfo in dirInfo.GetDirectories()) &#123; TreeViewItem subNode = new TreeViewItem(); subNode.Header = subDirInfo.Name; LoadSubDirectory(subNode, subDirInfo.FullName); node.Items.Add(subNode); &#125; // 加载文件 foreach (FileInfo fileInfo in dirInfo.GetFiles()) &#123; TreeViewItem subNode = new TreeViewItem(); subNode.Header = fileInfo.Name; node.Items.Add(subNode); &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; &#125; private void _TreeView_SelectedItemChanged(object sender, RoutedPropertyChangedEventArgs&lt;object&gt; e) &#123; // 获取选中的节点 TreeViewItem selectedNode = _TreeView.SelectedItem as TreeViewItem; // 显示选中节点的Header if (selectedNode != null) &#123; MessageBox.Show(selectedNode.Header.ToString()); &#125; &#125;&#125; 首先，通过鼠标操作，选择TreeView的根目录，然后，利用DirectoryInfo获取当前所有目录，再利用递归调用，一层一层的获取所有子目录，最后以TreeViewItem元素一层层加载到控件中。 Menu菜单Menu控件继承于MenuBase，而MenuBase继承于ItemsControl。所以学习Menu之前，要先了解一下MenuBase基类。它是一个抽象类，拥有一个ItemContainerTemplateSelector模板选择器，并重写了一些关于键盘和鼠标的方法。 Menu的子项必须为MenuItem。这个MenuItem和前面的TreeViewItem类似，拥有共同的HeaderedItemsControl父类，也就是说，MenuItem本身也是一个集合控件，若要以代码形式加载Menu的内容，也必须要掌握递归的加载思路。 在本节中，我们将以两种方式加载Menu的数据。但是在学习之前，先熟悉一下MenuItem元素，因为，实际上，我们主要是操作MenuItem元素。 一、MenuItem元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class MenuItem : HeaderedItemsControl, ICommandSource&#123; public static readonly RoutedEvent ClickEvent; public static readonly DependencyProperty UsesItemContainerTemplateProperty; public static readonly DependencyProperty ItemContainerTemplateSelectorProperty; public static readonly DependencyProperty IsSuspendingPopupAnimationProperty; public static readonly DependencyProperty IconProperty; public static readonly DependencyProperty InputGestureTextProperty; public static readonly DependencyProperty StaysOpenOnClickProperty; public static readonly DependencyProperty IsCheckedProperty; public static readonly DependencyProperty IsHighlightedProperty; public static readonly DependencyProperty IsCheckableProperty; public static readonly DependencyProperty IsPressedProperty; public static readonly DependencyProperty IsSubmenuOpenProperty; public static readonly DependencyProperty CommandTargetProperty; public static readonly DependencyProperty CommandParameterProperty; public static readonly DependencyProperty CommandProperty; public static readonly RoutedEvent SubmenuClosedEvent; public static readonly RoutedEvent SubmenuOpenedEvent; public static readonly RoutedEvent UncheckedEvent; public static readonly RoutedEvent CheckedEvent; public static readonly DependencyProperty RoleProperty; public MenuItem(); public static ResourceKey SubmenuHeaderTemplateKey &#123; get; &#125; public static ResourceKey SubmenuItemTemplateKey &#123; get; &#125; public static ResourceKey SeparatorStyleKey &#123; get; &#125; public static ResourceKey TopLevelItemTemplateKey &#123; get; &#125; public static ResourceKey TopLevelHeaderTemplateKey &#123; get; &#125; public bool IsCheckable &#123; get; set; &#125; public object CommandParameter &#123; get; set; &#125; public IInputElement CommandTarget &#123; get; set; &#125; public bool IsSubmenuOpen &#123; get; set; &#125; public MenuItemRole Role &#123; get; &#125; public bool IsPressed &#123; get; protected set; &#125; public bool IsHighlighted &#123; get; protected set; &#125; public bool StaysOpenOnClick &#123; get; set; &#125; public string InputGestureText &#123; get; set; &#125; public object Icon &#123; get; set; &#125; public bool IsSuspendingPopupAnimation &#123; get; &#125; public ItemContainerTemplateSelector ItemContainerTemplateSelector &#123; get; set; &#125; public bool UsesItemContainerTemplate &#123; get; set; &#125; public bool IsChecked &#123; get; set; &#125; public ICommand Command &#123; get; set; &#125; protected override bool IsEnabledCore &#123; get; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public event RoutedEventHandler Unchecked; public event RoutedEventHandler Click; public event RoutedEventHandler Checked; public event RoutedEventHandler SubmenuClosed; public event RoutedEventHandler SubmenuOpened; public override void OnApplyTemplate(); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override void OnAccessKey(AccessKeyEventArgs e); protected virtual void OnChecked(RoutedEventArgs e); protected virtual void OnClick(); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e); protected override void OnInitialized(EventArgs e); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnMouseEnter(MouseEventArgs e); protected override void OnMouseLeave(MouseEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected override void OnMouseRightButtonDown(MouseButtonEventArgs e); protected override void OnMouseRightButtonUp(MouseButtonEventArgs e); protected virtual void OnSubmenuClosed(RoutedEventArgs e); protected virtual void OnSubmenuOpened(RoutedEventArgs e); protected virtual void OnUnchecked(RoutedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); protected override bool ShouldApplyItemContainerStyle(DependencyObject container, object item); protected internal override void OnVisualParentChanged(DependencyObject oldParent); &#125; MenuItem从鼠标的交互上，提供了两种方式。第一种是提供了Click事件，开发者可以订阅该事件以编写相应的业务逻辑。第二种是提供了ICommand接口属性和CommandParameter命令参数，以WPF命令的形式开发业务逻辑。 下面，我们以一种交互方式为例。 二、Menu示例 前端代码 1234567891011121314151617181920212223242526272829303132333435&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Menu x:Name=&quot;_Menu&quot;&gt; &lt;MenuItem Header=&quot;文件&quot;&gt; &lt;MenuItem Header=&quot;新建&quot; Click=&quot;MenuItem_Click&quot;/&gt; &lt;MenuItem Header=&quot;打开&quot; Click=&quot;MenuItem_Click&quot;&gt; &lt;MenuItem.Icon&gt; &lt;Image Source=&quot;/Images/logo.png&quot;/&gt; &lt;/MenuItem.Icon&gt; &lt;/MenuItem&gt; &lt;/MenuItem&gt; &lt;MenuItem Header=&quot;编辑&quot;/&gt; &lt;MenuItem Header=&quot;视图&quot;/&gt; &lt;MenuItem Header=&quot;项目&quot;/&gt; &lt;MenuItem Header=&quot;调试&quot;/&gt; &lt;MenuItem Header=&quot;测试&quot;/&gt; &lt;MenuItem Header=&quot;分析&quot;/&gt; &lt;MenuItem Header=&quot;工具&quot;/&gt; &lt;MenuItem Header=&quot;帮助&quot;/&gt; &lt;/Menu&gt; &lt;TextBlock x:Name=&quot;_TextBlock&quot; Grid.Row=&quot;1&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt;&lt;/TextBlock&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 12345678910111213public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void MenuItem_Click(object sender, RoutedEventArgs e) &#123; var item = sender as MenuItem; _TextBlock.Text = $&quot;你单击了 &#123;item.Header&#125;&quot;; &#125;&#125; 上面演示了Menu最基本的用法，如果希望采用数据绑定的方式加载菜单，则可以参考下面的作法。 三、Menu数据绑定 我们需要创建一个实体类，来代表Menu的每一个子项。 123456789/// &lt;summary&gt;/// 主菜单的实体/// &lt;/summary&gt;public class MenuModel&#123; public string Name &#123; get; set; &#125; public List&lt;MenuModel&gt; Children &#123; get; set; &#125; = new List&lt;MenuModel&gt;(); public string View &#123; get; set; &#125;&#125; 在前端代码中，需要设置Menu的ItemTemplate元素模板。 1234567891011121314151617181920212223&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Menu x:Name=&quot;_Menu&quot;&gt; &lt;Menu.ItemTemplate&gt; &lt;HierarchicalDataTemplate ItemsSource=&quot;&#123;Binding Children&#125;&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot;/&gt; &lt;/HierarchicalDataTemplate&gt; &lt;/Menu.ItemTemplate&gt; &lt;/Menu&gt; &lt;/Grid&gt;&lt;/Window&gt; 因为MenuModel实体中有Children集合，所以在前端将Children作为HierarchicalDataTemplate的ItemsSource。并将Name显示出来。 最后，实例化一些子项数据，形成一个数据源，将这个数据源绑定到Menu的ItemsSource即可 来看看后端代码 12345678910111213141516171819202122232425public partial class MainWindow : Window&#123; public List&lt;MenuModel&gt; Menus &#123; get; set; &#125; = new List&lt;MenuModel&gt;(); public MainWindow() &#123; InitializeComponent(); for (int i = 0; i &lt; 5; i++) &#123; MenuModel parent = new MenuModel(); parent.Name = $&quot;一级菜单 &quot;; for (int j = 0; j &lt; 5; j++) &#123; MenuModel child = new MenuModel(); child.Name = $&quot;二级菜单 &quot;; parent.Children.Add(child); &#125; Menus.Add(parent); &#125; _Menu.ItemsSource = Menus; &#125; &#125; ContextMenu上下文菜单ContextMenu上下文菜单必须要依附于一个“宿主控件”。由于FrameworkElement基类有一个叫ContextMenu的属性，代表了鼠标右键时弹出一个菜单，所以大多数控件都可以设置“上下文菜单”。 ContextMenu继承于MenuBase，而MenuBase继承于ItemsControl。所以，ContextMenu本质上也是一个集合控件。而它的元素则是MenuItem。在用法上，与Menu控件差不多。 一、ContextMenu的定义 12345678910111213141516171819202122232425262728293031323334353637383940public class ContextMenu : MenuBase&#123; public static readonly DependencyProperty HorizontalOffsetProperty; public static readonly RoutedEvent OpenedEvent; public static readonly DependencyProperty StaysOpenProperty; public static readonly DependencyProperty CustomPopupPlacementCallbackProperty; public static readonly DependencyProperty HasDropShadowProperty; public static readonly RoutedEvent ClosedEvent; public static readonly DependencyProperty PlacementRectangleProperty; public static readonly DependencyProperty PlacementTargetProperty; public static readonly DependencyProperty IsOpenProperty; public static readonly DependencyProperty VerticalOffsetProperty; public static readonly DependencyProperty PlacementProperty; public ContextMenu(); public double HorizontalOffset &#123; get; set; &#125; public bool StaysOpen &#123; get; set; &#125; public CustomPopupPlacementCallback CustomPopupPlacementCallback &#123; get; set; &#125; public bool HasDropShadow &#123; get; set; &#125; public PlacementMode Placement &#123; get; set; &#125; public Rect PlacementRectangle &#123; get; set; &#125; public UIElement PlacementTarget &#123; get; set; &#125; public bool IsOpen &#123; get; set; &#125; public double VerticalOffset &#123; get; set; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public event RoutedEventHandler Closed; public event RoutedEventHandler Opened; protected virtual void OnClosed(RoutedEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected virtual void OnOpened(RoutedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); protected internal override void OnVisualParentChanged(DependencyObject oldParent); &#125; 二、属性成员 属性名称 说明 HorizontalOffset 获取或设置目标原点和弹出项对齐之间的水平距离点。 StaysOpen 是否保持打开状态 CustomPopupPlacementCallback 获取或设置ContextMenu指示在屏幕位置的回调 HasDropShadow 是否有投影出现的上下文菜单。 Placement 获取或设置ContextMenu显示的相对位置 PlacementRectangle 获取或设置相对于其上下文菜单位于在打开时的区域。 PlacementTarget 获取或设置ContextMenu打开时的相对控件 IsOpen 是否打开 VerticalOffset 获取或设置目标原点和弹出项对齐之间的垂直距离点。 三、ContextMenu示例 123456789101112&lt;Grid&gt; &lt;Border Background=&quot;LightBlue&quot; Width=&quot;200&quot; Height=&quot;100&quot; CornerRadius=&quot;15&quot;&gt; &lt;Border.ContextMenu&gt; &lt;ContextMenu&gt; &lt;MenuItem Header=&quot;复制&quot;/&gt; &lt;MenuItem Header=&quot;粘贴&quot;/&gt; &lt;MenuItem Header=&quot;删除&quot;/&gt; &lt;MenuItem Header=&quot;关于&quot;/&gt; &lt;/ContextMenu&gt; &lt;/Border.ContextMenu&gt; &lt;/Border&gt; &lt;/Grid&gt; StatusBar状态栏StatusBar是一个“包容性”极强的控件，通常的作用是作为程序的状态内容显示。它同样继承于ItemsControl基类，所以，它也是一个集合控件。 它的元素是StatusBarItem类型，而StatusBarItem继承于ContentControl内容控件，所以，本质上讲，StatusBar的元素可以是任意类型的控件。因为StatusBarItem元素有一个叫Content的属性。 这个控件其实并不常用，通常情况下被当成一个布局控件来使用。如下所示 12345678910111213141516171819&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StatusBar Grid.Row=&quot;1&quot;&gt; &lt;StatusBarItem Content=&quot;版权所有 @WPF中文网&quot;/&gt; &lt;StatusBarItem&gt; &lt;CheckBox Content=&quot;CheckBox&quot;/&gt; &lt;/StatusBarItem&gt; &lt;StatusBarItem&gt; &lt;RadioButton Content=&quot;RadioButton&quot;/&gt; &lt;/StatusBarItem&gt; &lt;StatusBarItem&gt; &lt;Button Content=&quot;Button&quot;/&gt; &lt;/StatusBarItem&gt; &lt;TextBlock Text=&quot;文字块&quot;/&gt; &lt;/StatusBar&gt;&lt;/Grid&gt; 如上所示，StatusBar的元素除了StatusBarItem，甚至可以直接实例化其它控件，比如最后一个TextBlock就是这样的用法。 图形控件Shape概述形状是WPF另一大系列控件。WPF所有的形状都继承于Shape基类。那么，WPF提供了哪些可用的形状呢？我们用一张图来说明它的子类。 形状名称 说明 Ellipse 椭圆形 Line 在两个点之间绘制直线。 Rectangle 绘制矩形。 Polyline 绘制一系列相互连接的直线。 Polygon 绘制多边形，它是由一系列相互连接的线条构成的闭合形状。 Path 绘制一系列相互连接的直线和曲线。 Shape是一个抽象基类，它不能被实例化，所以我们在使用时只能实例化它的子类。而Shape的父类是FrameworkElement，所以，所有的Shape子类都是一个UIElement 类，因此形状对象可以用在面板和大多数控件中。 由于 Canvas 面板支持其子对象的绝对位置，因此特别适合创建复杂的图形。 我们来看看Shape的定义 一、Shape的定义 123456789101112131415161718192021222324252627282930313233343536public abstract class Shape : FrameworkElement&#123; public static readonly DependencyProperty StretchProperty; public static readonly DependencyProperty StrokeDashArrayProperty; public static readonly DependencyProperty StrokeDashOffsetProperty; public static readonly DependencyProperty StrokeLineJoinProperty; public static readonly DependencyProperty StrokeDashCapProperty; public static readonly DependencyProperty StrokeMiterLimitProperty; public static readonly DependencyProperty StrokeStartLineCapProperty; public static readonly DependencyProperty StrokeThicknessProperty; public static readonly DependencyProperty StrokeProperty; public static readonly DependencyProperty FillProperty; public static readonly DependencyProperty StrokeEndLineCapProperty; protected Shape(); public Brush Stroke &#123; get; set; &#125; public PenLineCap StrokeEndLineCap &#123; get; set; &#125; public PenLineCap StrokeStartLineCap &#123; get; set; &#125; public double StrokeThickness &#123; get; set; &#125; public Brush Fill &#123; get; set; &#125; public double StrokeDashOffset &#123; get; set; &#125; public virtual Geometry RenderedGeometry &#123; get; &#125; public Stretch Stretch &#123; get; set; &#125; public DoubleCollection StrokeDashArray &#123; get; set; &#125; public double StrokeMiterLimit &#123; get; set; &#125; public PenLineCap StrokeDashCap &#123; get; set; &#125; public virtual Transform GeometryTransform &#123; get; &#125; public PenLineJoin StrokeLineJoin &#123; get; set; &#125; protected abstract Geometry DefiningGeometry &#123; get; &#125; protected override Size ArrangeOverride(Size finalSize); protected override Size MeasureOverride(Size constraint); protected override void OnRender(DrawingContext drawingContext); &#125; Shape基类提供了许多公共属性，如下表所示。 二、属性成员 属性名称 说明 Stroke 获取或设置Shape的边框颜色画刷 StrokeEndLineCap 获取或设置Shape描述线的末端的样式 StrokeStartLineCap 获取或设置Shape描述线的开头的样式 StrokeThickness 获取或设置Shape边框的厚度 Fill 获取或设置Shape的内部填充颜色 StrokeDashOffset 获取或设置短划线模式内短划线开始处的距离 RenderedGeometry 获取或设置Shape的几何 Stretch 获取或设置Shape的填充模式 StrokeDashArray 获取或设置勾勒形状轮廓的短划线和间隙的模式的值 StrokeMiterLimit 获取或设置一个限制到一半的斜接长度比 StrokeDashCap 获取或设置 System.Windows.Media.PenLineCap 枚举值，该值指定如何绘制虚线的末端。 GeometryTransform 获取或设置Shape的转换 StrokeLineJoin 获取或设置Shape的顶点处使用的联接类型。 DefiningGeometry 获取Shape的Geometry Ellipse椭圆Ellipse继承于Shape，Shape继承于FrameworkElement，所以，它可以设置其 Width 和 Height。 使用其 Fill 属性指定用于绘制椭圆形内部的 Brush。 使用其 Stroke 属性指定用于绘制椭圆形轮廓的 Brush。 StrokeThickness 属性指定椭圆形轮廓的粗细。 下面的示例演示了椭圆和正圆。 前端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;WPF中文网 - wpfsoft.com - 椭圆课程&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Ellipse Width=&quot;100&quot; Height=&quot;50&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;2&quot; Fill=&quot;Red&quot;&gt; &lt;Ellipse.Triggers&gt; &lt;EventTrigger RoutedEvent=&quot;Loaded&quot;&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation From=&quot;100&quot; To=&quot;200&quot; Duration=&quot;0:0:2&quot; AutoReverse=&quot;True&quot; RepeatBehavior=&quot;Forever&quot; Storyboard.TargetProperty=&quot;(Ellipse.Width)&quot; /&gt; &lt;DoubleAnimation From=&quot;50&quot; To=&quot;100&quot; Duration=&quot;0:0:2&quot; AutoReverse=&quot;True&quot; RepeatBehavior=&quot;Forever&quot; Storyboard.TargetProperty=&quot;(Ellipse.Height)&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt; &lt;/Ellipse.Triggers&gt; &lt;/Ellipse&gt; &lt;Grid Grid.Column=&quot;1&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Ellipse Width=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Height=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Fill=&quot;Green&quot;/&gt; &lt;Slider x:Name=&quot;slider&quot; Grid.Row=&quot;1&quot; Value=&quot;50&quot; Maximum=&quot;200&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt;&lt;/Window&gt; 在上面的例子中，我们实例化了两个椭圆，第一个椭圆用了一个事件Triggers和Storyboard故事板，演示了椭圆大小的动画改变，在第二个椭圆中，宽度和高度相等，便出现了一个正圆，利用Binding对象将Slider的Value和椭圆的尺寸绑定起来，以此滑动改变椭圆大小。 注：关于动画部分，我们将在后面专门讲解。 Line线段Line(线段)继承于Shape，它自身只有4个属性，分别用于定义线段两端的端点坐标。 123456789101112131415public sealed class Line : Shape&#123; public static readonly DependencyProperty X1Property; public static readonly DependencyProperty Y1Property; public static readonly DependencyProperty X2Property; public static readonly DependencyProperty Y2Property; public Line(); public double X1 &#123; get; set; &#125; public double Y1 &#123; get; set; &#125; public double X2 &#123; get; set; &#125; public double Y2 &#123; get; set; &#125; protected override Geometry DefiningGeometry &#123; get; &#125;&#125; 其中X1,Y1表示第一个点坐标，X2,Y2表示第二个点坐标。 下面的属性位于Shape基类，在Line线段中设置后，会有意想不到的效果。 StrokeStartLineCap属性：表示线段前头的开关。 Stroke：线条颜色。 StrokeThickness：线条宽度。 StrokeDashArray：设置虚线。 StrokeDashOffset：虚线位置偏移量。 接下来，我们以一个示例来说明Line的用法。 前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;WPF中文网 - wpfsoft.com - Line课程&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Canvas x:Name=&quot;canvas&quot;&gt; &lt;Line x:Name=&quot;flowLine&quot; X1=&quot;20&quot; Y1=&quot;40&quot; X2=&quot;400&quot; Y2=&quot;100&quot; StrokeDashArray=&quot;2,1&quot; Stroke=&quot;Green&quot; StrokeThickness=&quot;8&quot;/&gt; &lt;Line X1=&quot;&#123;Binding ElementName=x1,Path=Value&#125;&quot; Y1=&quot;&#123;Binding ElementName=y1,Path=Value&#125;&quot; X2=&quot;&#123;Binding ElementName=x2,Path=Value&#125;&quot; Y2=&quot;&#123;Binding ElementName=y2,Path=Value&#125;&quot; StrokeStartLineCap=&quot;Round&quot; Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;/&gt; &lt;Slider x:Name=&quot;x1&quot; Value=&quot;10&quot; Maximum=&quot;450&quot; Width=&quot;450&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;237&quot;/&gt; &lt;Slider x:Name=&quot;y1&quot; Value=&quot;10&quot; Maximum=&quot;450&quot; Width=&quot;450&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;256&quot;/&gt; &lt;Slider x:Name=&quot;x2&quot; Value=&quot;300&quot; Maximum=&quot;450&quot; Width=&quot;450&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;276&quot;/&gt; &lt;Slider x:Name=&quot;y2&quot; Value=&quot;300&quot; Maximum=&quot;450&quot; Width=&quot;450&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;295&quot;/&gt; &lt;/Canvas&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); Loaded += (s, e) =&gt; &#123; int number = 10; Task.Run(() =&gt; &#123; while (true) &#123; if (number == 1) number = 10; Application.Current.Dispatcher.BeginInvoke(new Action(() =&gt; &#123; flowLine.StrokeDashOffset = number; &#125;)); number--; Thread.Sleep(250); &#125; &#125;); &#125;; &#125;&#125; 在XAML代码中，我们实例化了两个Line，其中一个Line的端点坐标绑定了4个Slider的Value属性，可以通过滑动改变线条的位置，第二Line设置为虚线，并通过C#代码开辟子线程，在子线程中通过动态设置StrokeDashOffset属性，来模拟流动的线段效果。 Rectangle矩形Rectangle是一个比较简单而实用的图形控件，继承于Shape，有两个属性比较常用，即RadiusX和RadiusY，表示设置矩形的圆角。所以，通过这两个属性的设置，矩形也可以画出一个圆。 观察下面的例子。 12345678910111213141516171819202122232425262728293031&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;WPF中文网 - wpfsoft.com -课程&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Canvas x:Name=&quot;canvas&quot;&gt; &lt;Rectangle RadiusX=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; RadiusY=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Width=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Height=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Fill=&quot;Red&quot; Canvas.Left=&quot;50&quot; Canvas.Top=&quot;36&quot;/&gt; &lt;Rectangle Width=&quot;100&quot; Height=&quot;100&quot; Fill=&quot;Green&quot; Canvas.Left=&quot;313&quot; Canvas.Top=&quot;36&quot;/&gt; &lt;Slider x:Name=&quot;slider&quot; Width=&quot;450&quot; Value=&quot;100&quot; Maximum=&quot;450&quot; Canvas.Left=&quot;32&quot; Canvas.Top=&quot;291&quot;/&gt; &lt;/Canvas&gt;&lt;/Window&gt; 在本例中，我们实例化了两个Rectangle对象，如果RadiusX和RadiusY与Width、Height相等，则会显示一个正圆。 Polyline折线Polyline表示由一系列线段组合绘制而成的折线，因为它有一个Points属性，用来保存这些点的坐标。这些坐标点用于绘制Polyline图形中各线段相接处的顶点。集合中第一个元素表示起点，最后一元素表示终点。 在XAML前端代码中定义Points的内容书写格式如下：假如我们有4个点，分别是起点(30,30)，中继点(200,30)，中继点(50,250)，终点(220,250)，那么，Points的内容书写为：Points&#x3D;”30,30 200,30 50,250 220,250” 完整代码如下所示 12345678910111213&lt;Canvas x:Name=&quot;canvas&quot;&gt; &lt;Polyline StrokeThickness=&quot;20&quot; Points=&quot;30,30 200,30 50,250 220,250&quot;&gt; &lt;Polyline.Stroke&gt; &lt;LinearGradientBrush StartPoint=&quot;30,30&quot; EndPoint=&quot;220,250&quot; MappingMode=&quot;Absolute&quot;&gt; &lt;GradientStop Color=&quot;Red&quot; Offset=&quot;1&quot; /&gt; &lt;GradientStop Color=&quot;Yellow&quot; Offset=&quot;0.66&quot; /&gt; &lt;GradientStop Color=&quot;Green&quot; Offset=&quot;0&quot; /&gt; &lt;/LinearGradientBrush&gt; &lt;/Polyline.Stroke&gt; &lt;/Polyline&gt;&lt;/Canvas&gt; Polygon多边形Polygon叫多边形，与Polyline类似，都有一个Points属性，只不过，Polygon会把起点和终点连接起来。就拿上一节的例子，我们只是简单地把Polyline换成Polygon，其它设置保持不变。如下所示： 12345678910111213&lt;Canvas x:Name=&quot;canvas&quot;&gt; &lt;Polygon StrokeThickness=&quot;20&quot; Points=&quot;30,30 200,30 50,250 220,250&quot;&gt; &lt;Polygon.Stroke&gt; &lt;LinearGradientBrush StartPoint=&quot;30,30&quot; EndPoint=&quot;220,250&quot; MappingMode=&quot;Absolute&quot;&gt; &lt;GradientStop Color=&quot;Red&quot; Offset=&quot;1&quot; /&gt; &lt;GradientStop Color=&quot;Yellow&quot; Offset=&quot;0.66&quot; /&gt; &lt;GradientStop Color=&quot;Green&quot; Offset=&quot;0&quot; /&gt; &lt;/LinearGradientBrush&gt; &lt;/Polygon.Stroke&gt; &lt;/Polygon&gt;&lt;/Canvas&gt; 结果，在Polyline下面原本呈现的Z字形，在Polygon下面就变成了一个8字形，可以很明显的看到它的起点和终点相连起来了。 同理，我们在C#后端，也相应的修改成Polygon对象。 123456789101112131415161718192021222324252627282930public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private int count = 0; private Polygon polygon = null; private void Window_PreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e) &#123; if (count++ == 0) &#123; polygon = new Polygon(); polygon.StrokeThickness = 5; polygon.Stroke = Brushes.Red; canvas.Children.Add(polygon); &#125; var point = e.GetPosition(canvas); polygon.Points.Add(point); &#125; private void Window_PreviewMouseRightButtonUp(object sender, MouseButtonEventArgs e) &#123; count = 0; &#125;&#125; 最后，效果如上，用鼠标绘制出来的就是封闭的多边形。 Path路径12345678910public sealed class Path : Shape&#123; public static readonly DependencyProperty DataProperty; public Path(); public Geometry Data &#123; get; set; &#125; protected override Geometry DefiningGeometry &#123; get; &#125;&#125; 从定义上看，Path只有一个Data属性，这个属性的类型为Geometry。而Geometry又是一个抽象类，所以我们不能直接使用它，那它肯定会有一系列可以实例化的子类。没错，Geometry表示一个几何，而几何的图形可以分为好几种。 几何名称 说明 LineGeometry 直线几何 RectangleGeometry 矩形几何 EllipseGeometry 椭圆几何 PathGeometry 路径几何 StreamGeometry PathGeometry的轻量级替代品，不支持 Bidning、动画等功能 CombinedGeometry 多图形组合，形成单一几何几何图形 GeometryGroup 多图形组合，形成几何图形组 接下来，我们分别讲一下这几种几何的用法。 一、LineGeometry直线几何 12345&lt;Path Stroke=&quot;Blue&quot; Fill=&quot;Red&quot;&gt; &lt;Path.Data&gt; &lt;LineGeometry StartPoint=&quot;10,20&quot; EndPoint=&quot;100,200&quot;/&gt; &lt;/Path.Data&gt;&lt;/Path&gt; 二、RectangleGeometry矩形几何 12345&lt;Path Stroke=&quot;Blue&quot; Fill=&quot;Red&quot;&gt; &lt;Path.Data&gt; &lt;RectangleGeometry Rect=&quot;50,20,30,40&quot; /&gt; &lt;/Path.Data&gt;&lt;/Path&gt; 三、EllipseGeometry椭圆几何 12345&lt;Path Stroke=&quot;Yellow&quot; Fill=&quot;LightGreen&quot;&gt; &lt;Path.Data&gt; &lt;EllipseGeometry Center=&quot;150,80&quot; RadiusX=&quot;60&quot; RadiusY=&quot;50&quot;/&gt; &lt;/Path.Data&gt;&lt;/Path&gt; 从上面的3个例子来看，Line、Rectangle、Ellipse控件能够画出来的效果，Path都可以画出来。而接下来我们要分享的是，Line、Rectangle、Ellipse控件画不出来的效果，Path也能画出来。那就是PathGeometry路径几何。 四、PathGeometry路径几何 PathGeometry微微有点复杂。它有一个Figures属性，可以容纳很多较复杂的图形。Figures是一个集合，其中的元素是PathFigure类型，而PathFigure中的Segments属性又是一个集合，其中的元素类型为PathSegment。 PathSegment是一个抽象类，我们可以实例化PathSegment的子类放到PathFigure中，然后把PathFigure放到PathGeometry中，这样就可以绘制不同的路径图形了。那么PathSegment有哪些子类呢？ LineSegment 直线段 ArcSegment 圆弧线段 BezierSegment 三次方贝塞尔曲线段 QuadraticBezierSegmnt 二次方贝塞尔曲线段 PolyLineSegment 折线段 PolyBezierSegment 多三次方贝塞尔曲线段 PolyQuadraticBezierSegment 多二次方贝塞尔曲 PathFigure有一个StartPoint属性表示起点坐标，而Segments集合中的元素就是上面那张表中的各种线段实例，它们将依次首尾相接，最终绘制成形。 我们以LineSegment和ArcSegment为例。 12345678910111213141516171819&lt;Path Stroke=&quot;Black&quot; Fill=&quot;LightPink&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathGeometry.Figures&gt; &lt;PathFigure StartPoint=&quot;150,200&quot;&gt; &lt;LineSegment Point=&quot;300,200&quot;/&gt; &lt;ArcSegment Point=&quot;300 50&quot; Size=&quot;100 100&quot; SweepDirection=&quot;Clockwise&quot; IsLargeArc=&quot;False&quot;/&gt; &lt;ArcSegment Point=&quot;300 200&quot; Size=&quot;100 100&quot; SweepDirection=&quot;Clockwise&quot; IsLargeArc=&quot;False&quot;/&gt; &lt;/PathFigure&gt; &lt;/PathGeometry.Figures&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt;&lt;/Path&gt; 首先，PathFigure 图形的起点坐标为（150,200），然后第一个元素是线段，终点坐标为（300,200），图形的坐标原点是左上角（0，0），所以，往下就是Y轴正半轴方向，往右就是X轴正半轴方向。 然后，画了两条圆弧，第一条圆弧的起点坐标就是线段的终点坐标，即（300,200），圆弧的终点坐标为（300 50），大小为（100 100），第二条圆弧的终点坐标又回到了线段的终点坐标（300 200），于是就出现了图中的样子。 ArcSegment的常用属性如下：Point：指明圆弧连接的终点；Size：指明完整椭圆的横轴半径和纵轴半径；IsLargeArc：指明是否使用大弧去连接 ；SweepDirection ：指明圆弧是顺时针方向还是逆时针方向；RotationAngle：指明圆弧椭圆的旋转角度； 接下来，我们再讲一下BezierSegment贝塞尔曲线。 BezierSegment需要4个坐标点来完成图形的绘制，分别是起点，控制点1，控制点2和终点。 123&lt;PathFigure IsFilled=&quot;False&quot; StartPoint=&quot;5,5&quot;&gt; &lt;BezierSegment Point1=&quot;200,50&quot; Point2=&quot;50,200&quot; Point3=&quot;350,250&quot;/&gt;&lt;/PathFigure&gt; 如上所示，（5，5）表示起点（StartPoint属性），Point1属性（200,50）和Point2属性（50,200）表示两个控制点，Point3属性（350,250）表示终点。 五、Path的标记语法 通过上面的示例我们会发现要绘制复杂的图形，需要实例化各种子类，代码繁琐，这时就需要了解Path的路径标记语法，它大大减少了代码量。您可以从以下的表格或微软官网中获得相关知识。 命令 用途 语法 示例 对应标签语法 M 移动到起点坐标 M 起点 M 150,200 L 绘制直线 L 终点 L 300,200 H 水平直线 H 终点横坐标 V 垂直直线 V 终点横坐标 A 绘制圆弧 A 母椭圆尺寸 旋转角度 是否大弧 顺时针&#x2F;逆时针 终点 A 180，80 45 1 1 150，150 C 三次方贝塞尔曲线 C 控制点1 控制点2 终点 C 200,50 50,200 350,250 Q 二次方贝塞尔曲线 Q 控制点1 终点 Q 200,50 350,250 S 平滑三次方贝塞尔曲线 S 控制点2 终点 S 200,50 350,250 T 平滑二次方贝塞尔曲线 T 终点 T 350,250 Z 闭合图形 Z M 10,150 L40,150 L40,250 L10,250 Z 1&lt;Path Fill=&quot;HotPink&quot; Data=&quot;M 10,150 L40,150 L40,250 L10,250 Z&quot;/&gt; 最后，我们通过Path的路径标记语法画了一个封闭的矩形图形，可以看到代码量的书写大大减少了。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"WPF - 编程","slug":"WPF-编程","permalink":"http://example.com/tags/WPF-%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"WPF编程基础上（一）","slug":"WPF基础学习上","date":"2025-05-11T10:00:24.000Z","updated":"2025-05-13T14:34:26.244Z","comments":true,"path":"2025/05/11/WPF基础学习上/","permalink":"http://example.com/2025/05/11/WPF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%8A/","excerpt":"","text":"BindingPath12341. this.DataContext = new MainViewModel();2. &lt;Window.DataContext&gt; &lt;local:MainViewModel /&gt; &lt;/Window.DataContext&gt; 12345//xaml&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding Path=Message&#125;&quot;/&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding Message&#125;&quot;/&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding Path=.&#125;&quot;/&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding .&#125;&quot;/&gt; 1234567//用程序来写var binding = new Bingding&#123; Path = new PropertyPath(&quot;Message&quot;), Mode BindingMode.TwoWay&#125;;BindingOperations.SetBinding(tbl,TextBlock.TextProperty,bingding); 123456789101112131415&lt;TextBlock&gt; &lt;TextBlock.Text&gt; &lt;MultiBinding&gt; &lt;Binding/&gt; &lt;/MultiBinding&gt; &lt;/TextBlock.Text&gt;&lt;/TextBlock&gt; &lt;TextBlock&gt; &lt;TextBlock.Text&gt; &lt;PriorityBinding&gt; &lt;Binding/&gt; &lt;/PriorityBinding&gt; &lt;/TextBlock.Text&gt;&lt;/TextBlock&gt; Source12345678910&lt;Windows.DataContext&gt; &lt;sys:String x:Key=&quot;str&quot;&gt;Hello,world&lt;/sys:String&gt;&lt;/Windows.DataContext&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding Source=&#123;StaticResource str&#125;&#125;&quot;/&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;DynamicResource str&#125;&quot;/&gt; private void Window_Loaded(object sender,RoutedEventArgs e) &#123; this.Resources[&quot;str&quot;] = &quot;Goodbye&quot;; &#125; 123456class MyResource&#123; public string Message&#123;get;&#125; = &quot;public Property&quot;; public static string StaticString = &quot;Static string&quot;; public const string ConstString = &quot;Const String&quot;;&#125; 12345678&lt;Windows.DataContext&gt; &lt;local:MyResource x:key=&quot;myres&quot; /&gt;&lt;/Windows.DataContext&gt;&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;StaticResource myres,Path=Message&#125;&#125;&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Static local:MyResource.StaticString&#125;&#125;&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Static local:MyResource.ConstString&#125;&#125;&quot;/&gt;//enum&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Static HorizontalAlignment.Stretch&#125;&#125;&quot;/&gt; 12&lt;CollectionViewSource/&gt;&lt;ObjectDataProvider/&gt; ElementName12&lt;TextBox Name=&quot;txt&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding ElementName=txt,Path=text&#125;&quot; /&gt; 绑定失败的例子： 123456&lt;TextBox Name=&quot;txt&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding ElementName=txt,Path=text&#125;&quot; &gt; &lt;TextBlock.ToolTip&gt; &lt;TextBlock Text=&quot;&#123;Binding ElementName=txt,Path=text&#125;&quot;&gt; &lt;/TextBlock.ToolTip&gt;&lt;/TextBlock&gt; 原因scope 123456&lt;TextBox Name=&quot;txt&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding ElementName=txt,Path=text&#125;&quot; &gt; &lt;TextBlock.ToolTip&gt; &lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Reference txt&#125;,Path=text&#125;&quot;&gt; &lt;/TextBlock.ToolTip&gt;&lt;/TextBlock&gt; ModeRelativeSource相对源 FindAncestor 寻找父级 AncestorType 父级类型 AncestorLevel 父级级别 PreviousData Self 自己 TemplateParent 12//当前窗口屏幕上方距离&lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=FindAncestor , Path= Top&#125;&#125;&quot;/&gt; 12345//绑定同级&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;TextBox /&gt; &lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource AncestorType=StackPanel ,Path=Chilren[0].Text&#125;&#125;&quot;/&gt;&lt;/StackPanel&gt; 123456789101112131415//绑定自己&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;TextBox /&gt; &lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Self,Path=ActualWidth&#125;&#125;&quot;/&gt;&lt;/StackPanel&gt;//方法2&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;TextBox /&gt; &lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;x:Static RealativeSource.Self,Path=ActualWidth&#125;&#125;&quot;/&gt;&lt;/StackPanel&gt;//方法3&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;TextBox /&gt; &lt;TextBlock Text=&quot;&#123;Binding RelativeSource 2,Path=ActualWidth&#125;&#125;&quot;/&gt;&lt;/StackPanel&gt; 123456789101112//情况少用&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;Label Padding=&quot;10&quot; Content=&quot;Hello&quot;&gt; &lt;Label.Template&gt; &lt;ControlTemplate TargetType=&quot;Label&quot;&gt; &lt;Border&gt; &lt;ContentPresenter Margin=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplateParent&#125;,Path=Padding,Mode=OneWay&#125;&quot;/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Label.Template&gt; &lt;/Label&gt;&lt;/StackPanel&gt; Misc.(其他)123//浮点数，保留3位小数&lt;TextBlock Text=&quot;&#123;Binding ElementName=window,Path=Top,StringFormat=&#x27;Top:&#123;0:F3&#125;&#x27;&#125;&quot;/&gt;&lt;Label Content=&quot;&#123;Binding ElementName=window,Path=Left,ContentStringFormat=&#x27;Left:&#123;0:F3&#125;&#x27;&#125;&quot;/&gt; 12//TextBox实时更新&lt;TextBox Text=&quot;&#123;Binding ElementName=tb1,Path=Text,UpdateSourceTrigger=PropertyChanged&#125;&quot;/&gt; TargetNullValue 当获取或设置源的值为 null 时将使用TargetNullValue的值。 FallbackValue 当增加了绑定语法时，有时绑定失败了啥都不显示，我们可能需要一些提示语句来提示我们绑定失败，此时就用到了 FallbackValue。 依赖属性（DP） 是类的静态字段 只能存在于DependencyObject上 WPF控件都继承了DependencyObject,且拥有大量DependencyProperty 最终会存放在DP类中的静态HashTable中 实现 属性名 属性类型 对应的类型 初始值 值发生变化时的回调方法 附加属性写在单独的类中（类可以不是DependencyObject） 只有在这个回调方法中可以知道当前的属性被附加在了什么上 语法 常规 123456789101112class CustomTextBox : TextBox&#123; public bool IsHighlighted &#123; get &#123; return (bool)GetValue(IsHighlightedProperty); &#125; set &#123; SetValue(IsHighlightedProperty, value); &#125; &#125; public static readonly DependencyProperty IsHighlightedProperty = DependencyProperty.Register(&quot;IsHighlighted&quot;, typeof(bool), typeof(CustomTextBox), new PropertyMetadata(false)); &#125; 属性修改时的回调 1234567public static readonly DependencyProperty IsHighlightedProperty = DependencyProperty.Register(&quot;IsHighlighted&quot;, typeof(bool), typeof(CustomTextBox), new PropertyMetadata(false,callback));private static void callback(DependencyObject d, DependencyPropertyChangedEventArgs e)&#123; ...&#125; 只读属性 12345678910111213141516/// &lt;summary&gt;/// 只读/// &lt;/summary&gt; public bool HasText =&gt; (bool)GetValue(HasTextProperty);public static readonly DependencyProperty HasTextProperty;public static readonly DependencyPropertyKey HasTextPropertyKey;static CustomTextBox()&#123; HasTextPropertyKey = DependencyProperty.RegisterReadOnly(&quot;HasText&quot;, typeof(bool), typeof(CustomTextBox), new PropertyMetadata(false )); HasTextProperty = HasTextPropertyKey.DependencyProperty;&#125; 附加属性（AP）为什么不选择DP 已有控件的类都是写好的，没有其他办法为他添加DP 有些属性并不专属于某种控件，而是具有通用性 Grid.ROw DockPanel.Dock Canvas.Left AP不必写在DependencyObject上 语法 123&lt;TextBox Grid.Row=&quot;0&quot;&gt; &lt;Grid.Column&gt;1&lt;/Grid.Column&gt;&lt;/TextBox&gt; 123&lt;TextBox ap:TextBoxHelper.Title=&quot;Hello&quot;&gt; &lt;ap:TextBoxHelper.Content&gt;World&lt;/ap:TextBoxHelper.Content&gt;&lt;/TextBox&gt; 控件父类控件的父类们 我们以最常用的Button控件为例。首先看看它的父类们：Button-&gt;ButtonBase-&gt;ContentControl-&gt;Control-&gt;FrameworkElement-&gt;UIElement-&gt;Visual-&gt;DependencyObject-&gt;DispatcherObject。 然后再看一个最常用的StackPanel控件的继承路线：StackPanel-&gt;Panel-&gt;FrameworkElement-&gt;UIElement-&gt;Visual-&gt;DependencyObject-&gt;DispatcherObject。 最后再看一个Rectangle矩形图形的继承路线：Rectangle-&gt;Shape-&gt;FrameworkElement-&gt;UIElement-&gt;Visual-&gt;DependencyObject-&gt;DispatcherObject。 我们会发现它们的继承路线最终都在FrameworkElement这一层汇合，换句话说，这三种控件的身上都流着FrameworkElement的血，那自然也流淌着UIElement-&gt;Visual-&gt;DependencyObject-&gt;DispatcherObject这四个父类的血了。 DispatcherObject DependencyObject Visual UIElement FrameworkElement DispatcherObject类当你们在后台线程中要访问控件时，就可以从控件中找到那位中间商Dispatcher，由中间商来完成你要对控件的操作访问。（调度员） 在开发过程中，难免需要在后台线程中去操作控件，于是Dispatcher调度员提供了Invoke和BeginInvoke两个方法，供我们可以安全的访问UI线程中的控件。 官方解释在 WPF 中， DispatcherObject 只能由 Dispatcher 它与之关联的访问。 例如，后台线程无法更新与 Dispatcher UI 线程上关联的内容Button。 为了使后台线程访问该 Content 属性 Button，后台线程必须将工作委托给 Dispatcher 与 UI 线程关联的工作。 这是通过使用 Invoke 或BeginInvoke。 Invoke 是同步的， BeginInvoke 是异步的。 操作将添加到指定DispatcherPriority位置的队列Dispatcher中。 1234567891011121314151617181920212223namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); Task.Run(() =&gt; &#123; Task.Delay(3000).Wait(); button.Dispatcher.Invoke(() =&gt; &#123; button.Content = &quot;www.wpfsoft.com&quot;; &#125;); &#125;); &#125; &#125;&#125; DependencyObject类在需要的时候主动去改变控件的值的开发模式，我们称为事件驱动模式。 于是微软在WPF框架中推出了更省事的处理方式——数据驱动模式。什么是数据驱动模式？**控件的属性不再被直接赋值，而是绑定了另一个”变量“，当这个”变量“发生改变时，控件的属性也会跟着改变，这样的属性也被称为依赖属性。**这有点像初中数学中的y&#x3D;x这样的函数，y是因变量，x是自变量，y随着x的变化而变化。 提前阅读 DependencyObject 类表示参与依赖属性系统的对象。属性系统的主要功能是计算属性的值，并提供有关已更改的值的系统通知。 参与属性系统的另一个类 DependencyProperty。 DependencyProperty 允许将依赖属性注册到属性系统，并提供有关每个依赖属性的标识和信息，而 DependencyObject 为基类，使对象能够使用此依赖属性。INotifyPropertyChanged 类用于通知UI刷新，注重的仅仅是数据更新后的通知。DependencyObject 类用于给UI添加依赖和附加属性，注重数据与UI的关联。如果简单的数据通知，两者都可以实现的。 我们来看一下DependencyObject类的定义，比较常用的是GetValue和SetValue。GetValue表示获取某一个依赖属性的值，由于不确定这个值是什么类型，所以微软把这个函数的返回值设计成object。SetValue表示设置某一个依赖属竹的值，所有它有两个参数，第一个参数dp表示要设置的依赖属性，第二个参数value表示新值。 1234567891011121314151617181920212223public class DependencyObject : DispatcherObject&#123; public DependencyObject(); public DependencyObjectType DependencyObjectType &#123; get; &#125; public bool IsSealed &#123; get; &#125; public void ClearValue(DependencyProperty dp); public void ClearValue(DependencyPropertyKey key); public void CoerceValue(DependencyProperty dp); public sealed override bool Equals(object obj); public sealed override int GetHashCode(); public LocalValueEnumerator GetLocalValueEnumerator(); public object GetValue(DependencyProperty dp); public void InvalidateProperty(DependencyProperty dp); public object ReadLocalValue(DependencyProperty dp); public void SetCurrentValue(DependencyProperty dp, object value); public void SetValue(DependencyProperty dp, object value); public void SetValue(DependencyPropertyKey key, object value); protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e); protected internal virtual bool ShouldSerializeProperty(DependencyProperty dp); &#125; Visual类Visual类是WPF框架中第三个父类，主要是为 WPF 中的呈现提供支持，其中包括命中测试、坐标转换和边界框计算。它位于程序集:PresentationCore.dll库文件中，它的命名空间:System.Windows.Media。 官方引用 Visual 类是派生每个 FrameworkElement 对象的基本抽象。 该类还用作在 WPF 中编写新控件的入口点，在 Win32 应用程序模型中，该类在许多方面可视为窗口句柄 (HWND)。Visual 对象是一个核心 WPF 对象，它的主要作用是提供呈现支持。 用户界面控件如 Button 和 TextBox）派生自 Visual 类，并使用该类来保存它们的呈现数据。 Visual 对象为以下项提供支持：输出显示：呈现视觉对象的持久、序列化的绘图内容。转换：针对视觉对象执行转换。剪裁：为视觉对象提供剪裁区域支持。命中测试：确定坐标或几何形状是否包含在视觉对象的边界内。边框计算：确定视觉对象的边框。 换句话说，将来我们要学习的Button、TextBox、CheckBox、Gird、ListBox等所有控件都继承了Visual类，控件在绘制到界面的过程中，涉及到转换、裁剪、边框计算等功能，都是使用了Visual父类的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class Visual : DependencyObject, IResource&#123; protected Visual(); protected DependencyObject VisualParent &#123; get; &#125; protected virtual int VisualChildrenCount &#123; get; &#125; protected internal DoubleCollection VisualYSnappingGuidelines &#123; get; protected set; &#125; protected internal Vector VisualOffset &#123; get; protected set; &#125; protected internal Geometry VisualClip &#123; get; protected set; &#125; protected internal Rect? VisualScrollableAreaClip &#123; get; protected set; &#125; protected internal CacheMode VisualCacheMode &#123; get; protected set; &#125; protected internal BitmapEffectInput VisualBitmapEffectInput &#123; get; protected set; &#125; protected internal BitmapEffect VisualBitmapEffect &#123; get; protected set; &#125; protected internal Effect VisualEffect &#123; get; protected set; &#125; protected internal Transform VisualTransform &#123; get; protected set; &#125; protected internal BitmapScalingMode VisualBitmapScalingMode &#123; get; protected set; &#125; protected internal DoubleCollection VisualXSnappingGuidelines &#123; get; protected set; &#125; protected internal double VisualOpacity &#123; get; protected set; &#125; protected internal EdgeMode VisualEdgeMode &#123; get; protected set; &#125; protected internal ClearTypeHint VisualClearTypeHint &#123; get; set; &#125; protected internal TextRenderingMode VisualTextRenderingMode &#123; get; set; &#125; protected internal TextHintingMode VisualTextHintingMode &#123; get; set; &#125; protected internal Brush VisualOpacityMask &#123; get; protected set; &#125; public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual); public bool IsAncestorOf(DependencyObject descendant); public bool IsDescendantOf(DependencyObject ancestor); public Point PointFromScreen(Point point); public Point PointToScreen(Point point); public GeneralTransform2DTo3D TransformToAncestor(Visual3D ancestor); public GeneralTransform TransformToAncestor(Visual ancestor); public GeneralTransform TransformToDescendant(Visual descendant); public GeneralTransform TransformToVisual(Visual visual); protected void AddVisualChild(Visual child); protected virtual Visual GetVisualChild(int index); protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters); protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters); protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi); protected void RemoveVisualChild(Visual child); protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved); protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);&#125; 代码分析 首先，我们可以看到，Visual类继承了DependencyObject类。另外Visual类是一个抽象类，不可以被实例。Visual类提供了一系列的属性和方法。我们在这里捡一些比较重要的分析一下。 VisualParent属性：这个属性表示获取一个可视化父对象。因为XAML的代码结构就是一棵xml树，每个控件都对象几乎都有一个可视化父对象。 VisualChildrenCount属性：获取当前对象的子元素数量。 VisualOffset属性：指当前可视对象的偏移量值。需要注意的是这个属性被声明成protected internal。啥意思呢？VisualOffset属性只能由同一个程序集的其它类访问，或Visual的子类访问。 protected internal protected internal 关键字组合是一种成员访问修饰符， 表示受保护的内部成员。 VisualOpacity属性：获取或设置 Visual 的不透明度。 VisualEffect属性：获取或设置要应用于 Visual 的位图效果。 VisualTransform属性：获取或设置 Transform 的 Visual 值。 这些属性都只读为了解Visual类的基础，因为这些属性都被设计成protected internal，我们的控件虽然继承了这个Visual类，但在实际的使用过程中是感知不到这些属性的，自然也不能实操它们。 我们真正能在继承的控件中直接使用的是Visual类中被声明为public的方法成员。它们有以下几个： DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual); &#x2F;&#x2F;返回两个可视对象的公共上级。 bool IsAncestorOf(DependencyObject descendant); &#x2F;&#x2F;确定可视对象是否为后代可视对象的上级。 bool IsDescendantOf(DependencyObject ancestor); &#x2F;&#x2F;确定可视对象是否为上级可视对象的后代。 Point PointFromScreen(Point point); &#x2F;&#x2F;将屏幕坐标中的 Point 转换为表示 Point 的当前坐标系的 Visual。 Point PointToScreen(Point point); &#x2F;&#x2F;将表示 Point 的当前坐标系的 Visual 转换为屏幕坐标中的 Point。 GeneralTransform2DTo3D TransformToAncestor(Visual3D ancestor); &#x2F;&#x2F;返回一个转换，该转换可用于将 Visual 中的坐标转换为可视对象的指定 Visual3D 上级。 GeneralTransform TransformToAncestor(Visual ancestor); &#x2F;&#x2F;返回一个转换，该转换可用于将 Visual 中的坐标转换为可视对象的指定 Visual 上级。 GeneralTransform TransformToDescendant(Visual descendant); &#x2F;&#x2F;返回一个转换，该转换可用于将 Visual 中的坐标转换为指定的可视对象后代。 GeneralTransform TransformToVisual(Visual visual); &#x2F;&#x2F;返回一个转换，该转换可用于将 Visual 中的坐标转换为指定的可视对象。 由此可见，Visual类所做的事情只为控件呈现相关，但还不是去呈现控件，只是提供呈现的基础。那么，谁又去继承了Visual类，成为继Visual类之后又一个控件的基类呢？答案是UIElement类。 UIElement类UIElement类继承了Visual类，在WPF框架中排行老四（第4个基类）。它位于程序集:PresentationCore.dll之中，命名空间:System.Windows。 这个基类非常非常重要，理解了这个类，就理解了WPF所有控件1&#x2F;3的知识与用法。我们先来看一下它的全貌。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404public class UIElement : Visual, IAnimatable, IInputElement&#123;public static readonly RoutedEvent PreviewMouseDownEvent;public static readonly DependencyProperty AreAnyTouchesOverProperty;public static readonly DependencyProperty AreAnyTouchesDirectlyOverProperty;public static readonly DependencyProperty IsKeyboardFocusedProperty;public static readonly DependencyProperty IsStylusCaptureWithinProperty;public static readonly DependencyProperty IsStylusCapturedProperty;public static readonly DependencyProperty IsMouseCaptureWithinProperty;public static readonly DependencyProperty IsMouseCapturedProperty;public static readonly DependencyProperty IsKeyboardFocusWithinProperty;public static readonly DependencyProperty IsStylusOverProperty;public static readonly DependencyProperty IsMouseOverProperty;public static readonly DependencyProperty IsMouseDirectlyOverProperty;public static readonly RoutedEvent TouchLeaveEvent;public static readonly RoutedEvent TouchEnterEvent;public static readonly RoutedEvent LostTouchCaptureEvent;public static readonly RoutedEvent GotTouchCaptureEvent;public static readonly RoutedEvent TouchUpEvent;public static readonly RoutedEvent PreviewTouchUpEvent;public static readonly RoutedEvent TouchMoveEvent;public static readonly RoutedEvent PreviewTouchMoveEvent;public static readonly RoutedEvent TouchDownEvent;public static readonly RoutedEvent PreviewTouchDownEvent;public static readonly RoutedEvent DropEvent;public static readonly RoutedEvent PreviewDropEvent;public static readonly RoutedEvent DragLeaveEvent;public static readonly RoutedEvent PreviewDragLeaveEvent;public static readonly DependencyProperty AreAnyTouchesCapturedProperty;public static readonly DependencyProperty AreAnyTouchesCapturedWithinProperty;public static readonly DependencyProperty AllowDropProperty;public static readonly DependencyProperty RenderTransformProperty;public static readonly RoutedEvent ManipulationCompletedEvent;public static readonly RoutedEvent ManipulationBoundaryFeedbackEvent;public static readonly RoutedEvent ManipulationInertiaStartingEvent;public static readonly RoutedEvent ManipulationDeltaEvent;public static readonly RoutedEvent ManipulationStartedEvent;public static readonly RoutedEvent ManipulationStartingEvent;public static readonly DependencyProperty IsManipulationEnabledProperty;public static readonly DependencyProperty FocusableProperty;public static readonly DependencyProperty IsVisibleProperty;public static readonly DependencyProperty IsHitTestVisibleProperty;public static readonly DependencyProperty IsEnabledProperty;public static readonly DependencyProperty IsFocusedProperty;public static readonly RoutedEvent DragOverEvent;public static readonly RoutedEvent LostFocusEvent;public static readonly DependencyProperty SnapsToDevicePixelsProperty;public static readonly DependencyProperty ClipProperty;public static readonly DependencyProperty ClipToBoundsProperty;public static readonly DependencyProperty VisibilityProperty;public static readonly DependencyProperty UidProperty;public static readonly DependencyProperty CacheModeProperty;public static readonly DependencyProperty BitmapEffectInputProperty;public static readonly DependencyProperty EffectProperty;public static readonly DependencyProperty BitmapEffectProperty;public static readonly DependencyProperty OpacityMaskProperty;public static readonly DependencyProperty OpacityProperty;public static readonly DependencyProperty RenderTransformOriginProperty;public static readonly RoutedEvent GotFocusEvent;public static readonly RoutedEvent PreviewDragOverEvent;public static readonly DependencyProperty IsStylusDirectlyOverProperty;public static readonly RoutedEvent PreviewDragEnterEvent;public static readonly RoutedEvent StylusMoveEvent;public static readonly RoutedEvent PreviewStylusMoveEvent;public static readonly RoutedEvent StylusUpEvent;public static readonly RoutedEvent PreviewStylusUpEvent;public static readonly RoutedEvent StylusDownEvent;public static readonly RoutedEvent PreviewStylusDownEvent;public static readonly RoutedEvent QueryCursorEvent;public static readonly RoutedEvent LostMouseCaptureEvent;public static readonly RoutedEvent GotMouseCaptureEvent;public static readonly RoutedEvent MouseLeaveEvent;public static readonly RoutedEvent MouseEnterEvent;public static readonly RoutedEvent MouseWheelEvent;public static readonly RoutedEvent PreviewStylusInAirMoveEvent;public static readonly RoutedEvent PreviewMouseWheelEvent;public static readonly RoutedEvent PreviewMouseMoveEvent;public static readonly RoutedEvent MouseRightButtonUpEvent;public static readonly RoutedEvent PreviewMouseRightButtonUpEvent;public static readonly RoutedEvent MouseRightButtonDownEvent;public static readonly RoutedEvent PreviewMouseRightButtonDownEvent;public static readonly RoutedEvent DragEnterEvent;public static readonly RoutedEvent PreviewMouseLeftButtonUpEvent;public static readonly RoutedEvent MouseLeftButtonDownEvent;public static readonly RoutedEvent PreviewMouseLeftButtonDownEvent;public static readonly RoutedEvent MouseUpEvent;public static readonly RoutedEvent PreviewMouseUpEvent;public static readonly RoutedEvent MouseDownEvent;public static readonly RoutedEvent MouseMoveEvent;public static readonly RoutedEvent StylusInAirMoveEvent;public static readonly RoutedEvent MouseLeftButtonUpEvent;public static readonly RoutedEvent StylusLeaveEvent;public static readonly RoutedEvent StylusEnterEvent;public static readonly RoutedEvent GiveFeedbackEvent;public static readonly RoutedEvent PreviewGiveFeedbackEvent;public static readonly RoutedEvent QueryContinueDragEvent;public static readonly RoutedEvent TextInputEvent;public static readonly RoutedEvent PreviewTextInputEvent;public static readonly RoutedEvent LostKeyboardFocusEvent;public static readonly RoutedEvent PreviewLostKeyboardFocusEvent;public static readonly RoutedEvent GotKeyboardFocusEvent;public static readonly RoutedEvent PreviewGotKeyboardFocusEvent;public static readonly RoutedEvent KeyUpEvent;public static readonly RoutedEvent PreviewKeyUpEvent;public static readonly RoutedEvent KeyDownEvent;public static readonly RoutedEvent PreviewQueryContinueDragEvent;public static readonly RoutedEvent PreviewStylusButtonUpEvent;public static readonly RoutedEvent PreviewKeyDownEvent;public static readonly RoutedEvent StylusInRangeEvent;public static readonly RoutedEvent PreviewStylusInRangeEvent;public static readonly RoutedEvent StylusOutOfRangeEvent;public static readonly RoutedEvent PreviewStylusSystemGestureEvent;public static readonly RoutedEvent PreviewStylusOutOfRangeEvent;public static readonly RoutedEvent GotStylusCaptureEvent;public static readonly RoutedEvent LostStylusCaptureEvent;public static readonly RoutedEvent StylusButtonDownEvent;public static readonly RoutedEvent StylusButtonUpEvent;public static readonly RoutedEvent PreviewStylusButtonDownEvent;public static readonly RoutedEvent StylusSystemGestureEvent; public UIElement(); public string Uid &#123; get; set; &#125;public Visibility Visibility &#123; get; set; &#125;public bool ClipToBounds &#123; get; set; &#125;public Geometry Clip &#123; get; set; &#125;public bool SnapsToDevicePixels &#123; get; set; &#125;public bool IsFocused &#123; get; &#125;public bool IsEnabled &#123; get; set; &#125;public bool IsHitTestVisible &#123; get; set; &#125;public bool IsVisible &#123; get; &#125;public bool AreAnyTouchesCapturedWithin &#123; get; &#125;public int PersistId &#123; get; &#125;public bool IsManipulationEnabled &#123; get; set; &#125;public bool AreAnyTouchesOver &#123; get; &#125;public bool AreAnyTouchesDirectlyOver &#123; get; &#125;public bool AreAnyTouchesCaptured &#123; get; &#125;public IEnumerable&lt;TouchDevice&gt; TouchesCaptured &#123; get; &#125;public IEnumerable&lt;TouchDevice&gt; TouchesCapturedWithin &#123; get; &#125;public IEnumerable&lt;TouchDevice&gt; TouchesOver &#123; get; &#125;public CacheMode CacheMode &#123; get; set; &#125;public bool Focusable &#123; get; set; &#125;public BitmapEffectInput BitmapEffectInput &#123; get; set; &#125;public bool IsMouseDirectlyOver &#123; get; &#125;public BitmapEffect BitmapEffect &#123; get; set; &#125;public Size RenderSize &#123; get; set; &#125;public bool IsArrangeValid &#123; get; &#125;public bool IsMeasureValid &#123; get; &#125;public Size DesiredSize &#123; get; &#125;public bool AllowDrop &#123; get; set; &#125;public CommandBindingCollection CommandBindings &#123; get; &#125;public InputBindingCollection InputBindings &#123; get; &#125;public bool HasAnimatedProperties &#123; get; &#125;public bool IsMouseOver &#123; get; &#125;public Effect Effect &#123; get; set; &#125;public bool IsStylusOver &#123; get; &#125;public bool IsMouseCaptured &#123; get; &#125;public bool IsMouseCaptureWithin &#123; get; &#125;public bool IsStylusDirectlyOver &#123; get; &#125;public bool IsStylusCaptured &#123; get; &#125;public bool IsStylusCaptureWithin &#123; get; &#125;public bool IsKeyboardFocused &#123; get; &#125;public bool IsInputMethodEnabled &#123; get; &#125;public double Opacity &#123; get; set; &#125;public Brush OpacityMask &#123; get; set; &#125;public bool IsKeyboardFocusWithin &#123; get; &#125;public IEnumerable&lt;TouchDevice&gt; TouchesDirectlyOver &#123; get; &#125;public Point RenderTransformOrigin &#123; get; set; &#125;public Transform RenderTransform &#123; get; set; &#125;protected StylusPlugInCollection StylusPlugIns &#123; get; &#125;protected virtual bool IsEnabledCore &#123; get; &#125;protected internal virtual bool HasEffectiveKeyboardFocus &#123; get; &#125; public event KeyEventHandler KeyUp;public event EventHandler&lt;TouchEventArgs&gt; TouchMove;public event EventHandler&lt;TouchEventArgs&gt; PreviewTouchMove;public event EventHandler&lt;TouchEventArgs&gt; TouchDown;public event EventHandler&lt;TouchEventArgs&gt; PreviewTouchDown;public event DragEventHandler Drop;public event DragEventHandler PreviewDrop;public event DragEventHandler DragLeave;public event DragEventHandler PreviewDragLeave;public event DragEventHandler DragOver;public event DragEventHandler PreviewDragOver;public event DragEventHandler DragEnter;public event DragEventHandler PreviewDragEnter;public event GiveFeedbackEventHandler GiveFeedback;public event GiveFeedbackEventHandler PreviewGiveFeedback;public event QueryContinueDragEventHandler QueryContinueDrag;public event QueryContinueDragEventHandler PreviewQueryContinueDrag;public event TextCompositionEventHandler TextInput;public event EventHandler&lt;TouchEventArgs&gt; PreviewTouchUp;public event EventHandler&lt;TouchEventArgs&gt; TouchUp;public event EventHandler&lt;TouchEventArgs&gt; LostTouchCapture;public event TextCompositionEventHandler PreviewTextInput;public event EventHandler&lt;ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting;public event EventHandler&lt;ManipulationDeltaEventArgs&gt; ManipulationDelta;public event EventHandler&lt;ManipulationStartedEventArgs&gt; ManipulationStarted;public event EventHandler&lt;ManipulationStartingEventArgs&gt; ManipulationStarting;public event DependencyPropertyChangedEventHandler FocusableChanged;public event DependencyPropertyChangedEventHandler IsVisibleChanged;public event DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;public event DependencyPropertyChangedEventHandler IsEnabledChanged;public event RoutedEventHandler LostFocus;public event EventHandler&lt;TouchEventArgs&gt; GotTouchCapture;public event RoutedEventHandler GotFocus;public event DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;public event DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;public event DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;public event DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;public event DependencyPropertyChangedEventHandler IsMouseCapturedChanged;public event DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;public event DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;public event EventHandler&lt;TouchEventArgs&gt; TouchLeave;public event EventHandler&lt;TouchEventArgs&gt; TouchEnter;public event EventHandler LayoutUpdated;public event KeyboardFocusChangedEventHandler LostKeyboardFocus;public event KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;public event KeyboardFocusChangedEventHandler GotKeyboardFocus;public event StylusEventHandler PreviewStylusMove;public event StylusEventHandler StylusMove;public event StylusEventHandler PreviewStylusInAirMove;public event StylusEventHandler StylusInAirMove;public event StylusEventHandler StylusEnter;public event StylusEventHandler StylusLeave;public event StylusEventHandler PreviewStylusInRange;public event StylusEventHandler StylusInRange;public event StylusEventHandler PreviewStylusOutOfRange;public event StylusEventHandler StylusOutOfRange;public event StylusSystemGestureEventHandler PreviewStylusSystemGesture;public event StylusSystemGestureEventHandler StylusSystemGesture;public event StylusEventHandler GotStylusCapture;public event StylusEventHandler LostStylusCapture;public event StylusButtonEventHandler StylusButtonDown;public event StylusButtonEventHandler StylusButtonUp;public event StylusButtonEventHandler PreviewStylusButtonDown;public event StylusButtonEventHandler PreviewStylusButtonUp;public event KeyEventHandler PreviewKeyDown;public event KeyEventHandler KeyDown;public event KeyEventHandler PreviewKeyUp;public event StylusEventHandler StylusUp;public event KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;public event StylusEventHandler PreviewStylusUp;public event StylusDownEventHandler PreviewStylusDown;public event MouseButtonEventHandler PreviewMouseDown;public event MouseButtonEventHandler MouseDown;public event MouseButtonEventHandler PreviewMouseUp;public event MouseButtonEventHandler MouseUp;public event MouseButtonEventHandler PreviewMouseLeftButtonDown;public event MouseButtonEventHandler MouseLeftButtonDown;public event MouseButtonEventHandler PreviewMouseLeftButtonUp;public event MouseButtonEventHandler MouseLeftButtonUp;public event MouseButtonEventHandler PreviewMouseRightButtonDown;public event MouseButtonEventHandler MouseRightButtonDown;public event MouseButtonEventHandler PreviewMouseRightButtonUp;public event MouseButtonEventHandler MouseRightButtonUp;public event MouseEventHandler PreviewMouseMove;public event MouseEventHandler MouseMove;public event MouseWheelEventHandler PreviewMouseWheel;public event MouseWheelEventHandler MouseWheel;public event MouseEventHandler MouseEnter;public event MouseEventHandler MouseLeave;public event MouseEventHandler GotMouseCapture;public event MouseEventHandler LostMouseCapture;public event QueryCursorEventHandler QueryCursor;public event StylusDownEventHandler StylusDown;public event DependencyPropertyChangedEventHandler IsStylusCapturedChanged;public event EventHandler&lt;ManipulationCompletedEventArgs&gt; ManipulationCompleted;public event EventHandler&lt;ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback; public void AddHandler(RoutedEvent routedEvent, Delegate handler);public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);public void AddToEventRoute(EventRoute route, RoutedEventArgs e);public void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);public void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);public void Arrange(Rect finalRect);public void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);public void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);public bool CaptureMouse();public bool CaptureStylus();public bool CaptureTouch(TouchDevice touchDevice);public bool Focus();public object GetAnimationBaseValue(DependencyProperty dp);public IInputElement InputHitTest(Point point);public void InvalidateArrange();public void InvalidateMeasure();public void InvalidateVisual();public void Measure(Size availableSize);public virtual bool MoveFocus(TraversalRequest request);public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);public void RaiseEvent(RoutedEventArgs e);public void ReleaseAllTouchCaptures();public void ReleaseMouseCapture();public void ReleaseStylusCapture();public bool ReleaseTouchCapture(TouchDevice touchDevice);public void RemoveHandler(RoutedEvent routedEvent, Delegate handler);public bool ShouldSerializeCommandBindings();public bool ShouldSerializeInputBindings();public Point TranslatePoint(Point point, UIElement relativeTo);public void UpdateLayout();protected virtual void ArrangeCore(Rect finalRect);protected virtual Geometry GetLayoutClip(Size layoutSlotSize);protected override HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);protected override GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);protected virtual Size MeasureCore(Size availableSize);protected virtual void OnAccessKey(AccessKeyEventArgs e);protected virtual void OnChildDesiredSizeChanged(UIElement child);protected virtual AutomationPeer OnCreateAutomationPeer();protected virtual void OnDragEnter(DragEventArgs e);protected virtual void OnDragLeave(DragEventArgs e);protected virtual void OnDragOver(DragEventArgs e);protected virtual void OnDrop(DragEventArgs e);protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);protected virtual void OnGotFocus(RoutedEventArgs e);protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);protected virtual void OnGotMouseCapture(MouseEventArgs e);protected virtual void OnGotStylusCapture(StylusEventArgs e);protected virtual void OnGotTouchCapture(TouchEventArgs e);protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnKeyDown(KeyEventArgs e);protected virtual void OnKeyUp(KeyEventArgs e);protected virtual void OnLostFocus(RoutedEventArgs e);protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);protected virtual void OnLostMouseCapture(MouseEventArgs e);protected virtual void OnLostStylusCapture(StylusEventArgs e);protected virtual void OnLostTouchCapture(TouchEventArgs e);protected virtual void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e);protected virtual void OnManipulationCompleted(ManipulationCompletedEventArgs e);protected virtual void OnManipulationDelta(ManipulationDeltaEventArgs e);protected virtual void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e);protected virtual void OnManipulationStarted(ManipulationStartedEventArgs e);protected virtual void OnManipulationStarting(ManipulationStartingEventArgs e);protected virtual void OnMouseDown(MouseButtonEventArgs e);protected virtual void OnMouseEnter(MouseEventArgs e);protected virtual void OnMouseLeave(MouseEventArgs e);protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);protected virtual void OnMouseMove(MouseEventArgs e);protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);protected virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);protected virtual void OnMouseUp(MouseButtonEventArgs e);protected virtual void OnMouseWheel(MouseWheelEventArgs e);protected virtual void OnPreviewDragEnter(DragEventArgs e);protected virtual void OnPreviewDragLeave(DragEventArgs e);protected virtual void OnPreviewDragOver(DragEventArgs e);protected virtual void OnPreviewDrop(DragEventArgs e);protected virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);protected virtual void OnPreviewKeyDown(KeyEventArgs e);protected virtual void OnPreviewKeyUp(KeyEventArgs e);protected virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);protected virtual void OnPreviewMouseDown(MouseButtonEventArgs e);protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);protected virtual void OnPreviewMouseMove(MouseEventArgs e);protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);protected virtual void OnPreviewMouseUp(MouseButtonEventArgs e);protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);protected virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);protected virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);protected virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);protected virtual void OnPreviewStylusDown(StylusDownEventArgs e);protected virtual void OnPreviewStylusInAirMove(StylusEventArgs e);protected virtual void OnPreviewStylusInRange(StylusEventArgs e);protected virtual void OnPreviewStylusMove(StylusEventArgs e);protected virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);protected virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);protected virtual void OnPreviewStylusUp(StylusEventArgs e);protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);protected virtual void OnPreviewTouchDown(TouchEventArgs e);protected virtual void OnPreviewTouchMove(TouchEventArgs e);protected virtual void OnPreviewTouchUp(TouchEventArgs e);protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);protected virtual void OnQueryCursor(QueryCursorEventArgs e);protected virtual void OnRender(DrawingContext drawingContext);protected virtual void OnStylusButtonDown(StylusButtonEventArgs e);protected virtual void OnStylusButtonUp(StylusButtonEventArgs e);protected virtual void OnStylusDown(StylusDownEventArgs e);protected virtual void OnStylusEnter(StylusEventArgs e);protected virtual void OnStylusInAirMove(StylusEventArgs e);protected virtual void OnStylusInRange(StylusEventArgs e);protected virtual void OnStylusLeave(StylusEventArgs e);protected virtual void OnStylusMove(StylusEventArgs e);protected virtual void OnStylusOutOfRange(StylusEventArgs e);protected virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);protected virtual void OnStylusUp(StylusEventArgs e);protected virtual void OnTextInput(TextCompositionEventArgs e);protected virtual void OnTouchDown(TouchEventArgs e);protected virtual void OnTouchEnter(TouchEventArgs e);protected virtual void OnTouchLeave(TouchEventArgs e);protected virtual void OnTouchMove(TouchEventArgs e);protected virtual void OnTouchUp(TouchEventArgs e);protected internal virtual DependencyObject GetUIParentCore();protected internal virtual void OnRenderSizeChanged(SizeChangedInfo info);protected internal override void OnVisualParentChanged(DependencyObject oldParent);&#125; UIElement类代码分析 第一部分 路由事件 UIElement基类定义了大量的路由事件。什么是路由事件？路由事件和xaml的可视化树概念相关，控件的事件被触发后，会沿着这棵树广播，有两个方向，要么往树的根部广播，要么往树的枝叶广播，如果不广播就是直接事件。 所以，路由事件分为冒泡事件和隧道事件，冒泡，是从触发源为出发点，依次传递到父节点，直到最后的根节点。隧道事件是不管谁是触发源，都是从根节点触发，到子节点，直到触发节点。 从空间上来说，冒泡事件和隧道事件是成对出现的。从时间来说，都是先触发隧道事件，然后是冒泡事件。从命名来说，隧道事件都是以Preview开头的事件。 根据命名规则，我们可以大致猜测出一个结果，带Key的基本都是与键盘相关的事件（如按下键位、抬起键位），带Mouse的基本都是与鼠标相关的事件（如左键单击、双击），带Stylus的基本都是与触摸相关的事件，具体用到哪一类型的事件，再详细查阅一下相关说明文档即可。 重点：关于这些事件的回调函数，即以On开头的方法成员，都被声明成了protected virtual，意思是他们都可以被重载，这使得我们在开发业务时更加方便。 第二部分 依赖属性 UIElement基类还定义了大量的依赖属性。前面的章节中，在DependencyObject类中我们简单提到过依赖属性。在这里我们以UIElement基类的Visibility属性为例。 123public Visibility Visibility &#123; get; set; &#125; public static readonly DependencyProperty VisibilityProperty; 上面有两个成员，Visibility是普通的属性成员，VisibilityProperty是WPF的依赖属性成员，以Property结尾的字样作为WPF的依赖属性命名规则。而这两个成员合起来，才能被称为一个完整的依赖属性。这个Visibility 属性表示设置或获取控件的可见性。当我们要设置控件的可见性时，只需要如下设置即可。 12345&lt;TextBlock Text=&quot;WPF中文网&quot; Visibility=&quot;Visible&quot; FontSize=&quot;48&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; Visibility实际上是一个枚举，它包含3个值，分别是Visible、Hidden、Collapsed。其含义分别是显示、隐藏、彻底隐藏（不占布局位置）。 Visibility 状态会影响该元素的所有输入处理。 不可见的元素不会参与命中测试，也不会接收输入事件，即使鼠标位于元素可见时所在的边界上也是如此。 但是在这一节中，我们只是探讨UIElement基类提供了哪些方面的属性，并不详细探讨依赖属性，所以下面我们把目光聚焦到UIElement基类的常用属性上。另外由于WPF中几乎所有控件都继承了这个基类，意思就是说所有的控件都有这些属性可以使用。下面我在描述的时候将采用“控件”两字来解释一些技术细节。 Uid属性:获取或设置控件的唯一标识符，像人们的身份证一样。这个值默认是string.Empty。 Visibility属性：获取或设置控件的可见性。默认是Visible。 ClipToBounds属性：如果该值为true，表示进行裁剪，以适配它的父控件。比如有时候我们外面有一个Panel，里面的控件尺寸太大，势必会“撑破”外面的父控件，为了布局美观，只好削足适履。 Clip属性：用于剪裁区域大小的几何图形。需要注意的是，这个属性和上面的ClipToBounds属性是有区别的。ClipToBounds是裁剪控件自身，Clip是裁剪控件里面的内容。比如Image图像控件，我们在显示一张图时，就可以运用Clip进行裁剪后显示，通常在显示用户头像时裁剪成圆形时使用。如下所示 12345678910&lt;Image Source=&quot;sampleImages\\Waterlilies.jpg&quot; Width=&quot;200&quot; Height=&quot;150&quot; HorizontalAlignment=&quot;Left&quot;&gt; &lt;Image.Clip&gt; &lt;EllipseGeometry RadiusX=&quot;100&quot; RadiusY=&quot;75&quot; Center=&quot;100,75&quot;/&gt; &lt;/Image.Clip&gt;&lt;/Image&gt; SnapsToDevicePixels属性：如果该值为true，表示控件的呈现是否应使用特定于设备的像素设置。意思是开启后可以最大限度的防锯齿效果，默认为false。 IsFocused属性：这是一个只读属性，表示当前控件是否有焦点。 IsEnabled属性：如果该值为true，表示禁用控件，反之启用控件。 IsHitTestVisible属性：获取或设置一个值，该值声明是否可以返回此元素作为其呈现内容的某些部分的点击测试结果。 IsVisible属性：这是一个只读属性，表示当前控件是否显示。 Focusable属性：如果该值为true，表示控件可以得到焦点，大部份内容控件都默认可以获得焦点。 IsKeyboardFocused属性：表示该控件是否具有键盘焦点。 IsMouseOver属性：表示鼠标是否在控件上面。通常在设计控件的样式（Style）时会用到。 IsStylusOver属性：表示触笔指针是否在控件的上方。 IsSealed属性：表示当前类型是否为只读类。 Opacity属性：设置控件的透明度，取值范围是0-1之间的double值。 OpacityMask属性：设置一个画笔，作为控件的蒙板。比如我们给一张图片设置一个掩码，就可以使用ImageBrush这种图片画笔来实现。 12345&lt;Image Height=&quot;150&quot; Width=&quot;200&quot; Source=&quot;sampleImages/Waterlilies.jpg&quot; &gt; &lt;Image.OpacityMask&gt; &lt;ImageBrush ImageSource=&quot;sampleImages/tornedges.png&quot;/&gt; &lt;/Image.OpacityMask&gt;&lt;/Image&gt; AllowDrop属性：表示控件是否允许拖拽操作。 RenderTransform属性：（非常重要）如果要设置控件的移动、缩放、旋转，需要这此属性进行设置。 UIElement类总结 通过上述的代码分析，我们大致可以得出以下结论，UIElement基类为我们提供了一系列的鼠标、键盘和触摸事件，并提供了一些常用的依赖属性。它可以呈现继承它的所有控件，为控件布局时调整位置和大小，响应用户的输入，引发一系列的路由事件，并继承了IAnimatable动画接口，用于支持动画的某些方面。 我们熟悉了UIElement的这些属性和事件之后，实际上意味着我们也熟悉了WPF所有控件的这些属性。下一节，我们将探讨UIElement的子类FrameworkElement。 FrameworkElement基类论重要性，完全不亚于UIElement基类。甚至论起与开发者的“亲密度”，FrameworkElement更像是近水的楼台。 FrameworkElement类FrameworkElement类继承于UIElement类，继承关系是：Object-&gt;DispatcherObject-&gt;DependencyObject-&gt;Visual-&gt;UIElement-&gt;FrameworkElement，它也是WPF控件的众多父类中最核心的基类，从这里开始，继承树开始分支，分别是Shape图形类、Control控件类和Panel布局类三个方向。 FrameworkElement类本质上也是提供了一系列属性、方法和事件。同时又扩展 UIElement 并添加了以下功能： 官方文档 1.布局系统定义： FrameworkElement 为中 UIElement定义为虚拟成员的某些方法提供特定的 WPF 框架级实现。 最值得注意的是， FrameworkElement 会密封某些 WPF 核心级布局替代，并改为提供派生类应替代的 WPF 框架级别的等效项。 例如，密封但 FrameworkElementArrangeCore 提供 ArrangeOverride。 这些更改反映了这样一个事实，即在 WPF 框架级别，有一个可以呈现任何 FrameworkElement 派生类的完整布局系统。 在 WPF 核心级别，将构建基于 WPF 的常规布局解决方案的某些成员已就位，但未定义布局系统的实际引擎。2.逻辑树： 常规 WPF 编程模型通常以元素树的方式表示。 支持将元素树表示为逻辑树，以及支持在标记中定义该树的支持是在 级别实现的 FrameworkElement 。 但请注意， FrameworkElement 故意不定义内容模型，并将该责任留给派生类。3.对象生存期事件： 了解何时初始化元素 (调用构造函数) 或首次将元素加载到逻辑树中时，这通常很有用。 FrameworkElement 定义多个与对象生存期相关的事件，这些事件为涉及元素的代码隐藏操作（例如添加更多子元素）提供有用的挂钩。4.支持数据绑定和动态资源引用： 对数据绑定和资源的属性级支持由 DependencyProperty 类实现，并体现在属性系统中，但解析存储为 Expression (数据绑定和动态资源的编程构造) 中存储的成员值的能力由 FrameworkElement实现。5.风格：FrameworkElement 定义 Style 属性。 但是， FrameworkElement 尚未定义对模板的支持或支持修饰器。 这些功能由控件类（如 和 ContentControl）Control引入。6.更多动画支持： 某些动画支持已在 WPF 核心级别定义，但 FrameworkElement 通过实现 BeginStoryboard 和相关成员扩展了此支持。 我们来看看这个基类的结构定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class FrameworkElement : UIElement, IFrameworkInputElement, IInputElement, ISupportInitialize, IHaveResources, IQueryAmbient&#123; public static readonly DependencyProperty StyleProperty; public static readonly DependencyProperty MaxHeightProperty; public static readonly DependencyProperty FlowDirectionProperty; public static readonly DependencyProperty MarginProperty; public static readonly DependencyProperty HorizontalAlignmentProperty; public static readonly DependencyProperty VerticalAlignmentProperty; public static readonly DependencyProperty FocusVisualStyleProperty; public static readonly DependencyProperty CursorProperty; public static readonly DependencyProperty ForceCursorProperty; public static readonly RoutedEvent UnloadedEvent; public static readonly DependencyProperty ToolTipProperty; public static readonly DependencyProperty ContextMenuProperty; public static readonly RoutedEvent ToolTipOpeningEvent; public static readonly RoutedEvent ToolTipClosingEvent; public static readonly RoutedEvent ContextMenuOpeningEvent; public static readonly RoutedEvent ContextMenuClosingEvent; public static readonly DependencyProperty MinHeightProperty; public static readonly DependencyProperty HeightProperty; public static readonly RoutedEvent LoadedEvent; public static readonly DependencyProperty MinWidthProperty; public static readonly DependencyProperty MaxWidthProperty; public static readonly DependencyProperty OverridesDefaultStyleProperty; public static readonly DependencyProperty UseLayoutRoundingProperty; public static readonly DependencyProperty BindingGroupProperty; public static readonly DependencyProperty LanguageProperty; public static readonly DependencyProperty NameProperty; public static readonly DependencyProperty TagProperty; public static readonly DependencyProperty DataContextProperty; public static readonly RoutedEvent RequestBringIntoViewEvent; public static readonly RoutedEvent SizeChangedEvent; public static readonly DependencyProperty ActualWidthProperty; public static readonly DependencyProperty ActualHeightProperty; public static readonly DependencyProperty LayoutTransformProperty; public static readonly DependencyProperty InputScopeProperty; public static readonly DependencyProperty WidthProperty; protected internal static readonly DependencyProperty DefaultStyleKeyProperty; public FrameworkElement(); public Transform LayoutTransform &#123; get; set; &#125; public double Width &#123; get; set; &#125; public double MinWidth &#123; get; set; &#125; public double MaxHeight &#123; get; set; &#125; public double Height &#123; get; set; &#125; public double MinHeight &#123; get; set; &#125; public double ActualHeight &#123; get; &#125; public double MaxWidth &#123; get; set; &#125; public double ActualWidth &#123; get; &#125; public TriggerCollection Triggers &#123; get; &#125; public object Tag &#123; get; set; &#125; public string Name &#123; get; set; &#125; public XmlLanguage Language &#123; get; set; &#125; public BindingGroup BindingGroup &#123; get; set; &#125; public object DataContext &#123; get; set; &#125; public ResourceDictionary Resources &#123; get; set; &#125; public DependencyObject TemplatedParent &#123; get; &#125; public bool UseLayoutRounding &#123; get; set; &#125; public FlowDirection FlowDirection &#123; get; set; &#125; public InputScope InputScope &#123; get; set; &#125; public Thickness Margin &#123; get; set; &#125; public Style Style &#123; get; set; &#125; public VerticalAlignment VerticalAlignment &#123; get; set; &#125; public bool OverridesDefaultStyle &#123; get; set; &#125; public HorizontalAlignment HorizontalAlignment &#123; get; set; &#125; public ContextMenu ContextMenu &#123; get; set; &#125; public object ToolTip &#123; get; set; &#125; public DependencyObject Parent &#123; get; &#125; public bool IsInitialized &#123; get; &#125; public bool ForceCursor &#123; get; set; &#125; public Cursor Cursor &#123; get; set; &#125; public Style FocusVisualStyle &#123; get; set; &#125; public bool IsLoaded &#123; get; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal InheritanceBehavior InheritanceBehavior &#123; get; set; &#125; protected internal virtual IEnumerator LogicalChildren &#123; get; &#125; protected internal object DefaultStyleKey &#123; get; set; &#125; public event ToolTipEventHandler ToolTipClosing; public event ToolTipEventHandler ToolTipOpening; public event RoutedEventHandler Unloaded; public event DependencyPropertyChangedEventHandler DataContextChanged; public event SizeChangedEventHandler SizeChanged; public event RequestBringIntoViewEventHandler RequestBringIntoView; public event EventHandler&lt;DataTransferEventArgs&gt; SourceUpdated; public event EventHandler&lt;DataTransferEventArgs&gt; TargetUpdated; public event RoutedEventHandler Loaded; public event EventHandler Initialized; public event ContextMenuEventHandler ContextMenuClosing; public event ContextMenuEventHandler ContextMenuOpening; public static FlowDirection GetFlowDirection(DependencyObject element); public static void SetFlowDirection(DependencyObject element, FlowDirection value); public bool ApplyTemplate(); public virtual void BeginInit(); public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior, bool isControllable); public void BeginStoryboard(Storyboard storyboard); public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior); public void BringIntoView(); public void BringIntoView(Rect targetRectangle); public virtual void EndInit(); public object FindName(string name); public object FindResource(object resourceKey); public BindingExpression GetBindingExpression(DependencyProperty dp); public sealed override bool MoveFocus(TraversalRequest request); public virtual void OnApplyTemplate(); public sealed override DependencyObject PredictFocus(FocusNavigationDirection direction); public void RegisterName(string name, object scopedElement); public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding); public BindingExpression SetBinding(DependencyProperty dp, string path); public void SetResourceReference(DependencyProperty dp, object name); public bool ShouldSerializeResources(); public bool ShouldSerializeStyle(); public bool ShouldSerializeTriggers(); public object TryFindResource(object resourceKey); public void UnregisterName(string name); public void UpdateDefaultStyle(); protected sealed override void ArrangeCore(Rect finalRect); protected virtual Size ArrangeOverride(Size finalSize); protected override Geometry GetLayoutClip(Size layoutSlotSize); protected override Visual GetVisualChild(int index); protected sealed override Size MeasureCore(Size availableSize); protected virtual Size MeasureOverride(Size availableSize); protected virtual void OnContextMenuClosing(ContextMenuEventArgs e); protected virtual void OnContextMenuOpening(ContextMenuEventArgs e); protected override void OnGotFocus(RoutedEventArgs e); protected virtual void OnInitialized(EventArgs e); protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e); protected virtual void OnToolTipClosing(ToolTipEventArgs e); protected virtual void OnToolTipOpening(ToolTipEventArgs e); protected internal void AddLogicalChild(object child); protected internal DependencyObject GetTemplateChild(string childName); protected internal override DependencyObject GetUIParentCore(); protected internal override void OnRenderSizeChanged(SizeChangedInfo sizeInfo); protected internal virtual void OnStyleChanged(Style oldStyle, Style newStyle); protected internal override void OnVisualParentChanged(DependencyObject oldParent); protected internal virtual void ParentLayoutInvalidated(UIElement child); protected internal void RemoveLogicalChild(object child); &#125; 属性分析 1.LayoutTransform 属性：获取或设置在执行布局时应应用于此元素的图形转换。这个属性与UIElement类中的RenderTransform属性有相似之处，所以我们在此将两者进行对比说明一下。两个属性都是Transform类型，而Transform是一个抽象类，这个类可以实现控件在平面中的各种转换，包括 旋转 (System.Windows.Media.RotateTransform) 缩放 (System.Windows.Media.ScaleTransform)、 倾斜 (System.Windows.Media.SkewTransform) 、 平移 (System.Windows.Media.TranslateTransform)。 虽然两个属性都可以达到控件的变换效果，但是两者还是有区别的。LayoutTransform属性是在控件布局之前对控件进行变换，而RenderTransform属性是在布局结束后执行控件的变换，LayoutTransform开销比RenderTransform要大，所以，尽量使用RenderTransform属性去实现控件的变换。（我们会在后面专门探讨控件的变换） 2.Width属性：这是表示控件的宽度。与之相关的还有以下几个属性。 ActualWidth：获取此元素的呈现宽度。只读属性。 MaxWidth：获取或设置一个控件的最大宽度。 MinWidth：获取或设置一个控件的最小宽度。 3.Height属性：这是表示控件的高度，与之相关的还有以下几个属性。 ActualHeight：获取此元素的呈现高度。只读属性。 MaxHeight：获取或设置一个控件的最大高度。 MinHeight：获取或设置一个控件的最小高度。 4.Tag属性：这个属性非常重要，它是object类型，意味着可以保存任意类型的对象值。它就像FrameworkElement类身上的一个小口袋，但确能容纳万物。我们通常会将一些与控件相关的数据临时存放在Tag属性中，当把控件作为参数传递时，小口袋里面的对象也随之传递过去了。 5.Name属性：获取或设置控件的标识名称。在同一个窗体、页、用户控件中，Name标识是唯一的。设置了控件的名称后，我们就可以在后端代码直接以这个标识去引用控件。 6.Margin属性：获取或设置控件的外边距。如下所示，我们定义了一个button的margin，距离左边、上边、右边和下边的像素分别是20、40、60、80。 123 &lt;Grid&gt; &lt;Button Content=&quot;WPF中文网&quot; Margin=&quot;20 40 60 80&quot; /&gt;&lt;/Grid&gt; Padding属性说明 与Margin相对应的是Padding，表示设置控件的内边距。但是这个属性并不在FrameworkElement中，而在Control类中，从本节第一张图所示，说明只有内容控件才具有Padding，而Shape和Panel是没有Padding属性的。 7.HorizontalAlignment属性：设置控件的水平对齐方式。这个对齐方式是相对于父元素而言的，比如我们有一个Button控件，在外面还包裹了一层Grid控件，那么，设置Button控件的HorizontalAlignment属性，可以将Button控件分别显示在Grid控件的左边、中间、右边三个位置。 8.VerticalAlignment属性：设置控件的垂直对齐方式。与HorizontalAlignment属性类似，只是对方的方向不同，可以设置控件在垂直方向上是居于顶部、中间、还是底部三个位置。 总结：上述两个属性的值都是枚举型，它们都有一个共同的值，那就是stretch，表示是拉伸的方式填充父元素的布局。 9.ToolTip属性：获取或设置用户界面 (UI) 中为此元素显示的工具提示对象。指鼠标移到控件上方时显示的提示内容，它是一个object类型，意味着可以显示任意布局外观。 10.Parent属性：获取此元素的逻辑父元素。它是一个只读属性。 接下来，我们将介绍几个比较重要的属性，这些属性是WPF框架中非常核心的知识概念，需要单独形成章节来学习，在这里，我们只是通过这些属性来引出其概念。 WPF样式（Style） 什么是样式？简单来说，是指控件呈现时的样子。比如我们上班时会穿上工作服，休假时会穿上更个性化的衣服，我还是那个我，但是身上的衣服却不同，不管是颜色、款式，甚至包括我们的头饰、妆容，都会有所不同。 对于控件而言，同样都是button按钮，有的按钮是方的，有的是圆的，有的是蓝色，有的是红色，有的有文字，有的有图标，如果做到这些不同的样式呢？答案是Style属性。 11.Style属性：获取或设置此元素呈现时所使用的样式。（关于Style样式我们会专门拿一章节来探讨） 与Style相关的还有一个属性，叫FocusVisualStyle，顾名思义，控件在获得焦点时的样式。 WPF资源（ResourceDictionary） 什么是资源？资源，也就是资源字典，也就是ResourceDictionary类，它提供一个哈希表&#x2F;字典实现，其中包含组件所使用的 WPF 资源以及 WPF 应用程序的其他元素。我们可以把WPF的控件、窗体、Application应用所用到的一切资源都放在其中，将多个ResourceDictionary元素合并起来形成一个ResourceDictionary元素（ResourceDictionary也是一个隐式集合）。所以FrameworkElement类设计一个资源属性。 12.Resources 属性：获取或设置本地定义的资源字典。关于Resources资源我们会专门拿一章节来探讨） WPF的数据上下文（DataContext） 我们曾经在前面的《DependencyObject类》一文中提到过数据驱动模式，控件的值绑定某个“变量”，当“变量”的值发生改变，控件的值也跟着改变，反过来说，当控件的值发生改变，“变量”的值也跟着改变。那么这个特指的“变量”是什么？它和我们今天要介绍的数据上下文有什么关系？ 答案是，这个“变量”其实也是一个属性，且必须是一个属性（重点），它是谁的属性？WPF说，它是某个ViewModel类的属性。 假定我们有一个View窗体，窗体有一个TextBox控件；又假如我们还有一个ViewModel实体，这个实体中有一个叫Name的属性。如果我们要将TextBox控件的Text属性和ViewModel实体的Name属性成功的建立绑定关系，必备的条件是什么？ 首先，由于View窗体继承于FrameworkElement类，所以每个窗体（或控件）都有一个叫DataContext的数据上下文属性。所以必备的条件是：**ViewModel实体必须先赋值给View窗体的DataContext，ViewModel的Name属性才能绑定到TextBox控件的Text属性。**换言之，领导之间要先搭好桥，下属和下属才好配合工作。这就是DataContext的概念和用途。（关于DataContext数据上下文我们会专门拿一章节来探讨） 13.DataContext属性：获取或设置元素参与数据绑定时的数据上下文。 14.ContextMenu属性：设置与获取控件的上下文菜单 ，就是鼠标在控件上右键时弹出来的菜单。 15.Cursor属性：获取或设置在鼠标指针位于此元素上时显示的光标。 友情提示 上述所介绍的属性，是WPF中所有控件都有的属性哦，所以，学一个FrameworkElement类，就把所有控件都学了30%呢。——重庆教主 事件分析 FrameworkElement类提供了12个事件，一般比较常用的是：Initialized、Loaded、Unloaded、SizeChanged等事件。 方法成员 FrameworkElement类还提供了一些方法成员。 1.FindName(String)：表示查找某个元素。比如我们在窗体中要查找某个控件。 2.FindResource(Object)：查找某个资源。如果在调用对象上找不到该资源，则接下来搜索逻辑树中的父元素，然后搜索应用程序、主题，最后搜索系统资源。实在找不到就抛出异常。 3.TryFindResource(Object)：尝试去找某个资源。建议使用这个方法。 4.RegisterName (string , object );注册控件的名称到父控件上。 12345678button2 = new Button();button2.Name = &quot;Button2&quot;; // 注册button2的名称到myMainPanel控件上myMainPanel.RegisterName(button2.Name, button2);button2.Content = &quot;Button 2&quot;;button2.Click += new RoutedEventHandler(button2Clicked);myMainPanel.Children.Add(button2); 5.SetBinding(DependencyProperty, BindingBase)和SetBinding(DependencyProperty, String)，这两个成员都和绑定相关，我们将在后面做专题介绍。 最后，我们来看哪些类会继承这个FrameworkElement基类，以便于了解我们接下来要学哪些内容。 Microsoft.Windows.Themes.BulletChromeMicrosoft.Windows.Themes.ScrollChromeSystem.Windows.Controls.AccessTextSystem.Windows.Controls.AdornedElementPlaceholderSystem.Windows.Controls.ContentPresenterSystem.Windows.Controls.ControlSystem.Windows.Controls.DecoratorSystem.Windows.Controls.ImageSystem.Windows.Controls.InkCanvasSystem.Windows.Controls.ItemsPresenterSystem.Windows.Controls.MediaElementSystem.Windows.Controls.PageSystem.Windows.Controls.PanelSystem.Windows.Controls.Primitives.DocumentPageViewSystem.Windows.Controls.Primitives.GridViewRowPresenterBaseSystem.Windows.Controls.Primitives.PopupSystem.Windows.Controls.Primitives.TickBarSystem.Windows.Controls.Primitives.TrackSystem.Windows.Controls.TextBlockSystem.Windows.Controls.ToolBarTraySystem.Windows.Controls.Viewport3DSystem.Windows.Documents.AdornerSystem.Windows.Documents.AdornerLayerSystem.Windows.Documents.DocumentReferenceSystem.Windows.Documents.FixedPageSystem.Windows.Documents.GlyphsSystem.Windows.Documents.PageContentSystem.Windows.Interop.HwndHostSystem.Windows.Shapes.Shape 好，关于FrameworkElement类的成员，我们就先讲这么多，在介绍完WPF的父类之后，下一章，我们正式开始学习WPF控件。 布局控件布局控件概述在WPF中，布局的方式十分丰富，有按表格布局的Grid和UniformGrid栅格控件，有类似Winform拖放的Canvas控件，有按照垂直或水平排列的StackPanel控件，也有按照东西南北中方位排列的DockPanel控件，还有以瀑布流方式WrapPanel控件，以及按Tab页切换显示的TabControl控件。微软将它们抽象成Panel基类，并让这个基类继承于FrameworkElement类。 控件名称 布局方式 Grid 网格，根据自定义行和列来设置控件的布局 StackPanel 栈式面板，包含的元素在竖直或水平方向排成一条直线 WrapPanel 自动折行面板，包含的元素在排满一行后，自动换行 DockPanel 泊靠式面板，内部的元素可以选择泊靠方向 UniformGrid 网格,UniformGrid就是Grid的简化版，每个单元格的大小相同。 Canvas 画布，内部元素根据像素为单位绝对坐标进行定位 Border 装饰的控件，此控件用于绘制边框及背景，在Border中只能有一个子控件 Panel基类Panel其实是一个抽象类，不可以实例化，WPF所有的布局控件都从Panel继承而来，所以我们在学习布局控件之前，要先了解一下这个类。首先看一下它的定义： 1234567891011121314151617181920212223242526272829public abstract class Panel : FrameworkElement, IAddChild&#123; public static readonly DependencyProperty BackgroundProperty; public static readonly DependencyProperty IsItemsHostProperty; public static readonly DependencyProperty ZIndexProperty; protected Panel(); public bool HasLogicalOrientationPublic &#123; get; &#125; public Orientation LogicalOrientationPublic &#123; get; &#125; public bool IsItemsHost &#123; get; set; &#125; public UIElementCollection Children &#123; get; &#125; public Brush Background &#123; get; set; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal UIElementCollection InternalChildren &#123; get; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; protected internal virtual Orientation LogicalOrientation &#123; get; &#125; protected internal virtual bool HasLogicalOrientation &#123; get; &#125; public static int GetZIndex(UIElement element); public static void SetZIndex(UIElement element, int value); public bool ShouldSerializeChildren(); protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent); protected override Visual GetVisualChild(int index); protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost); protected override void OnRender(DrawingContext dc); protected internal override void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved); &#125; 从它的代码定义来看，它继承于FrameworkElement基类和IAddChild接口。所以，所有 Panel 元素都支持 FrameworkElement 定义的基本大小调整和定位属性，包括 Height、Width、HorizontalAlignment、VerticalAlignment、Margin 和 LayoutTransform。 它有一个Background属性，意味着所有的布局控件都可以设置背景颜色。另外，它还有一个Children属性，这是一个集合属性，也就是说，所有的布局控件都可以添加多个子元素。这一点从它继承的IAddChild接口也能得到印证。 12345678910namespace System.Windows.Markup&#123; //提供了一种分析允许混合的子元素或文本的元素的方法。 public interface IAddChild &#123; //添加子对象。 void AddChild(object value); //将节点的文本内容添加到对象。 void AddText(string text); &#125; Panel提供了GetZIndex和SetZIndex方法成员，分别表示获取某个元素的ZIndex顺序和设置某个元素的ZIndex顺序。 什么是ZIndex？这是Panel提供的一个附加属性。假如一个单行单列的Grid布局控件中有两个Button,正常情况下，这两个Button都会以撑满Grid的方式呈现在Grid中，那么，到底哪一个Button在上面，哪一个Button在下面呢？就看这两个Button的Panel.ZIndex附加属性的值，值越大越在上面，而值较小的那个Button将被上面的Button遮盖，从而在视觉上，用户只能看到一个Button。 附加属性 附加属性的一个用途是允许子元素存储实际上由父元素定义的属性的唯一值。 此功能的一项应用是让子元素通知父级它们希望如何在用户界面 (UI) 中呈现，这对应用程序布局非常有用。 1234&lt;Grid &gt; &lt;Button Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20 40 60 80&quot; Padding=&quot;50&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20 40 60 80&quot; Padding=&quot;50&quot; /&gt;&lt;/Grid&gt; 在上面的示例中，正常情况下，会显示“WPF中文网2”按钮，但是我们故意叫其Panel.ZIndex&#x3D;0，从而小于上面那个按钮的属性值，所以显示了“WPF中文网1”按钮。 WPF 提供了一套全面的派生 Panel 实现，可实现许多复杂的布局。这里有一个非常非常需要注意的事项，那就是Panel的Background属性。有时候我们希望在布局控件上实现鼠标点击事件的获取，请记得一定要给Background属性设置一个颜色值，如果不希望有具体的颜色，那就设置成Transparent 。不然，您会踩坑的！因为布局控件的Background属性没有值时，是不能引发鼠标相关事件的。 深入探究Panel类 Panel作为布局控件的基类，拥有一个叫Children的属性，这个属性的类型是UIElementCollection。我们来看一下它的结构： 1234567891011121314151617181920212223242526public class UIElementCollection : IList, ICollection, IEnumerable&#123; public UIElementCollection(UIElement visualParent, FrameworkElement logicalParent); public virtual UIElement this[int index] &#123; get; set; &#125; public virtual int Capacity &#123; get; set; &#125; public virtual object SyncRoot &#123; get; &#125; public virtual bool IsSynchronized &#123; get; &#125; public virtual int Count &#123; get; &#125; public virtual int Add(UIElement element); public virtual void Clear(); public virtual bool Contains(UIElement element); public virtual void CopyTo(UIElement[] array, int index); public virtual void CopyTo(Array array, int index); public virtual IEnumerator GetEnumerator(); public virtual int IndexOf(UIElement element); public virtual void Insert(int index, UIElement element); public virtual void Remove(UIElement element); public virtual void RemoveAt(int index); public virtual void RemoveRange(int index, int count); protected void ClearLogicalParent(UIElement element); protected void SetLogicalParent(UIElement element); &#125; 从它所定义的方法来看，我们会看到一些添加或移除某个元素的方法成员，例如Add，Insert，Remove，Contains等等，而这些方法的参数都有一个叫UIElement的形参，说明什么问题？只要继承于UIElement的类（或控件），都可以添加到Panel或Panel子类的Children中，从而在前端呈现出来。 WPF提供了六个用于UI布局的Panel子类，分别是：Grid、StackPanel、WrapPanel、DockPanel、 VirtualizingStackPanel和 Canvas。 这些面板元素易于使用、功能齐全并且可扩展，足以适用于大多数应用程序。 一个Panel 的呈现就是测量和排列子控件，然后在屏幕上绘制它们。所以在布局的过程中会经过一系列的计算，那么子控件越多，执行的计算次数就越多，则性能就会变差。如果不需要进行复杂的布局，则尽量少用复杂布局控件（如 Grid和自定义复杂的Panel）；如果能简单布局实现就尽量使用构造相对简单的布局（如 Canvas、UniformGrid等），这种布局可带来更好的性能。 如果有可能，我们应尽量避免调用 UpdateLayout方法。 布局系统为Panel中的每个子控件完成两个处理过程：测量处理过程（Measure）和排列处理过程（Arrange）。每个子 Panel 均提供自己的 MeasureOverride 和 ArrangeOverride 方法，以实现自己特定的布局行为。 每个派生 Panel 元素都以不同方式处理大小调整约束。 了解 Panel 如何处理水平或垂直方向上的约束可以使布局更容易预测。 控件名称 x维度 y维度 Grid 约束 约束，Auto 应用于行和列的情形除外 StackPanel（垂直） 约束 按内容约束 StackPanel（水平） 按内容约束 约束 DockPanel 约束 约束 WrapPanel 按内容约束 按内容约束 Canvas 按内容约束 按内容约束 Grid控件（网格布局）Grid控件其实是一个窗体的默认控件，我们创建一个WPF应用程序后，其主窗体里面会有一个Grid控件。我们先来看一下此类的结构定义： 1234567891011121314151617181920212223242526272829303132333435public class Grid : Panel, IAddChild&#123; public static readonly DependencyProperty ShowGridLinesProperty; public static readonly DependencyProperty ColumnProperty; public static readonly DependencyProperty RowProperty; public static readonly DependencyProperty ColumnSpanProperty; public static readonly DependencyProperty RowSpanProperty; public static readonly DependencyProperty IsSharedSizeScopeProperty; public Grid(); public ColumnDefinitionCollection ColumnDefinitions &#123; get; &#125; public bool ShowGridLines &#123; get; set; &#125; public RowDefinitionCollection RowDefinitions &#123; get; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public static int GetColumn(UIElement element); public static int GetColumnSpan(UIElement element); public static bool GetIsSharedSizeScope(UIElement element); public static int GetRow(UIElement element); public static int GetRowSpan(UIElement element); public static void SetColumn(UIElement element, int value); public static void SetColumnSpan(UIElement element, int value); public static void SetIsSharedSizeScope(UIElement element, bool value); public static void SetRow(UIElement element, int value); public static void SetRowSpan(UIElement element, int value); public bool ShouldSerializeColumnDefinitions(); public bool ShouldSerializeRowDefinitions(); protected override Size ArrangeOverride(Size arrangeSize); protected override Visual GetVisualChild(int index); protected override Size MeasureOverride(Size constraint); protected internal override void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved); &#125; Grid有两个非常关键的属性ColumnDefinitions和RowDefinitions，分别表示列的数量集合和行的数量集合。ColumnDefinitions集合中的元素类型是ColumnDefinition类，RowDefinitions集合中元素类型是RowDefinition类。默认的Gridr控件没有定义行数和列数，也就是说，Grid默认情况下，行数和列数都等于1，那么它就只有一个单元格。 1234&lt;Grid &gt; &lt;Button Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20 40 60 80&quot; Padding=&quot;50&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20 40 60 80&quot; Padding=&quot;50&quot; /&gt;&lt;/Grid&gt; 如上述代码所示，此时的Grid因为只有一个单元格，而Grid的Children属性里面有两个Button，势必有一个Button会被遮盖。假如我们希望两个按钮同时显示，应该怎么办呢？这时就有了两个选格，第一，两个Button左右排列显示，第二，两个Button上下排列显示。 一、左右排列 12345678&lt;Grid &gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; Padding=&quot;50&quot; /&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; Padding=&quot;50&quot; /&gt;&lt;/Grid&gt; 代码分析 我们在Grid控件的ColumnDefinitions属性增加了两个ColumnDefinition对象，如果分别设置了两个按钮的Grid.Column附加属性，指示两个Button分别显示在第一列和第二列，从而实现了左右排列，具两个按钮分别占据了50%的区域。这是因为我们并没有指定两个ColumnDefinition对象的宽度。 二、上下排列 12345678&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; Padding=&quot;50&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; Padding=&quot;50&quot; /&gt; &lt;/Grid&gt; 要实现上下排列，我们只需要在Grid控件的RowDefinitions中增加两行元素即可，即RowDefinition对象。同时，指定每个Button显示在哪一行，例如Grid.Row&#x3D;”0”，表示显示在第一行。 三、上下左右排列 现在我们将左右排列和上下排列两种模式合并起来，看看会发生什么状况。 1234567891011121314&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 我们创建了4个Button，并分别设置了它们所在的行和列，至此，网格的布局效果跃然纸上。以上就是Grid控件的基本用法。 深入探究Grid控件 在实际开发中，我们可能会遇到更复杂的用法，比如第一行只显示一个button，需要跨列显示，或者第一列只占整个Grid的20%的宽度等等，这就需要了解ColumnDefinition和RowDefinition。另外，我们需要显示Grid的网格线，又该如何实现呢？接下来，我们一一去探寻。 四、跨列排列 12345678910111213&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; Grid.ColumnSpan=&quot;2&quot;/&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 我们在原有基础上删掉了一个按钮，并将第一个按钮的Grid.ColumnSpan附加属性设置为2，表示从第0列往右跨两列，正好就呈现出图中的效果。您也可以尝试跨行显示，只需要设置按钮的Grid.RowSpan属性。 五、固定列宽 1234567891011121314&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;120&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 如图所示，我们只需要设置第一行ColumnDefinition的Width属性，让其宽度固定为120像素，那么第二列的宽度等于Grid的宽度减去120像素，其内部的Button宽度也随之自适应。这就是WPF布局自适应的好处。 六、调整行高和列宽 Grid控件的行高和列宽的设置十分丰富，了解它们的用法，有助于设计出更出色的布局。 名称 说明 绝对设置尺寸 使用设备无关单位准确地设置尺寸，就是给一个实际的数字，但通常将此值指定为整数（像素）。如： 自动设置尺寸 值为Auto，实际作用就是取实际控件所需的最小值，每行和每列的尺寸刚好满足需要，这是最有用的尺寸设置方式。如： 按比例设置设置尺寸 按比例将空间分割到一组行和列中。这是对所有行和列的标准设置。通常值为或N，实际作用就是取尽可能大的值，当某一列或行被定义为则是尽可能大，当出现多列或行被定义为则是代表几者之间按比例方设置尺寸。如： 指定权重，即第2列的宽度是第1列的两倍 七、Grid显示网格线 1234567891011121314&lt;Grid ShowGridLines=&quot;True&quot; Margin=&quot;5&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;120&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 只需要设置Grid的ShowGridLines&#x3D;True，就可以显示Grid的网格线，但是这种虚线效果并不友好，我们还有曲线救国的方案。 1234567891011121314151617&lt;Grid Margin=&quot;5&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;120&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Border Grid.Row=&quot;0&quot; Grid.RowSpan=&quot;2&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; BorderBrush=&quot;Gray&quot; BorderThickness=&quot;1&quot;/&gt; &lt;Border Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; BorderBrush=&quot;Gray&quot; BorderThickness=&quot;0 0 0 1&quot;/&gt; &lt;Border Grid.Row=&quot;0&quot; Grid.RowSpan=&quot;2&quot; Grid.Column=&quot;0&quot; BorderBrush=&quot;Gray&quot; BorderThickness=&quot;0 0 1 0&quot;/&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 我们在Grid内部增加了3个Border，第一个Border用来显示外边框，第二个Border显示中间的横线，第三个Border显示中间的竖线，这时所用的知识点几乎都是Grid的跨行和跨列属性，另外还有边框颜色刷子BorderBrush和边框厚度BorderThickness。 总结 Grid控件绝对是WPF中所有布局控件中最好用的一个，因为它自适应屏幕的宽度，最关键的一点是，它在呈现时，其ActualWidth实际宽度和ActualHeight实际高度会有一个计算值，我们在业务开发中，有时候要根据父控件的实际宽度和高度来计算子控件的呈现位置和大小。 除了Grid这种网格化的布局，下面我们将介绍另一种布局方式——均分布局 UniformGrid控件（均分布局）UniformGrid和Grid有些相似，只不过UniformGrid的每个单元格面积都是相等的，不管是横向的单元格，或是纵向的单元格，它们会平分整个UniformGrid。我们先看看它的结构定义： 12345678910111213141516public class UniformGrid : Panel&#123; public static readonly DependencyProperty FirstColumnProperty; public static readonly DependencyProperty ColumnsProperty; public static readonly DependencyProperty RowsProperty; public UniformGrid(); public int FirstColumn &#123; get; set; &#125; public int Columns &#123; get; set; &#125; public int Rows &#123; get; set; &#125; protected override Size ArrangeOverride(Size arrangeSize); protected override Size MeasureOverride(Size constraint); &#125; UniformGrid控件提供了3个属性，分别是FirstColumn、Columns 、Rows 。FirstColumn表示第一行要空几个单元格，后面两个属性分别用于设置行数和列数。接下来我们以实际的例子来分析这3个属性的用法。 123456&lt;UniformGrid&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;2&quot;/&gt;&lt;/UniformGrid&gt; 这是我们没有UniformGrid的属性的效果，它会根据子元素的数量和UniformGrid自身的尺寸来决定行数和列数。 123456&lt;UniformGrid FirstColumn=&quot;1&quot; Rows=&quot;3&quot; Columns=&quot;3&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;2&quot;/&gt;&lt;/UniformGrid&gt; 我们故意设计了当前UniformGrid为3行3列，同时设置第一行第一个单元格保持空白，于是我们就看到了上图中的效果。 UniformGrid控件使用非常简单方便，通常用于局部的布局。 StackPanel控件（栈式布局）StackPanel用于水平或垂直堆叠子元素。也就是说，StackPanel同样也有一个Children属性，而Children集合中的元素呈现在界面上时，只能是按水平或垂直方式布局。我们先来看看它的结构定义： 1234567891011121314151617181920212223242526272829303132333435363738public class StackPanel : Panel, IScrollInfo, IStackMeasure&#123; public static readonly DependencyProperty OrientationProperty; public StackPanel(); public double HorizontalOffset &#123; get; &#125; public double ViewportHeight &#123; get; &#125; public double ViewportWidth &#123; get; &#125; public double ExtentHeight &#123; get; &#125; public double ExtentWidth &#123; get; &#125; public bool CanVerticallyScroll &#123; get; set; &#125; public bool CanHorizontallyScroll &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; public double VerticalOffset &#123; get; &#125; public ScrollViewer ScrollOwner &#123; get; set; &#125; protected internal override Orientation LogicalOrientation &#123; get; &#125; protected internal override bool HasLogicalOrientation &#123; get; &#125; public void LineDown(); public void LineLeft(); public void LineRight(); public void LineUp(); public Rect MakeVisible(Visual visual, Rect rectangle); public void MouseWheelDown(); public void MouseWheelLeft(); public void MouseWheelRight(); public void MouseWheelUp(); public void PageDown(); public void PageLeft(); public void PageRight(); public void PageUp(); public void SetHorizontalOffset(double offset); public void SetVerticalOffset(double offset); protected override Size ArrangeOverride(Size arrangeSize); protected override Size MeasureOverride(Size constraint); &#125; StackPanel提供了一些属性和方法，最常用的是Orientation枚举属性，用于设置子控件在StackPanel内部的排列方式，分别是水平排列（Horizontal）和垂直排列（Vertical）。默认值是垂直排列（Vertical）。 一、水平排列 123456&lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;20&quot; /&gt;&lt;/StackPanel&gt; 请注意，当StackPanel子元素处于垂直排列时，此时子元素的宽度默认与StakcPanel的宽度保持一致，但是子元素的高度是与其自身的高度自适应显示。 二、垂直排列 123456&lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;20&quot; /&gt;&lt;/StackPanel&gt; 请注意，当StackPanel子元素处于水平排列时，此时子元素的高度默认与StakcPanel的高度保持一致，但是子元素的宽度是与其自身的宽度自适应显示。 深入探究StackPanel控件 可以利用子控件的HorizontalAlignment属性或VerticalAlignment来设置子控件在StackPanel内部的显示位置，比如在垂直排列布局模式下，可以设置HorizontalAlignment属性值，Left表示显示在左则，Right显示在右则，Center则居中显示，Stretch表示拉伸填充显示。 需要注意的是，由于WPF的控件布局都是采用自适应计算每个控件的位置，所以在设置了HorizontalAlignment或VerticalAlignment后，子控件的宽度和高度都会重新计算，主要是根据自身内容的尺寸计算。 12345678910111213&lt;ScrollViewer&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Left&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Right&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网6&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网7&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网8&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网9&quot; Margin=&quot;20&quot; /&gt; &lt;/StackPanel&gt;&lt;/ScrollViewer&gt; 于是，我们可以看到上图中前三行的按钮都是根据自身内容的宽高自适应绘制的。另外，如果StackPanel内部的子控件太多，则需要配合滚动条容器ScrollViewer控件。 和StackPanel类似的控件，还有两个，分别是WrapPanel和DockPanel。下一节，我们将探讨WrapPanel控件。 WrapPanel控件（瀑布流布局）WrapPanel控件表示将其子控件从左到右的顺序排列，如果第一行显示不了，则自动换至第二行，继续显示剩余的子控件。我们来看看它的结构定义： 12345678910111213141516public class WrapPanel : Panel&#123; public static readonly DependencyProperty ItemWidthProperty; public static readonly DependencyProperty ItemHeightProperty; public static readonly DependencyProperty OrientationProperty; public WrapPanel(); public double ItemWidth &#123; get; set; &#125; public double ItemHeight &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; protected override Size ArrangeOverride(Size finalSize); protected override Size MeasureOverride(Size constraint); &#125; 这个控件比较简单，只提供了3个属性，分别是Orientation代表子控件的排列方向，ItemWidth代表子控件的（最大）宽度，ItemHeight代表子控件的（最大）高度。默认的排列方向是水平方向。 一、水平排列 123456789101112&lt;WrapPanel Orientation=&quot;Horizontal&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Left&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Right&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网6&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网7&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网8&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网9&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网10&quot; Margin=&quot;5&quot; /&gt;&lt;/WrapPanel&gt; 由上图所示，我们在WrapPanel的Children属性中放了10个Button，分成了两行显示，请注意一个细节，WrapPanel的子元素的高度和宽度都是根据子元素自身内容的尺寸呈现。另外，当WrapPanel处于水平排列时，子元素的HorizontalAlignment是不起作用的。 二、垂直排列 12345678910111213141516171819202122&lt;WrapPanel Orientation=&quot;Vertical&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Left&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Right&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网6&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网7&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网8&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网9&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网10&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网12&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网13&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网14&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网15&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网16&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网17&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网18&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网19&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网20&quot; Margin=&quot;5&quot; /&gt; &lt;/WrapPanel&gt; 这里我们放了20个button在WrapPanel控件中，并设置Orientation属性为Vertical（垂直排列），此时，请观察前面3个按钮的HorizontalAlignment状态，可以很清晰的看到，第一个按钮居左显示，第二个按钮居右显示，第三个按钮居中显示，说明在Vertical垂直排列下，子元素的水平状态才会生效，反之亦然。 三、指定子元素宽高 123456789101112&lt;WrapPanel Orientation=&quot;Horizontal&quot; ItemWidth=&quot;80&quot; ItemHeight=&quot;80&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Left&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Right&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网6&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网7&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网8&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网9&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网10&quot; Margin=&quot;5&quot; /&gt;&lt;/WrapPanel&gt; 由此可以，我们也可以指定子元素的宽度和高度，以便统一观察。下一节，我们将探讨与WrapPanel非常相似的布局控件DockPanel。 DockPanel控件（停靠布局）官方解释，定义一个区域，从中可以按相对位置水平或垂直排列各个子元素。我们还是先来看一下它的结构定义： 123456789101112131415public class DockPanel : Panel&#123; public static readonly DependencyProperty LastChildFillProperty; public static readonly DependencyProperty DockProperty; public DockPanel(); public bool LastChildFill &#123; get; set; &#125; public static Dock GetDock(UIElement element); public static void SetDock(UIElement element, Dock dock); protected override Size ArrangeOverride(Size arrangeSize); protected override Size MeasureOverride(Size constraint); &#125; DockPanel提供了一个LastChildFill 属性，用来指示最后一个子元素是否填满剩余的空间。其次，它还提供了一个枚举依赖属性，叫Dock。这个属性是附加到子元素身上的，用来指示子元素在DockPanel显示停靠方位，其值分为Left，Right，Top，Bottom。 DockPanel因为继承了FrameworkElement基类，所以您还可以使用FrameworkElement基类的HorizontalAlignment（水平对齐）和VerticalAlignment（垂直对齐）两个属性，用来设置子元素的排列方式。接下来我们将演示它最基本的用法。 一、经典布局 1234567&lt;DockPanel&gt; &lt;Button DockPanel.Dock=&quot;Left&quot; Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; /&gt; &lt;Button DockPanel.Dock=&quot;Top&quot; Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; /&gt; &lt;Button DockPanel.Dock=&quot;Right&quot; Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; /&gt; &lt;Button DockPanel.Dock=&quot;Bottom&quot; Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt;&lt;/DockPanel&gt; 这是DockPanel最经典的布局方式，上下左右都停靠一个控件，中间剩余的空间，全部由最后一个控件填满。 二、水平布局 1234567&lt;DockPanel LastChildFill=&quot;False&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt;&lt;/DockPanel&gt; 我们只需要设置LastChildFill为False，并设置HorizontalAlignment属性，并再指定子控件的停靠方向，就可以达到上图的效果。 1234567&lt;DockPanel LastChildFill=&quot;False&quot; VerticalAlignment=&quot;Top&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot;/&gt;&lt;/DockPanel&gt; 你可以通过摸索HorizontalAlignment（水平对齐）和VerticalAlignment（垂直对齐）两个属性，还可以达到更多意想不到的效果哦。 VirtualizingStackPanel 类VirtualizingStackPanel 类（虚拟化元素）和StackPanel 类在用法上几乎差不多。其作用是在水平或垂直的一行中排列并显示内容。它继承于一个叫VirtualizingPanel的抽象类，而这个VirtualizingPanel抽象类继承于Panel布局基类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class VirtualizingStackPanel : VirtualizingPanel, IScrollInfo, IStackMeasure&#123; public static readonly DependencyProperty IsVirtualizingProperty; public static readonly DependencyProperty VirtualizationModeProperty; public static readonly DependencyProperty OrientationProperty; public static readonly RoutedEvent CleanUpVirtualizedItemEvent; public VirtualizingStackPanel(); public double VerticalOffset &#123; get; &#125; public double HorizontalOffset &#123; get; &#125; public double ViewportHeight &#123; get; &#125; public double ViewportWidth &#123; get; &#125; public double ExtentHeight &#123; get; &#125; public double ExtentWidth &#123; get; &#125; public bool CanVerticallyScroll &#123; get; set; &#125; public bool CanHorizontallyScroll &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; public ScrollViewer ScrollOwner &#123; get; set; &#125; protected override bool CanHierarchicallyScrollAndVirtualizeCore &#123; get; &#125; protected internal override Orientation LogicalOrientation &#123; get; &#125; protected internal override bool HasLogicalOrientation &#123; get; &#125; public static void AddCleanUpVirtualizedItemHandler(DependencyObject element, CleanUpVirtualizedItemEventHandler handler); public static void RemoveCleanUpVirtualizedItemHandler(DependencyObject element, CleanUpVirtualizedItemEventHandler handler); public virtual void LineDown(); public virtual void LineLeft(); public virtual void LineRight(); public virtual void LineUp(); public Rect MakeVisible(Visual visual, Rect rectangle); public virtual void MouseWheelDown(); public virtual void MouseWheelLeft(); public virtual void MouseWheelRight(); public virtual void MouseWheelUp(); public virtual void PageDown(); public virtual void PageLeft(); public virtual void PageRight(); public virtual void PageUp(); public void SetHorizontalOffset(double offset); public void SetVerticalOffset(double offset); protected override Size ArrangeOverride(Size arrangeSize); protected override double GetItemOffsetCore(UIElement child); protected override Size MeasureOverride(Size constraint); protected virtual void OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs e); protected override void OnClearChildren(); protected override void OnItemsChanged(object sender, ItemsChangedEventArgs args); protected virtual void OnViewportOffsetChanged(Vector oldViewportOffset, Vector newViewportOffset); protected virtual void OnViewportSizeChanged(Size oldViewportSize, Size newViewportSize); protected override bool ShouldItemsChangeAffectLayoutCore(bool areItemChangesLocal, ItemsChangedEventArgs args); protected internal override void BringIndexIntoView(int index); &#125; VirtualizingStackPanel 类有什么作用？ 比如在ListBox集合控件中需要显示500条数据，那整个屏幕只能显示20条，剩余的480条数据在ListBox控件要不要一次性绘制出来？其实就算绘制出来，用户的屏幕也看不见，只能是拖动滚动条才能看见后面的数据。既然屏幕只能显示20条数据，何不只绘制20条数据的UI子元素，剩下的480条数据的子元素在拖动滚动条时才绘制，这将大大减少计算机的性能消耗，提高UI界面的呈现速度，提高软件的流畅性。 所以，VirtualizingStackPanel 类的作用是开启虚拟化技术，延迟那些看不见的子元素的绘制与渲染。 要开启这项技术，只需要设置Listbox集合控件的附加属性VirtualizingStackPanel.IsVirtualizing&#x3D;”True”即可。因为ListBox的ItemsPanel（元素布局模板）默认采用了VirtualizingStackPanel控件布局。 Canvas控件（绝对布局）Canvas控件允许我们像Winform一样拖拽子控件进行布局，而子控件的位置相对于Canvas来说是绝对的，所以我将它称为绝对布局。我们来看看它的结构定义： 12345678910111213141516171819202122public class Canvas : Panel&#123; public static readonly DependencyProperty LeftProperty; public static readonly DependencyProperty TopProperty; public static readonly DependencyProperty RightProperty; public static readonly DependencyProperty BottomProperty; public Canvas(); public static double GetBottom(UIElement element); public static double GetLeft(UIElement element); public static double GetRight(UIElement element); public static double GetTop(UIElement element); public static void SetBottom(UIElement element, double length); public static void SetLeft(UIElement element, double length); public static void SetRight(UIElement element, double length); public static void SetTop(UIElement element, double length); protected override Size ArrangeOverride(Size arrangeSize); protected override Geometry GetLayoutClip(Size layoutSlotSize); protected override Size MeasureOverride(Size constraint); &#125; 观察它的结构，我们可以看到它提供了4个依赖属性，分别是LeftProperty，RightProperty，TopProperty和BottomProperty。其实是将这4个属性附加到子元素身上，以此来设置子元素距离Canvas上下左右的像素位置。 1234567&lt;Canvas&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt;&lt;/Canvas&gt; 上面的示例并没有指定button控件在Canvas控件中的上下左右停靠位置，所以这5个button默认会显示在Canvas的左上角，且只能显示最后一个，前面4个会被遮盖。我们来看看下面的例子。 1234567&lt;Canvas&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; Canvas.Left=&quot;50&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; Canvas.Top=&quot;50&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; Canvas.Right=&quot;50&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; Canvas.Bottom=&quot;50&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Canvas.Left=&quot;200&quot; Canvas.Top=&quot;150&quot; /&gt;&lt;/Canvas&gt; 上面的源代码中，我们从上到下，分别来分析一下5个button。 第一个button，设置了Canvas.Left&#x3D;”50”，它将保持距离Canvas左边50像素。 第二个button，设置了Canvas.Top&#x3D;”50”，它将保持距离Canvas顶部50像素。 第三个button，设置了Canvas.Right&#x3D;”50”，它将保持距离Canvas右侧50像素。 第四个button，设置了Canvas.Bottom&#x3D;”50”，它将保持距离Canvas底部50像素。 第五个button，设置了Canvas.Left&#x3D;”200” Canvas.Top&#x3D;”150”，也就是同时距离Canvas左边200像素，顶部150像素。 Border控件（边框布局）严格来说，Border并不是一个布局控件，因为它并不是Panel的子类，而是Decorator装饰器的子类，而Decorator继承于FrameworkElement。要了解Border的用法，我们要先看看它的父类Decorator。 12345678910111213public class Decorator : FrameworkElement, IAddChild&#123; public Decorator(); public virtual UIElement Child &#123; get; set; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; protected override Size ArrangeOverride(Size arrangeSize); protected override Visual GetVisualChild(int index); protected override Size MeasureOverride(Size constraint); &#125; Decorator 装饰器只有一个Child 属性，说明Decorator只能容纳一个子元素（UIElement），也就是Border只能容纳一个子元素。那我们再看看Border的结构定义： 123456789101112131415161718192021public class Border : Decorator&#123; public static readonly DependencyProperty BorderThicknessProperty; public static readonly DependencyProperty PaddingProperty; public static readonly DependencyProperty CornerRadiusProperty; public static readonly DependencyProperty BorderBrushProperty; public static readonly DependencyProperty BackgroundProperty; public Border(); public Thickness BorderThickness &#123; get; set; &#125; public Thickness Padding &#123; get; set; &#125; public CornerRadius CornerRadius &#123; get; set; &#125; public Brush BorderBrush &#123; get; set; &#125; public Brush Background &#123; get; set; &#125; protected override Size ArrangeOverride(Size finalSize); protected override Size MeasureOverride(Size constraint); protected override void OnRender(DrawingContext dc); &#125; 我们直接以表格的形式给出Border的相关属性。 属性 说明 BorderThickness 设置Border边框的厚度（像素宽度） Padding 设置子元素相对于Border边框的距离 CornerRadius 设置Border的圆角 BorderBrush 设置Border边框的颜色画刷 Background 设置Border的背景颜色画刷 正是因为Border有这么多实用的属性， 所以， 我们通常在布局界面时，Border（装饰器）控件是首选。接下来，我们以一个例子来说明Border有多么好用。 12345678910111213&lt;WrapPanel Margin=&quot;10&quot;&gt; &lt;Border Height=&quot;35&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; BorderBrush=&quot;Gray&quot;&gt; &lt;TextBlock Text=&quot;矩形 - Border控件&quot; Margin=&quot;5&quot; /&gt; &lt;/Border&gt; &lt;Border Height=&quot;35&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; BorderBrush=&quot;Gray&quot; CornerRadius=&quot;20&quot;&gt; &lt;TextBlock Text=&quot;椭圆 - Border控件&quot; Margin=&quot;5&quot; /&gt; &lt;/Border&gt; &lt;Border Width=&quot;150&quot; Height=&quot;150&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; Background=&quot;Red&quot; BorderBrush=&quot;Gray&quot; CornerRadius=&quot;75&quot;&gt; &lt;TextBlock Text=&quot;圆形Border控件&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; FontSize=&quot;16&quot; FontWeight=&quot;Bold&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot;/&gt; &lt;/Border&gt;&lt;/WrapPanel&gt; 我们分别写了3个Border，第一个Border被设计成矩形，第二个Border增加了圆角属性，第三个Border通过CornerRadius属性，将值设置为宽度或高度的一半，就形成了一个正圆。 将来，我们再配合WPF的模板、样式、触发器会让Border的用法更上一层楼。 WPF布局Demo示例通过前面的章节学习，我们来尝试利用学过的布局控件，设计一款简单的UI界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;auto&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;!--Top--&gt; &lt;DockPanel Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; Background=&quot;#126A74&quot; Height=&quot;60&quot;&gt; &lt;TextBlock Text=&quot;WPF中文网应用程序&quot; Foreground=&quot;White&quot; FontSize=&quot;20&quot; Margin=&quot;15,15&quot;/&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Right&quot;&gt; &lt;Border Height=&quot;35&quot; Margin=&quot;10&quot; BorderThickness=&quot;1&quot; BorderBrush=&quot;#CA5100&quot; Background=&quot;#CA5100&quot; CornerRadius=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;退出系统&quot; Foreground=&quot;White&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;10 0 10 0&quot;/&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;/DockPanel&gt; &lt;!--left--&gt; &lt;StackPanel Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Width=&quot;350&quot;&gt; &lt;Border Height=&quot;250&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; Background=&quot;#439D84&quot;&gt; &lt;TextBlock Text=&quot;参数区域&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot; FontSize=&quot;16&quot;/&gt; &lt;/Border&gt; &lt;Border Height=&quot;250&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; Background=&quot;#9CDC7B&quot;&gt; &lt;TextBlock Text=&quot;参数区域&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot; FontSize=&quot;16&quot;/&gt; &lt;/Border&gt; &lt;Border Height=&quot;110&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; Background=&quot;#E97752&quot;&gt; &lt;TextBlock Text=&quot;参数区域&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot; FontSize=&quot;16&quot;/&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;!--right--&gt; &lt;Grid Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot;&gt; &lt;Border Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; BorderBrush=&quot;#F7BD93&quot; CornerRadius=&quot;5&quot; Background=&quot;#FDD2B2&quot;&gt; &lt;TextBlock Text=&quot;主体区域&quot; Margin=&quot;5&quot; /&gt; &lt;/Border&gt; &lt;Border Width=&quot;150&quot; Height=&quot;150&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; Background=&quot;Red&quot; BorderBrush=&quot;Gray&quot; CornerRadius=&quot;75&quot;&gt; &lt;TextBlock Text=&quot;开始运行&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; FontSize=&quot;16&quot; FontWeight=&quot;Bold&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot;/&gt; &lt;/Border&gt; &lt;/Grid&gt; &lt;!--bottom--&gt; &lt;Grid Grid.Row=&quot;2&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; Background=&quot;#CA5100&quot;&gt; &lt;TextBlock Text=&quot;版本：1.0.2.5 | 版权所有：中国WPF中文网科技有限公司 www.wpfsoft.com&quot; Margin=&quot;10 5 10 5&quot; Foreground=&quot;White&quot;/&gt; &lt;/Grid&gt;&lt;/Grid&gt; 我们通过Grid栅格布局出界面的主要区域，然后给每个区域进行二次布局，比如Top区域，我们DockPanel和StackPanel的组合，设计成左右两个子区域，左边是应用程序的名称，右边是退出按钮。 中间区域，分为两部分组成，左边是一个StackPanel，里面有一个Border，右边是一个Grid。(注：左侧的StackPanel改成Grid的效果会更好哦) 底部区域是一个Grid,和一个TextBlock内容控件。好，我们布局控件的内容就先介绍到这里，在后续的章节中， 我们还会给出更多的例子来诠释WPF的其它知识点，而这些知识都有可能用以布局控件，所以，我们还会进一步学习布局控件的实战。 GridSplitter分割窗口ridSplitter控件用来分割窗体的布局，必须放在Grid栅格控件中配合使用，通过鼠标按住GridSplitter进行左右或上下拖动，即可调整行列尺寸。 注意事项： 1、如果您希望GridSplitter控件可以水平调整左右的Grid列宽时，那么HorizontalAlignment属性必须设置为Stretch或者Center。 2、如果您希望GridSplitter控件可以垂直调整行高，那么VerticalAlignment属性必须设置为Stretch或者Center。 3、ShowsPreview属性表示拖动时是否及时绘制调整尺寸。 接下来，我们通过一个例子来说明它的用法 前端代码 12345678910111213141516171819202122232425262728&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition Width=&quot;auto&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Border Grid.Column=&quot;0&quot; Background=&quot;LightBlue&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot; LineHeight=&quot;20&quot;&gt; 您好，我是站长重庆教主，欢迎来到 WPF中文网，我们的网址是：http://www.wpfsoft.com。您还可以在百度、B站、51CTO、csdn搜索我的名字，以便找到我其它的技术文章或视频课程。本站上线于2023年8月3日，在一个稀松平常的午后，我突然想搭建一个关于学习和分享WPF框架的博客网站，于是开始注册域名、购买空间、安装网站、设置栏目，不到3个小时，WPF中文网就诞生了。 &lt;/TextBlock&gt; &lt;/Border&gt; &lt;GridSplitter Grid.Column=&quot;1&quot; Width=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; ShowsPreview=&quot;False&quot;/&gt; &lt;Border Grid.Column=&quot;2&quot; Background=&quot;LightCoral&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot; LineHeight=&quot;20&quot;&gt;接下来的日子里，我将从WPF的起源、概述、学习路径等，一路写下去，一直把WPF最后一滴知识详尽才会封笔，我明白这是一场耗费个人巨大精力的战争。但是，那些我曾踩过的坑与走过的弯路，都无时无刻不提醒着我，尽量像讲故事一样，把这一切都写下来吧，总结自己，照亮来者。 &lt;/TextBlock&gt; &lt;/Border&gt; &lt;/Grid&gt;&lt;/Window&gt; 接下来我们看看F5运行后，可以用鼠标左右拖动的窗体效果。最好是为GridSplitter单独分配一行或者一列，同时，GridSplitter需要跨越整行或整列，这样的效果会更好。如上面的代码所示，我们在Grid中分割了3个单元格（3列），将GridSplitter居在放置，简单设置一下GridSplitter的属性，就可以达到我们的目的了。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"WPF - 编程","slug":"WPF-编程","permalink":"http://example.com/tags/WPF-%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"WPF编程高级","slug":"WPF高级学习","date":"2025-05-10T11:00:24.000Z","updated":"2025-05-13T15:40:12.938Z","comments":true,"path":"2025/05/10/WPF高级学习/","permalink":"http://example.com/2025/05/10/WPF%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"数据绑定什么是数据绑定DataContext数据上下文Binding（绑定）INotifyPropertyChanged接口ObservableCollection泛型集合IValueConverter转换器IMultiValueConverter多值转换器ValidationRule验证规则样式WPF样式概述Resource资源ResourceDictionary资源字典Trigger触发器MultiTrigger多条件触发器DataTrigger数据触发器MultiDataTrigger 数据触发器EventTrigger事件触发器模板LogicalTree逻辑树VisualTree可视化树ControlTemplate控件模板ControlTemplate的触发器TemplateBinding模板绑定DataTemplate数据模板ItemsPanelTemplate元素模板ListBox的ItemContainerStyleListBox模板样式实战Button的模板样式实战命令什么是命令ICommandSource命令源ICommand接口RoutedUICommand预定义命令CommandBinding命令绑定ApplicationCommands命令实战WPF事件转Command命令Mvvmlight之RelayCommandPrism之DelegateCommandReactiveUI之ReactiveCommand依赖属性什么是依赖属性DependencyProperty定义使用依赖属性的回调函数什么是附加属性PasswordBox与附加属性实战路由事件什么是路由事件路由事件实战什么是附加事件附加事件实战转换什么是Transform转换RotateTransform旋转ScaleTransform缩放SkewTransform倾斜TranslateTransform平移TransformGroup与图片查看器画刷什么是画刷SolidColorBrush纯色画刷LinearGradientBrush渐变画刷RadialGradientBrush径向渐变ImageBrush图像画刷VisualBrush放大镜+水印文字特效DropShadowEffect阴影特效BlurEffect模糊特效动画什么是动画DoubleAnimation动画在C#代码中使用动画","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"WPF - 编程","slug":"WPF-编程","permalink":"http://example.com/tags/WPF-%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"常见面试题","slug":"Face","date":"2025-05-10T10:00:24.000Z","updated":"2025-05-13T15:39:43.747Z","comments":true,"path":"2025/05/10/Face/","permalink":"http://example.com/2025/05/10/Face/","excerpt":"","text":"接口和抽象类区别相同 都可以被继承 都不能被直接实例化 都可以包含方法的声明 不同 接口 抽象类 不能包含成员变量 可以包含成员变量 不能包含构造函数 可以包含构造函数 可以多继承 只能单继承 子类必须实现所有声明的方法 子类必须实现所有的抽象方法(必须是公有的)，普通方法可不实现 方法声明默认public 普通方法可以由其他访问修饰符修饰，抽象方法必须是public，protected 理解接口：功能的定义 抽象类：事物的共性 emp：老鹰类，抽象类：鸟类，接口：飞、吃；歼二十，抽象类：飞机，接口：飞，攻击； 进程和线程进程是资源分配的最小单位，线程是CPU调度的最小单位 进程好比火车，线程好比火车的车厢 区别: 线程在进程下进行，单纯的车厢无法运行 一个进程包含多个线程，一辆火车有多个车厢 不同进程数据难共享，一辆火车乘客难以换到另一辆火车 同进程中不同线程数据易共享，a车厢乘客容易到b车厢 进程更消耗资源 进程之间不会相互影响 内存管理1. 内存管理基础 托管堆 vs 栈 栈：存储值类型（如int, struct）和方法调用上下文（参数、局部变量），由编译器自动分配&#x2F;释放。 托管堆：存储引用类型（如class实例），由垃圾回收器（GC）管理。 例外：值类型可能在堆上分配（如作为类的成员、装箱操作、静态变量）。 引用类型生命周期 对象通过new在堆上分配。 当对象不再被根对象（静态变量、局部变量、CPU寄存器等）引用时，成为垃圾。 2. 垃圾回收（GC）原理 分代回收（Generational GC） 分代策略： 第0代：新对象，GC最频繁（约每1秒）。 第1代：第0代存活的对象，GC频率较低。 第2代：长期存活对象和大对象（LOH），GC频率最低。 晋升机制：对象在GC后未被回收，则晋升到下一代。 GC触发条件 第0代空间不足。 调用GC.Collect()（通常不推荐手动触发）。 系统内存不足。 GC工作流程 标记阶段：从根对象出发，标记所有可达对象。 清理阶段：释放未被标记的对象内存。 压缩阶段（可选）：移动存活对象以减少内存碎片（仅限小对象堆）。 大对象堆（LOH） 存储大对象（如超过85KB的数组）。 不会被压缩，可能产生内存碎片。 单独回收，通常与第2代GC同时进行。 3. 资源释放与Dispose模式 Finalizer（终结器） 用~ClassName定义，由GC调用（时机不确定）。 潜在问题：延迟资源释放，影响性能。 IDisposable接口 核心方法：Dispose()，用于显式释放非托管资源（如文件句柄、数据库连接）。 使用模式： csharp 复制 1234567891011121314151617181920public class Resource : IDisposable &#123; private bool _disposed = false; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); // 避免重复调用Finalizer &#125; protected virtual void Dispose(bool disposing) &#123; if (!_disposed) &#123; if (disposing) &#123; // 释放托管资源 &#125; // 释放非托管资源 _disposed = true; &#125; &#125; ~Resource() =&gt; Dispose(false);&#125; using语句 自动调用Dispose()，确保资源释放： csharp 复制 123using (var resource = new Resource()) &#123; // 使用resource&#125; 4. 高级主题 弱引用（WeakReference） 允许引用对象的同时，允许其被GC回收。 用途：缓存、避免内存泄漏。 示例： csharp 复制 1234var weakRef = new WeakReference(myObject);if (weakRef.IsAlive) &#123; var target = weakRef.Target;&#125; 内存压力（Memory Pressure） 通知GC非托管资源的内存占用： GC.AddMemoryPressure()：提示GC额外内存压力。 GC.RemoveMemoryPressure()：释放后移除压力。 服务器GC vs 工作站GC 工作站GC：优化UI响应（默认客户端应用）。 服务器GC：多线程GC，适合高吞吐量服务端应用（通过.csproj配置）。 5. 常见问题与最佳实践 内存泄漏场景 静态引用：静态集合长期持有对象。 事件未注销：发布者持有订阅者的强引用。 解决方案：使用弱事件模式（如WeakEventManager）。 未释放非托管资源：忘记调用Dispose()。 性能优化 避免频繁分配大对象（尤其是LOH）。 减少装箱操作（如用泛型集合替代ArrayList）。 谨慎使用GC.Collect()，可能破坏分代优化。 诊断工具 Visual Studio诊断工具：内存分析器、CPU分析器。 Windbg&#x2F;SOS：分析堆转储。 dotMemory&#x2F;ANTS Memory Profiler：第三方内存分析工具。 装箱和拆箱1. 基本概念 装箱（Boxing） 将值类型（如int、struct）转换为引用类型（object或接口类型）的过程。 发生场景： 值类型赋值给object或接口变量。 值类型作为参数传递给接受object的方法。 底层行为： 在堆（托管堆）上分配内存，复制值类型数据到堆中。 返回堆上对象的引用。 csharp 复制 12int num = 42;object boxedNum = num; // 装箱 拆箱（Unboxing） 将引用类型（装箱后的对象）转换回原始值类型的过程。 底层行为： 检查目标类型是否与装箱类型一致。 将堆中的值复制到栈（或新的值类型变量）。 csharp 复制 1int unboxedNum = (int)boxedNum; // 拆箱 2. 关键特性 性能开销 装箱：涉及堆内存分配和数据复制，可能触发GC。 拆箱：需要类型检查和数据复制，但无内存分配。 高频操作需谨慎：例如在循环中对值类型频繁装箱。 类型安全 拆箱时必须显式指定目标类型，否则抛出InvalidCastException： csharp 复制 12object boxed = 42;double num = (double)boxed; // 运行时错误 与泛型的关系 泛型（如List&lt;T&gt;）可避免装箱拆箱： csharp 复制 12List&lt;int&gt; list = new List&lt;int&gt;(); // 无装箱list.Add(42); // 直接存储值类型 3. 常见场景与示例 示例1：非泛型集合中的装箱 csharp 复制 123ArrayList list = new ArrayList();list.Add(42); // int装箱为objectint num = (int)list[0]; // 拆箱 示例2：接口转换 csharp 复制 1IFormattable formattable = 10; // int装箱为IFormattable 示例3：错误拆箱 csharp 复制 12object boxed = &quot;123&quot;;int num = (int)boxed; // InvalidCastException 4. 如何避免装箱&#x2F;拆箱 使用泛型集合如List&lt;T&gt;、Dictionary&lt;TKey, TValue&gt;替代ArrayList、Hashtable。 避免不必要的object参数使用泛型方法约束（where T : struct）： csharp 复制 1public void Process&lt;T&gt;(T value) where T : struct &#123; &#125; // 无需装箱 使用Nullable&lt;T&gt;代替object处理可能为null的值类型： csharp 复制 1int? nullableInt = null; // 值类型语义，无需装箱 字符串格式化优化使用$&quot;&quot;或String.Format时，优先调用值类型的ToString()方法（不触发装箱）： csharp 复制 12int num = 42;string s = $&quot;&#123;num&#125;&quot;; // num.ToString()被调用，无装箱 5. 常见问题 GetType()是否需要装箱？ csharp 复制 12int num = 42;Type type = num.GetType(); // 装箱！因为GetType()是object的方法 is和as操作符的拆箱行为 is检查类型时不拆箱： csharp 复制 12object obj = 42;if (obj is int) &#123; &#125; // 检查类型，不拆箱 as操作符不可用于值类型： csharp 复制 12object obj = 42;int? num = obj as int?; // 合法（Nullable&lt;T&gt;） 模式匹配中的拆箱优化 csharp 复制 1if (obj is int num) &#123; &#125; // 安全拆箱，避免重复操作 6. 性能分析工具 IL代码查看使用ildasm或ILSpy查看装箱指令（box和unbox）。 性能分析器 Visual Studio性能分析器（检测堆分配）。 BenchmarkDotNet：测量高频装箱的性能损耗。 总结 装箱&#x2F;拆箱本质：值类型与引用类型间的转换，伴随堆内存分配和性能开销。 优化核心：通过泛型、避免object参数、使用值类型方法（如ToString()）减少操作。 高频场景需警惕：如循环、集合操作和非泛型API调用。 回调函数回调函数本质就是函数参数，也就是把A函数作为B函数的参数传到B函数里使用，那么这个A函数就是回调函数。 在C#中，实现回调的方式是通过委托来实现回调函数。即把A函数赋值给委托，然后把这个委托作为B函数的参数。 委托和事件在 C# 中，委托（Delegate） 是一个非常重要的概念，我们可以用生活中的例子来理解它：委托就像一个”方法容器”，允许你把方法当作参数传递。下面我会用通俗易懂的方式解释你的问题： 一、什么时候用委托？日常使用场景： 事件处理（比如按钮点击） 回调方法（比如异步操作完成后的通知） LINQ 查询（比如 Where 方法中的过滤条件） 策略模式（运行时动态改变算法） 多线程（比如 Thread 的启动方法） 典型需求：当你想把方法当作参数传递，或者需要动态决定调用哪个方法时。 二、委托的好处 解耦：调用方不需要知道具体实现，只需关心方法签名 灵活性：运行时动态改变方法逻辑 代码复用：通用逻辑+可插拔的具体实现 多播：一个委托可以绑定多个方法（+= 操作符） 三、委托 vs 事件 事件本质是封装后的委托，事件是基于 event 关键字修饰的委托实例 安全区别： 委托可以直接被调用（比如 myDelegate()） 事件只能通过 += 和 -= 订阅&#x2F;取消，且只能在声明它的类中触发 设计用途： 委托更通用，用于传递方法 事件专门用于实现发布-订阅模式 四、简单易懂的例子示例 1：基础委托（排序策略）1234567891011121314151617// 1. 定义委托public delegate int CompareDelegate(int a, int b);// 2. 使用委托的方法public void Sort(int[] arr, CompareDelegate compare)&#123; // 使用 compare 方法进行排序...&#125;// 3. 定义具体方法int Ascending(int a, int b) =&gt; a.CompareTo(b);int Descending(int a, int b) =&gt; b.CompareTo(a);// 4. 使用var arr = new int[] &#123; 3, 1, 4 &#125;;Sort(arr, Ascending); // 升序Sort(arr, Descending); // 降序 示例 2：事件（按钮点击）123456789101112131415161718// 1. 定义委托（实际开发中常用 EventHandler）public delegate void ClickEventHandler();// 2. 按钮类public class Button&#123; public event ClickEventHandler Clicked; // 事件 public void Press() &#123; Clicked?.Invoke(); // 只能在 Button 类内部触发 &#125;&#125;// 3. 使用var button = new Button();button.Clicked += () =&gt; Console.WriteLine(&quot;按钮被点了！&quot;);button.Press(); // 输出提示 五、关键总结 特性 委托 事件 直接调用 ✔️ (myDelegate()) ❌ 只能在声明类中触发 外部订阅 ✔️ ✔️ (+=&#x2F;-= 操作符) 多播支持 ✔️ ✔️ 典型用途 传递方法、回调 实现发布-订阅模式 实际开发建议：优先使用事件来实现通知机制，用委托来实现需要灵活传递方法的场景。在 GUI 编程（如 WPF&#x2F;WinForms）和异步编程（如 Task）中，委托和事件无处不在。 异步编程","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"CSharp学习","slug":"CSharp学习","date":"2025-05-10T10:00:24.000Z","updated":"2025-05-12T13:14:24.323Z","comments":true,"path":"2025/05/10/CSharp学习/","permalink":"http://example.com/2025/05/10/CSharp%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"反射反射是指在程序运行中，查看、操作其他程序集或者自身的元数据的各种信息（类、函数、变量、对象等）的行为。C#中的反射（Reflection）是一种强大的特性，允许你在运行时检查和操作程序集、类型和对象的信息，基本上，使用反射可以在代码运行时检查和操作指定的类及其成员。C#反射的原理主要基于元数据（与C#特性相似），即程序集中存储的有关类型、方法等的信息。 C#反射技术主要基于System.Type类和System.Reflection.Assemble类，通过Type类可以访问关于任何数据类型的信息，Assemble类用于访问给定程序集的相关信息，或把这个程序集加载到程序中。 反射的使用因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性 一.System.Type类Type类是一个抽象类。只要实例化了一个Type对象，实际上就实例化了Type的一个派生类。尽管一般情况下派生类只提供各种Type方法和属性的不同重载，但是这些方法和属性返回对应数据类型的正确数据，Type有与每种数据类型对应的派生类。它们一般不添加新的方法或属性通常，获取指向任何给定的Type引用有三种常用方式： 使用typeof运算符，这个运算符的参数是类型的名称，但不放在引号中： 1Type t =typeof(double); 使用GetType()方法，所以类都会从System.Object继承这个方法： 12double d =10;Type t = d.GetType(); 在一个变量上调用GetType()方法，返回的Type对象只与该数据类型相关，不包含该类型实例的任何信息。 调用Type类的静态方法GetType()： 1Type t =Type.GetType(&quot;System.Double&quot;); Type是很多反射功能的入口，它实现很多方法和属性，可用的属性都是只读的：可以使用Type确定数据的类型，但不能使用它修改该类型。 Type属性由Type实现的属性分为3类。 *包含与类相关的各种名称的字符串： Name：数据类型名 FullName：数据类型的完全限定名（包含名称空间） Namespace：在其中定义数据类型的名称空间名 *获取Type对象的引用的属性： BaseType：该对象的直接基本类型 UnderlyingSystemType：该Type在.NET运行库中映射到的类型 *布尔属性 IsAbstract，IsArray,IsClass,IsEnum等判断Type是什么类型的属性。 Type方法System.Type的大多数方法都用于获取对应数据类型的成员信息：构造函数，属性，方法和事件等。它有许多方法，但它们都有相同的模式。例如，获取数据类型的方法的信息：GetMethod()和GetMethods()。GetMethod()方法返回MethodInfo对象的一个引用，其中包含一个指定方法的细节信息；而GetMethods()返回这种引用的一个数组。 二.ActivatorActivator（快速实例化对象的类）用于将Type对象快捷实例化为对象 12345678static void Main(string[] args)&#123; Type t = typeof(Test); // 无参构造 Test test = Activator.CreateInstance(t) as Test; // 有参构造 test = Activator.CreateInstance(t, 99) as Test;&#125; 三.Assembly类相关概念主要用来加载其他程序集，加载后才能用Type来使用其他程序集中的信息，如果想要使用不是自己程序集中的内容，需要先加载程序集。 dll文件（库文件）可以简单的把库文件看成一种代码仓库 在C#中，程序集可以以DLL或EXE文件形式存储，并可以通过反射API在运行时加载和操作，其中包含了编译后的代码和元数据。程序集通常需要在运行时被加载，以便在应用程序中使用其中定义的类型和成员。 程序集在运行时的加载可以发生在两种不同的上下文中，分别是： 上下文中解析（Contextual Resolve）：这是程序集加载的一种默认行为，其中.NET运行时会尝试根据程序集的引用和依赖关系来自动解析和加载程序集。当你在代码中引用一个程序集，并且它有其他依赖的程序集，运行时会自动查找和加载这些依赖的程序集，以便构建完整的程序集树。 特定路径加载（LoadFrom）：LoadFrom方法允许你显式指定程序集的路径，而不依赖于运行时上下文进行解析。你可以使用Assembly.LoadFrom方法来加载程序集，提供程序集的完整文件路径作为参数。这种方式适用于需要加载特定位置的程序集，而不需要考虑运行时上下文中的解析。 加载方法 1.Assembly.Load： 当使用Assembly.Load时，参数是程序集的显示名称（可以包含长名称、版本、文化和公共密钥令牌信息）。此方法将在应用程序域的上下文中查找和加载程序集。如果程序集已经被加载，则将返回现有的程序集引用。Load方法最适合在已知需要加载程序集的完整名称的情况下使用。 1Assembly assembly = Assembly.Load(&quot;System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;); 2.Assembly.LoadFrom： 使用 Assembly.LoadFrom 时，参数是包含程序集文件的路径。此方法将从指定路径加载程序集，并在包含目录下解析其依赖项。注意，这可能会导致同一个程序集被多次加载，例如，当相同的程序集位于不同的目录时。LoadFrom适用于需要从特定路径加载程序集，而不必在上下文中解析的情况。 1Assembly assembly = Assembly.LoadFrom(@&quot;C:\\MyAssemblies\\MyAssembly.dll&quot;); 3.Assembly.LoadFile： Assembly.LoadFile 与 Assembly.LoadFrom 类似，因为它需要一个包含程序集文件的路径作为参数。然而，LoadFile 在加载程序集时不会将其添加到上下文中，也不会解析其依赖项。这意味着，如果程序集具有未解析的依赖项，可能会在运行时出现问题。LoadFile 在只需要检查程序集信息而无需实际执行代码的场景下非常有用。 1Assembly assembly = Assembly.LoadFile(@&quot;C:\\MyAssemblies\\MyAssembly.dll&quot;); 然后就可以通过assembly1.GetType();传入带命名空间的类名获取程序集下的指定类的类信息 特性一、特性是什么1、特性定义**特性（Attribute）**是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。 特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：预定义特性和自定义特性。 2、特性的语法特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。positional_parameters 规定必需的信息，name_parameter 规定可选的信息。 12[attribute(positional_parameters, name_parameter = value, ...)]element 3、特性和注释有什么区别特性很厉害，加了特性之后，就有很厉害的功能[Obsolete]编译时就有提示，影响了编译器[Obsolete(“请不要使用这个了，请使用什么来代替”, true)]甚至导致编译报错[Serializable]对象就可以序列化，影响了程序运行 123456789101112131415161718192021222324252627using System;namespace MyAttribute&#123; /// &lt;summary&gt; /// 这里是注释，除了让人看懂这里写的是什么，对运行没有任何影响 /// &lt;/summary&gt; ///[Obsolete(&quot;请不要使用这个了，请使用什么来代替&quot;)]//对编译都产生了影响，编译出现警告 ///[Obsolete(&quot;请不要使用这个了，请使用什么来代替&quot;, true)]//对编译都产生了影响，编译报错不通过 [Serializable]//可以序列化和反序列化 public class Student &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public void Study() &#123; Console.WriteLine($&quot;这里是&#123;this.Name&#125;在学习&quot;); &#125; public string Answer([Custom]string name) &#123; return $&quot;This is &#123;name&#125;&quot;; &#125; &#125;&#125; 特性无处不在：EF–MVC–WCF–WebService–UnitTest–IOC–AOP–SuperSocket 二、特性声明和使用1、什么是特性特性其实就是一个类，直接或间接继承自Attribute 123456789101112131415161718192021222324252627282930313233#region 程序集 mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089// C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\mscorlib.dll// Decompiled with ICSharpCode.Decompiler 6.1.0.5902#endregionusing System.Reflection;using System.Runtime.InteropServices;namespace System&#123; [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Delegate, Inherited = false)] [ComVisible(true)] public sealed class SerializableAttribute : Attribute &#123; internal static Attribute GetCustomAttribute(RuntimeType type) &#123; if ((type.Attributes &amp; TypeAttributes.Serializable) != TypeAttributes.Serializable) &#123; return null; &#125; return new SerializableAttribute(); &#125; internal static bool IsDefined(RuntimeType type) &#123; return type.IsSerializable; &#125; &#125;&#125;#if false // 反编译日志缓存中的 9 项#endif 属性更改通知123456789101112131415161718192021222324public class ViewModelBase : INotifyPropertyChanged&#123; public event EventHandler&lt;PropertyChangedExtendedEventArgs&gt; PropertyChangedExtended; public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged(object oldValue, object newValue,[CallerMemberName] string propertyName=&quot;&quot;) &#123; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); PropertyChangedExtended?.Invoke(this, new PropertyChangedExtendedEventArgs(propertyName, oldValue, newValue)); &#125;&#125;public class PropertyChangedExtendedEventArgs : PropertyChangedEventArgs&#123; public object OldValue &#123; get; &#125; public object NewValue &#123; get; &#125; public PropertyChangedExtendedEventArgs(string propertyName, object oldValue, object newValue) : base(propertyName) &#123; OldValue = oldValue; NewValue = newValue; &#125;&#125; 1234567891011121314151617181920212223public class Book : ViewModelBase&#123; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; var oldValue = name; name = value; OnPropertyChanged(oldValue, value); &#125; &#125; private string author; public string Author &#123; get &#123; return author; &#125; set &#123; var oldValue = author; author = value; OnPropertyChanged(oldValue,value); &#125; &#125;&#125; 委托C# 委托（Delegate）是一种类型安全的函数指针，它是 .NET Framework 中一种重要的编程概念，用于封装方法的引用。委托允许你将方法作为参数传递给其他方法，注册事件处理器，实现回调机制，以及在异步编程和多线程编程中扮演关键角色。以下是关于 C# 委托的详细介绍： 委托是 C# 语言中的一个特色，通常将委托分为命名方法委托、多播委托、匿名委托，其中命名方法委托是使用最多的一种委托。 在 C#语言中命名方法委托是最常用的一种委托，其定义的语法形式如下。 1修饰符 delegate 返回值类型 委托名 ( 参数列表 ); 从上面的定义可以看出，委托的定义与方法的定义是相似的。例如定义一个不带参数的委托，代码如下。 1public delegate void MyDelegate(); 在定义好委托后就到了实例化委托的步骤，命名方法委托在实例化委托时必须带入方法的具体名称。 实例化委托的语法形式如下。 1委托名 委托对象名 = new 委托名 ( 方法名 ); 委托中传递的方法名既可以是静态方法的名称，也可以是实例方法的名称。 需要注意的是，在委托中所写的方法名必须与委托定义时的返回值类型和参数列表相同。 在实例化委托后即可调用委托，语法形式如下。 1委托对象名 ( 参数列表 ); （1）委托可以声明在类外部，也可以在类内部 （2）跟方法有点类似，有参数，返回值，访问修饰符，比方法声明多一个关键字delegate 123456789101112131415161718192021222324252627282930313233namespace MyDelegate&#123; /// &lt;summary&gt; /// 1.无参数无返回值委托 /// &lt;/summary&gt; public delegate void NoReturnNoParaOutClass(); public class CustomDelegate &#123; /// &lt;summary&gt; /// 2.无参数无返回值委托 /// &lt;/summary&gt; public delegate void NoReturnNoPara(); /// &lt;summary&gt; /// 3.有参数无返回值委托 /// &lt;/summary&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; public delegate void NoReturnWithPara(int x, int y); /// &lt;summary&gt; /// 4.无参数有返回值的委托 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public delegate int WithReturnNoPara(); /// &lt;summary&gt; /// 5.带参数带返回值的委托 /// &lt;/summary&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public delegate int WithReturnWithPara(out int x, ref int y); &#125;&#125; （1）委托是一个类，继承自MulticastDelegate MulticastDelegate这个类我们自己定义的类是无法继承的 （2）委托的构造函数，需要传递一个方法作为参数 （3）委托的内部有三个方法Invoke，BeginInvoke，EndInvoke 二、委托实例化和执行 1、委托实例化 （1）通过New来实例化 （2）直接&#x3D;一个方法，这个是编译器提供的语法糖 （3）直接&#x3D;一个匿名委托 （4）直接&#x3D;一个Lambda 2、委托执行（1）Inovke执行委托 如果委托定义没有参数，则Inovke也没有参数；委托没有返回值，则Inovke也没有返回值 （2）BeginInvoke开启一个新线程执行委托 NetCore不支持，NetFamework支持 NetCore有更好的多线程功能来支持实现类似功能 （3）EndInvoke等待BeginInvoke执行完成后再执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System;namespace MyDelegate&#123; public class CustomDelegateShow &#123; public static void Show() &#123; //1、委托实例化 //（1）通过New来实例化，要求传递一个和这个委托的参数和返回值完全匹配的方法 NoReturnNoParaOutClass noReturnNoParaOutClass = new NoReturnNoParaOutClass(NoReturnNoParaMehtod); //（2）直接=一个方法，要求方法和这个委托的参数和返回值完全匹配，这个是编译器提供的语法糖 NoReturnNoParaOutClass noReturnNoParaOutClass2 = NoReturnNoParaMehtod; //（3）直接=一个匿名委托，要求和这个委托的参数和返回值完全匹配 NoReturnNoParaOutClass noReturnNoParaOutClass3 = delegate () &#123; Console.WriteLine(&quot;这是一个无参数无返回值的方法。。。&quot;); &#125;; //（4）直接=一个Lambda，要求和这个委托的参数和返回值完全匹配 NoReturnNoParaOutClass noReturnNoParaOutClass4 = ()=&gt; &#123; Console.WriteLine(&quot;这是一个无参数无返回值的方法。。。&quot;); &#125;; //无参无返回值委托实例化 CustomDelegate.NoReturnNoPara noReturnNoPara = NoReturnNoParaMehtod; //带参数无返回值委托实例化 CustomDelegate.NoReturnWithPara noReturnWithPara = NoReturnWithParaMehtod; //无参数带返回值委托实例化 CustomDelegate.WithReturnNoPara withReturnNoPara = WithReturnNoParaMehtod; //带参数带返回值委托实例化 CustomDelegate.WithReturnWithPara withReturnWithPara = WithReturnWithParaMehtod; //2、委托执行 //（1）Inovke执行方法，如果委托定义没有参数，则Inovke也没有参数；委托没有返回值，则Inovke也没有返回值 noReturnNoParaOutClass.Invoke(); //（2）BeginInvoke开启一个新的线程去执行委托 //NetCore不支持，NetFamework支持 NetCore有更好的多线程功能来支持实现类似功能 //noReturnNoParaOutClass.BeginInvoke((a) =&gt; Console.WriteLine(&quot;方法调用结束。。。&quot;), null); //（3）EndInvoke等待BeginInvoke方法执行完成后再执行EndInvoke后面的代码 //NetCore不支持，NetFamework支持 NetCore有更好的多线程功能来支持实现类似功能 //noReturnNoParaOutClass.EndInvoke(null); //无参无返回值委托执行 noReturnNoPara.Invoke(); //带参数无返回值委托执行 noReturnWithPara.Invoke(1,2); //无参数带返回值委托执行 int result=withReturnNoPara.Invoke(); //带参数带返回值委托执行 int x = 1; int y = 1; int result2 = withReturnWithPara.Invoke(out x, ref y); &#125; private static void NoReturnNoParaMehtod() &#123; Console.WriteLine(&quot;这是一个无参数无返回值的方法。。。&quot;); &#125; private static void NoReturnWithParaMehtod(int x, int y) &#123; Console.WriteLine($&quot;这是一个带参数无返回值的方法。。。&quot;); &#125; private static int WithReturnNoParaMehtod() &#123; Console.WriteLine($&quot;这是一个无参数带返回值的方法。。。&quot;); return default(int); &#125; private static int WithReturnWithParaMehtod(out int x, ref int y) &#123; Console.WriteLine($&quot;这是一个带参数带返回值的方法。。。&quot;); x = 1; return default(int); &#125; &#125;&#125; 框架内置委托Action&#x2F;Func是.NET Framework3.0时代的产物 1、Action（1）Action是来自于System.RunTime的一个声明好的可以带有一个或者多个参数无返回值的委托（2）最多支持16个入参，正常使用足够 12Action action = new Action(NoreturnNopara);Action&lt;int&gt; action1 = new Action&lt;int&gt;(DoNothingInt); （3）想要支持更多的参数呢，可以自己定义 &#x2F;&#x2F;参数不够自己定义 12//参数不够自己定义public delegate void Action&lt;in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16, in T17&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17); 2、Func（1）Func是来自于System.RunTime的一个声明好有返回值的委托，也可以有参数（2）如果既然有参数也有返回值，前面是输入参数类型，最后面的作为返回值类型（3）最多支持16个入参，正常足够使用 123Func&lt;int&gt; func = new Func&lt;int&gt;(ReturnNopara);Func&lt;int, int&gt; func1 = new Func&lt;int, int&gt;(ToInt);Func&lt;int, string, int&gt; func2 = new Func&lt;int, string, int&gt;(DoNothingIntAndStringNew); （4）想要支持更多的参数呢，可以自己定义 12//参数不够自己定义public delegate TResult Func&lt;in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16, in T17, out TResult&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17); 3、为什么要用框架内置委托（1）委托的本质是类，定义多个委托，其实就是新增了多个类，定义好的两个委托参数和返回值都是一致的，但是因为是不同的类，没有继承不能通用（2）既然是系统框架给我们定义好了这两个委托，自然是希望我们在以后的开发中，都去使用这两个委托，这样就可以把委托类型做到统一（3）那之前定义好的委托是去不掉的，这被称之为历史包袱 https://www.cnblogs.com/guoqiang1/p/8138889.html https://blog.csdn.net/wenchm/article/details/134553445 另：（十月的寒流） 作用 1、将函数作为函数的参数进行传递（回调函数、LINQ） 2、基于委托生成事件（声明事件并用来注册） （按钮） 123强类型委托Action&lt;T1&gt;Func&lt;T1,TResult&gt; 注意: 调用委托时，如果其中的一个委托报错，则后面的不会被调用 只有最后一个的返回值才会作为委托的返回值 因为是数组，所以 remove 的复杂度是O(n) 线程不安全 委托为什么不等于函数指针 委托可以”指向”多个函数 委托可以指向同一个函数多次 函数是包含在类中的，所以函数引用也包含了所在对象的信息;而C&#x2F;c++的函数指针只是函数的入口地址 异步调用 BeginInvoke EndInvoke Covariance&amp; Contravariance Predicate 返回值是bool 为什么不使用接口 使用接口非常不灵活，比如使用LINQ，要频繁传入各种形式的函数，且必须有类去实现接口 传接口对象其实说自了是在传类的引用，那么就有可能会将类的其他公共成员也暴露出来，引起不必要的麻 无法使用多播委托与事件提供的各种功能，比如添加与删除 类的方法是封装好的，而使用匿名委托可以随处声明，并使用当前作用域可访问的所有变量 内置的强类型委托等充分提供了各种常见形式的委托类型，没有必要自己写大量接口 事件另：（十月的寒流） 希望一个类的某些成员在发生变化时候能够被外界观测到 CollectionChanged TextChanged 标准.Net事件模式 1234delegate EventHandler(object sender,EventArgs e)EventArgsButton.ClickTextbox.TextChanged 推荐的命名规范 名词+动词（被动） 123456CollectionChangedEventRaisedPropertyChangedOnEventRaisedOnpropertyChangedRaisePropertyChange 事件说白了是C#提供的语法糖，效果是 将委托以私有变量的形式封装在类内，不让外面访问 对于委托进行了封装，从而定义add 与remove 方法 在add 与 remove 中通过互锁的方式提供了线程安全性 依赖属性is out refasync awitLinqSelectSelectMany用于将每个元素投影为一个序列，然后“平展”这些序列，将它们合并为一个序列。（用于将多个序列合并为一个序列。） SelectMany 有几个重载版本，最常用的版本接受两个参数： 一个转换函数，它接受一个源序列中的元素，并返回一个新序列（通常是一个 IEnumerable&lt;T&gt; 类型的序列）。 一个结果选择函数，它接受转换函数返回的序列中的每个元素，并返回最终结果中的元素。 下面是一个简单的 SelectMany 示例： 12345678910111213141516171819202122using System;using System.Collections.Generic;using System.Linq;class Program&#123; static void Main() &#123; int[][] numbers = &#123; new int[] &#123;1, 2, 3&#125;, new int[] &#123;4, 5, 6&#125;, new int[] &#123;7, 8, 9&#125; &#125;; var flattened = numbers.SelectMany(arr =&gt; arr); foreach (var num in flattened) &#123; Console.WriteLine(num); &#125; &#125;&#125; 在这个示例中，我们有一个二维整数数组 numbers。我们使用 SelectMany 来“平展”这个数组，将其转换为一个一维整数数组。转换函数 arr =&gt; arr 接受每个内部数组 arr，并直接返回它，这样 SelectMany 就会将所有内部数组合并为一个数组。 SelectMany 也可以用于更复杂的场景，例如，当你有一个对象数组，每个对象都有一个子对象集合，你可以使用 SelectMany 来获取所有子对象的列表。 下面是一个更复杂的示例： 123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.Linq;class Program&#123; static void Main() &#123; var customers = new List&lt;Customer&gt; &#123; new Customer &#123; Name = &quot;Customer A&quot;, Orders = new List&lt;Order&gt; &#123; new Order &#123; OrderId = 1 &#125;, new Order &#123; OrderId = 2 &#125; &#125;&#125;, new Customer &#123; Name = &quot;Customer B&quot;, Orders = new List&lt;Order&gt; &#123; new Order &#123; OrderId = 3 &#125;, new Order &#123; OrderId = 4 &#125; &#125;&#125; &#125;; var allOrders = customers.SelectMany(c =&gt; c.Orders); foreach (var order in allOrders) &#123; Console.WriteLine($&quot;Order ID: &#123;order.OrderId&#125;&quot;); &#125; &#125;&#125;class Customer&#123; public string Name &#123; get; set; &#125; public List&lt;Order&gt; Orders &#123; get; set; &#125;&#125;class Order&#123; public int OrderId &#123; get; set; &#125;&#125; 在这个示例中，我们有一个 Customer 对象的列表，每个 Customer 都有一个 Orders 集合。我们使用 SelectMany 来获取所有 Order 对象的列表，而不是分别对每个 Customer 的 Orders 集合进行操作。 如果你的目标是创建一个新序列，其中包含对源序列中每个元素进行一对一转换的结果，使用 Select。 如果你的目标是创建一个新序列，其中包含对源序列中每个元素进行一对多转换的结果，并且需要将这些结果“平铺”成一个单一序列，使用 SelectMany。 WhereWhere 方法接受一个返回布尔值的委托（通常是一个lambda表达式），并且返回一个新序列，其中只包含满足该条件的元素。 下面是一个使用 Where 方法的基本示例： 12345678910111213141516171819using System;using System.Linq;public class Program&#123; public static void Main() &#123; int[] numbers = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; // 使用Where方法筛选出偶数 var evenNumbers = numbers.Where(n =&gt; n % 2 == 0); Console.WriteLine(&quot;Even numbers:&quot;); foreach (var number in evenNumbers) &#123; Console.WriteLine(number); &#125; &#125;&#125; 在这个例子中，Where 方法用于筛选出数组 numbers 中的偶数。Lambda表达式 n =&gt; n % 2 == 0 定义了筛选条件，即选择那些除以2余数为0的整数。 Where 方法不会改变原始数据集合，而是创建一个新的序列，包含满足条件的元素。这个新序列是一个 IEnumerable&lt;T&gt; 类型，你可以使用 foreach 循环来遍历它，或者将其转换成其他集合类型，如 List&lt;T&gt; 或 Array。 Where 方法可以与其他LINQ方法结合使用，以构建更复杂的查询。例如，你可以先使用 Where 筛选数据，然后使用 OrderBy 对结果进行排序，或者使用 Select 对结果进行投影（转换）。 12345678var evenNumbersSorted = numbers .Where(n =&gt; n % 2 == 0) // 筛选出偶数 .OrderBy(n =&gt; n); // 按升序排序foreach (var number in evenNumbersSorted)&#123; Console.WriteLine(number);&#125; 在这个例子中，我们先筛选出偶数，然后对这些偶数进行排序。 Aggregate在 C# 中，Aggregate 方法是 LINQ（语言集成查询）的一部分，它用于对一个集合中的所有元素应用一个累积函数。这个方法可以用来执行各种操作，比如计算总和、平均值、连接字符串等。 Aggregate 方法的基本语法如下： 1result = source.Aggregate(func); 其中 source 是一个集合，func 是一个累积函数，它定义了如何处理每个元素以及如何累积结果。 累积函数 func 可以接受两个参数： 累积状态（通常称为 accumulator 或 s）：这是累积过程的中间结果。 当前元素（通常称为 element 或 x）：这是集合中当前正在处理的元素。 Aggregate 方法也可以接受一个种子值作为初始累积状态，这在某些情况下非常有用。 下面是一个简单的例子，用于计算一个整数列表的总和： 123List&lt;int&gt; numbers = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5 &#125;;int sum = numbers.Aggregate(0, (s, x) =&gt; s + x);Console.WriteLine(sum); // 输出 15 在这个例子中，0 是种子值，累积函数 (s, x) =&gt; s + x 定义了如何将每个元素累加到累积状态上。 Aggregate 方法也可以用来创建复杂的数据结构，比如连接字符串列表： 123List&lt;string&gt; words = new List&lt;string&gt; &#123; &quot;Hello&quot;, &quot;world&quot;, &quot;!&quot; &#125;;string sentence = words.Aggregate((s, x) =&gt; s + &quot; &quot; + x);Console.WriteLine(sentence); // 输出 &quot;Hello world !&quot; 在这个例子中，累积函数 (s, x) =&gt; s + &quot; &quot; + x 定义了如何将每个字符串连接到累积状态上，初始累积状态是列表的第一个元素。 Aggregate 方法非常灵活，可以根据需要定义复杂的累积逻辑。它是对集合进行迭代和累积操作的有力工具。 Z-score(Z评分法)Z评分法（Z-score）是一种统计学上的概念，用于表示一个数值相对于整个数据集的平均值的标准差数目。在统计学中，Z分数（Z-score）能够告诉我们一个给定的数据点距离平均值有多远，通过用标准差来表示这个距离。一个数据的Z分数告诉我们它是在平均值之上还是之下，以及它与平均值的距离有多远。 Z评分法的计算公式是：Z&#x3D;(X−μ) &#x2F; σ X 是观测值 \\mu：μ 是平均值（均值） \\sigma：σ 是标准差 在应用中，Z评分法常用于： 标准化：将不同分布的数据转换为标准正态分布，便于比较。 排名和比较：在教育、医学等领域的测试成绩，可以通过Z分数进行比较。 异常值检测：在数据分析中，Z分数可以帮助识别数据集中的异常值或离群点。 σ（标准差）标准差（Standard Deviation，缩写为SD或σ）是统计学中衡量一组数值离散程度的一种度量。它描述的是数据分布的宽度，或者说是数据分布的离散程度。标准差越大，表示数据的波动越大，数据分布越分散；标准差越小，表示数据的波动越小，数据分布越集中。 对于一组数据，标准差计算的基本步骤如下： 计算平均值（均值）μ。 求每个数值与平均值的差的平方。 计算这些平方差的平均值，即方差σ²。 计算方差的平方根，得到标准差σ。 用数学公式表示，标准差的计算过程是： CP和CPKCP（Capability Index，能力指数）和CPK（Capability Process Index，过程能力指数）是质量管理中的两个常用指标，用来衡量一个生产过程是否能够满足产品规格的要求。通俗地说，CP和CPK就是在说一个生产过程做出来的产品质量怎么样，是不是很稳定，能不能做到大多数产品都在标准范围内。 CP（能力指数）：这个指标主要是看生产出来的产品特性值分布的宽度是否在规格允许的范围之内。CP值越大，说明产品的质量越稳定，大部分的产品都集中在规格中心附近。如果CP值小，那么产品质量就可能比较分散，有些产品可能会超出规格。 CPK（过程能力指数）：这个指标不仅考虑了产品特性值的分布宽度，还考虑了这个分布的中心位置是否偏离了规格的中心。CPK值越大，表示生产过程不仅产品质量分布窄，而且中心位置也控制得很好，几乎没有偏离。如果CPK值小，说明生产过程可能存在问题，导致产品质量不稳定或者偏离规格中心。举个例子，就像射击靶心一样，CP值高就像所有的子弹都打在了靶子上，但可能没有全部集中在靶心；而CPK值高则意味着子弹不仅都打在了靶子上，而且还非常集中地打在了靶心。两者都高，说明射手既有很好的准确度，也有很好的稳定性。 补偿值CavityData(腔体数据) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/// &lt;summary&gt;/// 腔体数据/// &lt;/summary&gt;public class CavityData&#123; // 通过索引获取注液泵数据 public InjectorPumpData this[int index] &#123; get &#123; return InjectorPumpDatas[index]; &#125; &#125; public int CavitySerialNumber &#123; get; private set; &#125; /// &lt;summary&gt; /// 注液泵数据集合 /// &lt;/summary&gt; public List&lt;InjectorPumpData&gt; InjectorPumpDatas &#123; get; private set; &#125; /// &lt;summary&gt; /// 初始化腔体数据结构 /// &lt;/summary&gt; /// &lt;param name=&quot;needleCount&quot;&gt;针头个数&lt;/param&gt; public CavityData(int CavitySerialNumber, int injectorPumpCount, int[] needleCount) &#123; //4-24修改 this.CavitySerialNumber = CavitySerialNumber; InjectorPumpDatas = new List&lt;InjectorPumpData&gt;(); for (int i = 0; i &lt; injectorPumpCount; i++) &#123; InjectorPumpDatas.Add(new InjectorPumpData(this.CavitySerialNumber, i, needleCount)); &#125; &#125; /// &lt;summary&gt; /// 添加数据 /// &lt;/summary&gt; public void Add(int injectorPumpSerialNumber, int needleSerialNumber, double infusionVolume) &#123; InjectorPumpDatas[injectorPumpSerialNumber].Add(needleSerialNumber, infusionVolume); &#125; /// &lt;summary&gt; /// 添加注液针补偿数据 /// &lt;/summary&gt; public void AddCompensation(int injectorPumpSerialNumber, int needleSerialNumber, double compensation) &#123; InjectorPumpDatas[injectorPumpSerialNumber].AddCompensation(needleSerialNumber, compensation); &#125; /// &lt;summary&gt; /// 添加数据 /// &lt;/summary&gt; public void AddRange(int injectorPumpSerialNumber, int needleSerialNumber, IEnumerable&lt;double&gt; infusionVolume) &#123; InjectorPumpDatas[injectorPumpSerialNumber].AddRange(needleSerialNumber, infusionVolume); &#125; /// &lt;summary&gt; /// 清空 /// &lt;/summary&gt; public void Clear() &#123; foreach (var injectorPumpData in InjectorPumpDatas) &#123; injectorPumpData.Clear(); &#125; &#125;&#125; 保有量：二注后称 减去 一注前称 注液差：下料称重时，计算注液针灌入量误差。应灌注量-实际灌注量 数据集A：灌注量误差和注液针补偿缓存 数据集B：提取注液针补偿值与当前注液针补偿值相等的最后连续n个数据，写入PLC地址 数据集C：通过计算集合B的平均值和标准差，结合Z评分法剔除异常点得到集合C（Z分法需要一个阈值，这个阈值开放）；通过指数加权移动平均（这里有个平缓系数，也会开放），计算数据集C的注液针灌入量误差的平均值mean；计算新的注液针补偿值，注液针补偿&#x3D;当前注液针补偿+mean（当前注液针补偿通过plc获取） &#x2F;&#x2F;应灌注量：1.733 实际:1.741 误差0.008 当前补偿值0 数据集A：0+0.008 12345//应灌注量 1.733 4.78()//实际灌注量 1.741=》1.740//对应补偿值 -0.001//误差 1.733-1.741 = -0.008//理论补偿 = -0.001+(-0.008) = -0.009 1234567891011121314151617181920动态注液针补偿逻辑 PLC端:1 PLC开放注液针补偿地址，这些地址里面的值只能上位机更改，同时触摸屏实时显示2 注液前，PLC先把相应注液针补偿地址里面的值搬运到临时地址 (防止 PLC把注液针补偿写给注液泵后，上位机更新了教值，导致随电芯搬运的注液针补偿值和实际的补偿值不一致)，然后把这个补偿当作当前电芯的注液针补偿值，并一起搬运到下料3. 注液前后，注液针补偿值随电芯搬运到下料称重处 上位机端:1、下料称重，计算注液针灌入量误差，注液针灌入量误差=应灌入量-实际灌入量2. 读取当前电芯的注液针补偿值，将注液针灌入量误差和注液针补偿值缓存起来，作为数据集A3. 每下料一个电芯，查询数据集A，把注液针补偿值与当前注液针补偿值相等的最后连续n个数据提取出来，作为数据集B.并通过数据集B 的注液针灌入量误差计算新的注液针补偿值，如果新的注液针补偿值在设定的范围内，写给PLC对应的地址 把注液针补偿值与当前注液针补偿值相等的最后连续n个数据提取出来。这里不太对，应该是不论补偿值是否相等，都提取出来，然后根据每对“注液针灌入量误差和注液针补偿值”计算出一个“理论补偿值”，一共计算出n个，形成数据集，然后用这个数据集来做EWMA计算最终的，也就是当前的“理论补偿值”，并写入PLC。否则的话你打开自动调整，他会连续不停的调整补偿值，你很难得到包含n个不变的注液针补偿值的数据集 计算注液针补偿值:1. 通过计算数据集B的平均值和标准差，并结合Z分法来别除异常点,得到数据集C(Z分法需要一个负值，这个负值开放)2. 通过指数加权移动平均(这里有个平缓系数，也会开放)，计算数据集C的注液针灌入量误差的平均值mean3. 计算新的注液针补偿值,注液针补偿=当前注液针补偿+mean(当前注液针补偿通过PLC对用的地址读取》 对应PC补偿值：实际那根针的补偿值，PLC给出对应PC补偿值 当前PC补偿值：下料时候读取，看看是否人为修改了 理论PC补偿值：（？理论上应该补偿多少）对应PC补偿值+注液差 计算PC补偿值：（？通过算法计算出） 动态补偿值计算权重：0.1 动态补偿值异常因子：1.5 自定义控件Visual Tree和Logical Tree（可视化树和逻辑树）https://www.cnblogs.com/jellochen/p/3439903.html 在WPF中，用户界面是由XAML来呈现的。粗略地讲，从宏观上看，叶子为布局组件和控件所组成的树既是逻辑树，从微观上看，将逻辑树的叶子再放大可看到其内部是由可视化组件（继承自Visual类）组成的，叶子为这些可视化组件组成的树既是可视树。 当然，让我们更详细地探讨WPF中的逻辑树和可视化树。 逻辑树逻辑树是基于对象的层次结构，它反映了元素的父子关系和内容属性。在逻辑树中，每个节点都是一个继承自FrameworkElement或FrameworkContentElement的元素。逻辑树主要用于以下目的： 数据绑定：逻辑树用于确定数据绑定的范围和上下文。 样式继承：样式可以从父元素继承到子元素，逻辑树定义了这种继承的路径。 资源查找：当元素请求资源时，WPF会在逻辑树中向上查找，以找到定义的资源。 事件路由：逻辑树用于确定事件如何在不同元素之间传递，包括冒泡事件和隧道事件。逻辑树的构建通常是通过XAML文件中定义的元素和内容属性来完成的。例如，如果你在XAML中定义了一个Grid，里面包含了一个Button，那么Grid将是Button的父元素，在逻辑树中Button将是Grid的子节点。 可视化树可视化树是一个更详细的层次结构，它包含了逻辑树中的所有元素，以及为了渲染和布局目的而添加的其他可视化对象。可视化树的每个节点都是一个继承自Visual或Visual3D的对象。可视化树主要用于以下目的： 布局：可视化树用于计算元素的大小和位置，以及如何对它们进行布局。 渲染：WPF渲染引擎使用可视化树来确定如何在屏幕上绘制元素。 输入处理：可视化树用于确定哪些元素接收输入，如鼠标点击和键盘输入。可视化树的构建是基于逻辑树，但比逻辑树更复杂。例如，一个简单的Button可能在可视化树中包含多个子节点，如Border、ContentPresenter和其他用于渲染按钮外观的元素。这些额外的可视化对象不会出现在逻辑树中。 两者之间的关系逻辑树和可视化树是紧密相关的。每个逻辑树节点至少在可视化树中有一个对应的节点，但可视化树可能包含逻辑树中没有的额外节点。这是因为WPF的渲染模型需要额外的可视化对象来支持复杂的布局和渲染效果。 实际应用在开发WPF应用程序时，理解逻辑树和可视化树的概念非常重要。例如，当你遇到布局或渲染问题时，你可能需要检查可视化树来确定是否有额外的可视化对象影响了布局或渲染。同样，当你使用数据绑定或样式时，你需要考虑逻辑树中的元素关系。WPF提供了一个名为VisualTreeHelper的类，它包含了一些静态方法，可以用于遍历和检查可视化树。此外，LogicalTreeHelper类提供了一些方法来遍历逻辑树。总结来说，逻辑树和可视化树是WPF中管理UI元素的两种不同层次的表示。逻辑树关注元素之间的逻辑关系，而可视化树关注元素如何在实际屏幕上呈现。理解这两者之间的关系对于高效地开发WPF应用程序至关重要。 类索引器闭包多线程基本概念什么是线程 线程是操作系统中能够独立运行的最小单位，也是程序中能够并发执行的一段指令序列 线程是进程的一部分，一个进程可以包含多个线程，这些线程共享进程的资源 进程有入口线程，也可以创建更多的线程 为什么要多线程？ 批量重复任务希望同时进行（比如对于数组中的每个元素都进行相同且耗时的操作） 多个不同任务希望同时进行，互不干扰（比如有多个后台线程需要做轮询等操作） 什么是线程池？ 一组预先创建的线程，可以被重复使用来执行多个任务 避免频繁地创建和销毁线程，从而减少了线程创建和销毁的开销，提高了系统的性能和效率 异步编程默认使用线程池 什么是线程安全？线程安全 多个线程访问共享资源时，对共享资源的访问不会导致数据不一致或不可预期的结果 同步机制 用于协调和控制多个线程之间执行顺序和互斥访问共享资源 确保线程按照特定的顺序执行，避免竞态条件和数据不一致的问题 原子操作 在执行过程中不会被中断的操作。不可分割，要么完全执行，要么完全不执行，没有中间状态 在多线程环境下，原子操作能够保证数据的一致性和可靠性，避免出现竞态条件和数据竞争的问题 线程不安全的两个例子12345678910111213141516171819202122计数const int total = 100_000;int count = 0;var thread1 = new Thread(Increment);var thread2 = new Thread(Increment);thread1.Start();thread2.Start();thread1.Join();thread2.Join();Console.WriteLine($&quot;Count: &#123;count&#125;&quot;);void Increment()&#123; for (int i = 0; i &lt; total; i++) count++;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445操作队列var queue = new Queue&lt;int&gt;();var producer = new Thread(Producer);var consumer1 = new Thread(Consumer);var consumer2 = new Thread(Consumer);producer.Start();consumer1.Start();consumer2.Start();producer.Join();Thread.Sleep(100); // Wait for consumers to finishconsumer1.Interrupt();consumer2.Interrupt();consumer1.Join();consumer2.Join();void Producer()&#123; for (int i = 0; i &lt; 20; i++) &#123; Thread.Sleep(20); queue.Enqueue(i); &#125;&#125;void Consumer()&#123; try &#123; while (true) &#123; if (queue.TryDequeue(out var res)) Console.WriteLine(res); Thread.Sleep(1); &#125; &#125; catch (ThreadInterruptedException) &#123; Console.WriteLine(&quot;Thread interrupted.&quot;); &#125;&#125; 常用实现方式 线程 线程池 异步编程 考虑一下自带方法？ Parallel For、ForEach、Invoke PLINQ AsParallel、AsSequential AsOrdered 1234567891011121314151617181920212223242526Parallel 与 PLINQvar inputs = Enumerable.Range(1,20).ToArray();int HeavyJob(int input)&#123; Thread.Sleep(300); return input;&#125;// Sequentialvar forOutputs = new int[inputs.Length];for (int i = 0; i &lt; inputs.Length; i++)&#123; forOutputs[i] = HeavyJob(inputs[i]);&#125;// Parallelvar parallelOutputs = new int[inputs.Length];Parallel.For(0, inputs.Length, i =&gt;&#123; parallelOutputs[i] = HeavyJob(inputs[i]);&#125;);// PLINQvar plinqOutputs = inputs.AsParallel().Select(HeavyJob).ToArray(); 12345678910111213141516171819PLINQ 与信号量using System.Diagnostics;var inputs = Enumerable.Range(1,20).ToArray();var semaphore = new Semaphore(3, 3);int HeavyJob(int input)&#123; semaphore.WaitOne(); Thread.Sleep(300); semaphore.Release(); return input;&#125;var sw = Stopwatch.StartNew();var plinqOutputs = inputs.AsParallel().Select(HeavyJob).ToArray();sw.Stop();Console.WriteLine($&quot;Elapsed time: &#123;sw.ElapsedMilliseconds&#125;ms&quot;); 线程Thread线程的创建 创建 Thread 实例，并传入 ThreadStart 委托 还可以配置线程，如是否为后台线程 调用 Thread.Start 方法，还可以传参 线程的终止 调用 Thread.Join 方法，等待线程的结束 调用 Thread.Interrupt 方法，中断线程的执行 会在相应线程中抛出ThreadInterruptedException 如果线程中包含一个 while(true) 循环，那么需要保证包含等待方法，如IO操作，Thread.Sleep等 不能用 Abort？ 使用 Abort 方法来强制终止线程可能导致一些严重的问题，包括资源泄漏和不可预测的行为 较新版本的 .NET 中如果使用这个方法，会报PlatformNotSupportedException 推荐使用 Thread.Interrupt 或CancellationToken 线程的挂起与恢复 Thread.Suspend 以及 Thread.Resume 较新版本的 .NET 中，这两个方法已经被标记为Obsolete，且调用会报错 推荐使用锁、信号量等方式实现这一逻辑 线程的超时 Join 方法拥有 Timeout 入参，并会在超时后返回 false 可以在这种情况下考虑使用 Interrupt 或CancellationToken 的方式终止一个线程 1234567891011121314151617181920212223线程终止var thread = new Thread(() =&gt;&#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; Thread.Sleep(1000); Console.WriteLine(&quot;Sub thread: &quot; + i); &#125; &#125; catch (ThreadInterruptedException) &#123; Console.WriteLine(&quot;Thread interrupted&quot;); &#125;&#125;);thread.Start();Thread.Sleep(3500);thread.Interrupt();thread.Join();Console.WriteLine(&quot;Done&quot;); 线程安全与同步机制Thread-Safety原子操作 Interlocked 锁与信号量 lock &amp; Monitor Mutex Semaphore WaitHandle ManualResetEvent AutoResetEvent ReaderWriterLock 轻量型 SemaphoreSlim ManualResetEventSlim ReaderWriterLockSlim 不要自己造轮子！ 线程安全的单例：Lazy 线程安全的集合类型：ConcurrentBag、ConcurrentStack、ConcurrentQueue、ConcurrentDictionary 阻塞集合：BlockingCollection 通道：Channel 原子操作：Interlocked 周期任务：PeriodicTimer 多线程练习题练习 1：基本线程创建创建一个C#控制台应用程序，实现以下功能： 创建并启动3个线程。 每个线程打印从1到10的数字。 确保所有线程都完成后，主线程打印“所有线程已完成”。 123456789101112131415161718192021222324252627282930313233343536using System;using System.Threading;class Program&#123; static object lockObject = new object(); static void Main(string[] args) &#123; Thread[] threads = new Thread[3]; for (int i = 0; i &lt; threads.Length; i++) &#123; threads[i] = new Thread(PrintNumbers); threads[i].Start(); &#125; foreach (var thread in threads) &#123; thread.Join(); // 等待所有线程完成 &#125; Console.WriteLine(&quot;所有线程已完成&quot;); &#125; static void PrintNumbers() &#123; lock (lockObject) // 确保打印操作是线程安全的 &#123; for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine($&quot;线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;i&#125;&quot;); &#125; &#125; &#125;&#125; 练习 2：线程同步在练习1的基础上，实现以下功能： 使用锁（lock）或其他同步机制（如Monitor、Mutex）确保数字打印是线程安全的。 每个线程打印数字时，应该按顺序打印（例如，线程1打印1, 2, 3…，线程2打印11, 12, 13…）。 1234567891011121314151617181920212223242526272829303132333435363738394041class TestThread&#123; static int globalNextNum = 1; static object lockObject = new object(); public static void Main() &#123; Task[] tasks = new Task[3]; for (int i = 0; i &lt; tasks.Length; i++) &#123; tasks[i] = new Task(() =&gt; &#123; PrintOneToTen(); &#125;); tasks[i].Start(); &#125; for (int i = 0; i &lt; tasks.Length; i++) &#123; tasks[i].Wait(); &#125; Console.WriteLine(&quot;所有线程已完成&quot;); &#125; static void PrintOneToTen() &#123; try &#123; Monitor.Enter(lockObject); // 安全地访问共享资源 for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine($&quot;线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;globalNextNum++&#125;&quot;); // 为了让线程之间的输出更明显，我们可以让线程稍微等待一下 Thread.Sleep(100); &#125; &#125; finally &#123; // 确保退出锁定状态 Monitor.Exit(lockObject); &#125; &#125;&#125; 练习 3：使用线程池修改练习1，使用线程池（ThreadPool）来创建和管理线程，而不是直接创建Thread对象。 1234567891011121314151617181920212223242526272829303132333435TestThread.Main();class TestThread&#123; static int globalNextNum = 1; static object lockObject = new object(); public static void Main() &#123; //WaitCallback[] waitCallBack = new WaitCallback[3]; ManualResetEvent[] doneEvents = new ManualResetEvent[3]; for (int i = 0; i &lt; 3; i++) &#123; doneEvents[i] = new ManualResetEvent(false); ThreadPool.QueueUserWorkItem(PrintOneToTen,doneEvents[i]); &#125; WaitHandle.WaitAll(doneEvents); Console.WriteLine(&quot;所有线程已完成&quot;); &#125; static void PrintOneToTen(object state) &#123; lock (lockObject) &#123; ManualResetEvent doneEvents = (ManualResetEvent)state; // 安全地访问共享资源 for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine($&quot;线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;globalNextNum++&#125;&quot;); // 为了让线程之间的输出更明显，我们可以让线程稍微等待一下 Thread.Sleep(100); &#125; // 设置事件，表示线程已完成 doneEvents.Set(); &#125; &#125;&#125; 练习 4：使用Task使用Task类重写练习1，实现相同的功能。 12345678910111213141516171819202122232425262728293031323334353637TestThread.Main();class TestThread&#123; static int globalNextNum = 1; static object lockObject = new object(); public static void Main() &#123; Task[] tasks = new Task[3]; for (int i = 0; i &lt; tasks.Length; i++) &#123; tasks[i] = new Task(() =&gt; &#123; PrintOneToTen(); &#125;); tasks[i].Start(); &#125; for (int i = 0; i &lt; tasks.Length; i++) &#123; tasks[i].Wait(); &#125; Console.WriteLine(&quot;所有线程已完成&quot;); &#125; static void PrintOneToTen() &#123; lock(lockObject) &#123; // 安全地访问共享资源 for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine($&quot;线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;globalNextNum++&#125;&quot;); // 为了让线程之间的输出更明显，我们可以让线程稍微等待一下 Thread.Sleep(100); &#125; &#125; &#125;&#125; 练习 5：并行循环使用Parallel.For或Parallel.ForEach重写练习1，实现相同的功能。 1234567891011121314151617181920using System;using System.Threading.Tasks;class Program&#123; static void Main(string[] args) &#123; Parallel.For(1, 31, (i) =&gt; &#123; // 由于Parallel.For并行执行，我们需要计算每个线程应该打印的数字 int threadId = Task.CurrentId.HasValue ? Task.CurrentId.Value : -1; Console.WriteLine($&quot;线程 &#123;threadId&#125;: &#123;i&#125;&quot;); // 为了让输出更清晰，可以稍微等待 Thread.Sleep(100); &#125;); Console.WriteLine(&quot;所有线程已完成&quot;); &#125;&#125; 练习 6：线程间通信创建一个C#控制台应用程序，实现以下功能： 创建两个线程，一个线程用于生产数据，另一个线程用于消费数据。 使用BlockingCollection&lt;T&gt;或其他机制来实现生产者-消费者模式。 1234567891011121314151617181920212223242526272829303132333435class TestThread&#123; static BlockingCollection&lt;int&gt; blockingCollection = new BlockingCollection&lt;int&gt;(); public static void Main() &#123; Thread producer = new Thread(Produce); Thread consumer = new Thread(Consumer); producer.Start(); consumer.Start(); producer.Join(); consumer.Join(); &#125; static void Produce() &#123; for (int i = 0; i &lt; 10; i++) &#123; blockingCollection.Add(i); Console.WriteLine($&quot;produce:&#123;i&#125;&quot;); Thread.Sleep(100); &#125; &#125; static void Consumer() &#123; foreach (var item in blockingCollection.GetConsumingEnumerable()) &#123; Console.WriteLine($&quot;consumer:&#123;item&#125;&quot;); Thread.Sleep(100); &#125; &#125;&#125; 练习 7：线程局部存储创建一个C#控制台应用程序，实现以下功能： 创建一个线程局部存储（ThreadLocal&lt;T&gt;）变量，用于存储每个线程的计数。 启动多个线程，每个线程将自己的计数增加，并打印出增加后的值。 12345678910111213141516171819202122232425262728293031//在C#中，ThreadLocal&lt;T&gt; 是一个类，它提供了一种线程局部存储（Thread-Local Storage, TLS）机制，使得每个线程都可以拥有自己的变量副本，而不会与其他线程共享。class TestThread&#123; static ThreadLocal&lt;int&gt; threadLocal = new ThreadLocal&lt;int&gt;(()=&gt;0);//初始化为0 public static void Main() &#123; Thread[] threads = new Thread[3]; for (int i = 0; i &lt; threads.Length; i++) &#123; threads[i] = new Thread(ThreadProc); threads[i].Start(); &#125; foreach (var thread in threads) &#123; thread.Join(); &#125; &#125; static void ThreadProc() &#123; for (int i = 0; i &lt; 5; i++) &#123; threadLocal.Value++; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;threadLocal.Value&#125;&quot;); &#125; &#125;&#125; 练习 8：死锁演示创建一个C#控制台应用程序，演示死锁的情况： 创建两个资源（例如两个object）。 创建两个线程，每个线程分别锁定一个资源，然后尝试锁定另一个资源，以产生死锁。 1234567891011121314151617181920212223242526272829using System;using System.Threading;class Program&#123; static object lock1 = new object(); static object lock2 = new object(); static void Main(string[] args) &#123; Thread t1 = new Thread(DeadlockDemo); Thread t2 = new Thread(DeadlockDemo); t1.Start(); t2.Start(); &#125; static void DeadlockDemo() &#123; lock (lock1) &#123; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125; acquired lock1&quot;); Thread.Sleep(100); lock (lock2) &#123; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125; acquired lock2&quot;); &#125; &#125; &#125;&#125; 练习 9：解决死锁修改练习8中的代码，使用超时或其他策略来避免死锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Threading;class Program&#123; static object lock1 = new object(); static object lock2 = new object(); static void Main(string[] args) &#123; Thread t1 = new Thread(DeadlockFreeDemo); Thread t2 = new Thread(DeadlockFreeDemo); t1.Start(); t2.Start(); &#125; static void DeadlockFreeDemo() &#123; const int lockTimeout = 1000; // Timeout in milliseconds if (Monitor.TryEnter(lock1, lockTimeout)) &#123; try &#123; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125; acquired lock1&quot;); Thread.Sleep(100); if (Monitor.TryEnter(lock2, lockTimeout)) &#123; try &#123; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125; acquired lock2&quot;); &#125; finally &#123; Monitor.Exit(lock2); &#125; &#125; &#125; finally &#123; Monitor.Exit(lock1); &#125; &#125; &#125;&#125; 练习 10：线程安全的数据结构创建一个C#控制台应用程序，实现以下功能： 使用线程安全的集合（如ConcurrentBag&lt;T&gt;、ConcurrentDictionary&lt;TKey, TValue&gt;）。 多个线程同时向集合中添加和移除元素。 确保集合操作是线程安全的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;using System.Collections.Concurrent;using System.Threading;using System.Threading.Tasks;class Program&#123; // 使用 ConcurrentBag 作为线程安全的集合 static ConcurrentBag&lt;int&gt; bag = new ConcurrentBag&lt;int&gt;(); static void Main(string[] args) &#123; int numberOfThreads = 10; int itemsToAddPerThread = 100; // 创建并启动多个线程来添加元素 Task[] addingTasks = new Task[numberOfThreads]; for (int i = 0; i &lt; numberOfThreads; i++) &#123; int threadId = i; addingTasks[i] = Task.Run(() =&gt; AddItemsToBag(threadId, itemsToAddPerThread)); &#125; // 创建并启动多个线程来移除元素 Task[] removingTasks = new Task[numberOfThreads]; for (int i = 0; i &lt; numberOfThreads; i++) &#123; removingTasks[i] = Task.Run(RemoveItemsFromBag); &#125; // 等待所有添加任务完成 Task.WaitAll(addingTasks); // 等待所有移除任务完成 Task.WaitAll(removingTasks); Console.WriteLine(&quot;所有线程已完成操作。&quot;); Console.WriteLine(&quot;集合中的元素数量: &quot; + bag.Count); &#125; static void AddItemsToBag(int threadId, int count) &#123; for (int i = 0; i &lt; count; i++) &#123; bag.Add(threadId * count + i); &#125; Console.WriteLine($&quot;线程 &#123;threadId&#125; 完成添加 &#123;count&#125; 个元素。&quot;); &#125; static void RemoveItemsFromBag() &#123; int itemsRemoved = 0; int item; while (bag.TryTake(out item)) &#123; itemsRemoved++; &#125; Console.WriteLine($&quot;一个线程移除了 &#123;itemsRemoved&#125; 个元素。&quot;); &#125;&#125; 异步编程常见概念已经有多线程了，为何还要异步多线程与异步是不同的概念 异步并不意味着多线程，单线程同样可以异步 异步默认借助线程池 多线程经常阻塞，而异步要求不阻塞 多线程与异步的适用场景不同多线程 适合 CPU 密集型操作 适合长期运行的任务 线程的创建与销毁开销较大 提供更底层的控制，操作线程、锁、信号量等 线程不易于传参及返回 线程的代码书写较为繁琐 异步 适合 IO 密集型操作 适合短暂的小任务 避免线程阻塞，提高系统响应能力 什么是异步任务（Task）包含了异步任务的各种状态的一个引用类型 正在运行、完成、结果、报错等 另有 ValueTask 值类型版本 对于异步任务的抽象 开启异步任务后，当前线程并不会阻塞，而是可 以去做其他事情 异步任务（默认）会借助线程池在其他线程上运行 获取结果后回到之前的状态 任务的结果 返回值为 Task 的方法表示异步任务没有返回值 返回值为 Task 则表示有类型为 T 的返回值 异步方法（async Task） 将方法标记 async 后，可以在方法中使用 await 关键字 await 关键字会等待异步任务的结束，并获得结 果 async + await 会将方法包装成状态机，await 类似于检查点 MoveNext 方法会被底层调用，从而切换状态 async Task 返回值依旧是 Task 类型，但是在其中可以使用 await 关键字 在其中写返回值可以直接写 Task 中的 T 类 型，不用包装成 Task async void 同样是状态机，但缺少记录状态的 Task 对象 无法聚合异常（Aggregate Exception），需要谨慎处理异常 几乎只用于对于事件的注册 异步编程具有传染性（Contagious） 一处 async，处处 async 几乎所有自带方法都提供了异步的版本 重要思想：不阻塞！ await 会暂时释放当前线程，使得该线程可以执 行其他工作，而不必阻塞线程直到异步操作完成 不要在异步方法里用任何方式阻塞当前线程 常见阻塞情形 Task.Wait() &amp; Task.Result 如果任务没有完成，则会阻塞当前线程，容易导致死锁 Task.GetAwaiter().GetResult() 不会将 Exception 包装为 AggregateException Task.Delay() vs. Thread.Sleep() 后者会阻塞当前的线程，这与异步编程的理念不 符 前者是一个异步任务，会立刻释放当前的线程 IO 等操作的同步方法 较新版本的 .NET 为我们提供了一整套的异步方 法，包含 Web、IO、Stream 等 其他繁重且耗时的任务 使用 Task.Run 包装 同步上下文 一种管理和协调线程的机制，允许开发者将代码 的执行切换到特定的线程 WinForms 与 WPF 拥有同步上下文（UI 线 程），而控制台程序默认没有 ConfigureAwait(false) 配置任务通过 await 方法结束后是否会到原来的 线程，默认为 true 一般只有 UI 线程会采用这种策略 TaskScheduler 控制 Task 的调度方式和运行线程 线程池线程 Default 当前线程 CurrentThread 单线程上下文 STAThread 长时间运行线程 LongRunning 优先级、上下文、执行状态等 一发即忘（Fire-and-forget） 调用一个异步方法，但是并不使用 await 或阻塞 的方式去等待它的结束 无法观察任务的状态（是否完成、是否报错等） 简单任务如何创建异步任务？Task.Run() 在一个新的线程上执行代码 传入异步匿名方法会被包装成 Task Task.Run(async () &#x3D;&gt; await Task.Delay(100)) 保证异步方法在别的线程上运行 Task.Factory.StartNew() 提供更多功能，比如 TaskCreationOptions.LongRunning Task.Run 相当于简化版 new Task + Task.Start()看起来类似 new Thread + Thread.Start()，不 常用 如何同时开启多个异步任务？ 不要 for 循环中使用 await Task.WhenAll()、Task.WhenAny() 任务如何取消？ CancellationTokenSource + CancellationToken OperationCanceledException &amp; TaskCanceledException 推荐异步方法都带上 CancellationToken 这一传 参 「我可以不用，但你不能没有」 任务超时如何实现？在异步任务中汇报进度？如何在同步方法中调用异步方法？常见误区异步一定是多线程？ 异步编程不必需要多线程来实现 时间片轮转调度 比如可以在单个线程上使用异步 I&#x2F;O 或事件驱动 的编程模型（EAP） 单线程异步：自己定好计时器，到时间之前先去 做别的事情 。多线程异步：将任务交给不同的线程，并由自己 来进行指挥调度 异步方法一定要写成 async Task？ async 关键字只是用来配合 await 使用，从而将 方法包装为状态机 本质上仍然是 Task，只不过提供了语法糖，并 且函数体中可以直接 return Task 的泛型类型 接口中无法声明 async Task await 一定会切换同步上下文？ 在使用 await 关键字调用并等待一个异步任务 时，异步方法不一定会立刻来到新的线程上 如果 1 await 了一个已经完成的任务（包括 Task.Delay(0)），会直接获得结果 异步可以全面取代多线程？ 异步编程与多线程有一定关系，但两者并不是可 以完全互相替代 Task.Result 一定会阻塞当前线程？ 如果任务已经完成，那么 Task.Result 可以直接 得到结果 开启的异步任务一定不会阻塞当前线程？ await 关键字不一定会立刻释放当前线程，所以 如果调用的异步方法中存在阻塞（如 Thread.Sleep(0)），那么依旧会阻塞当前上下 文对应的线程 同步机制传统方法 Monitor（lock） Mutex Semaphore EventWaitHandle 轻量型 SemaphoreSlim ManualResetEventSlim 并发集合 ConcurrentBag&#x2F;Stack&#x2F;Queue BlockingCollection Channel 第三方库 AsyncManualResetEvent Microsoft.VisualStudio.Threading AsyncLock Nito.AsyncEx 还有什么？ Task.FromResult、Task.FromCanceled、 Task.FromException Task.GetAwaiter().GetResult() ContinueWith() Task.Yield() ValueTask IAsyncEnumerable？ IAsyncDisposable？ Async Stream Built-in 异步方法 HttpClient.GetAsync File.WriteAllTextAsync MemoryStream.ReadAsync Console.Out.WriteLineAsync 在异步编程中使用锁与信号量？ WPF &amp; Async 练习题练习 1: 异步读取文件内容编写一个异步方法 ReadFileAsync，该方法接收一个文件路径作为参数，异步读取文件内容，并返回读取到的字符串。 1234567public static async Task&lt;string&gt; ReadFileAsync(string filePath) &#123; using(var render = new StreamReader(filePath)) &#123; return await render.ReadToEndAsync(); &#125; &#125; 练习 2: 并发异步操作创建三个异步方法 GetDataAAsync、GetDataBAsync 和 GetDataCAsync，模拟从不同数据源获取数据。然后编写一个方法 FetchAllDataAsync，该方法并发执行这三个异步操作，并在所有操作完成后返回结果。 123456789101112public static async Task FetchAllDataAsync() &#123; Task&lt;string&gt; taskA = GetDataAAsync(@&quot;D:\\log.txt&quot;); Task&lt;string&gt; taskB = GetDataBAsync(@&quot;D:\\log.txt&quot;); Task&lt;string&gt; taskC = GetDataCAsync(@&quot;D:\\log.txt&quot;); await Task.WhenAll(taskA, taskB, taskC); Console.WriteLine($&quot;Data A: &#123;taskA.Result&#125;&quot;); Console.WriteLine($&quot;Data B: &#123;taskB.Result&#125;&quot;); Console.WriteLine($&quot;Data C: &#123;taskC.Result&#125;&quot;); &#125; 练习 3: 顺序执行异步操作编写一个异步方法 SequenceAsyncOps，该方法顺序执行以下操作：先执行 GetDataAAsync，然后根据 GetDataAAsync 的结果执行 GetDataBAsync，最后根据 GetDataBAsync 的结果执行 GetDataCAsync 并返回结果。 练习 4: 异步处理错误在练习 3 的基础上，增加错误处理功能。如果任何一步操作失败，捕获异常并打印错误信息。 123456789101112131415// 练习 3 &amp; 4: 顺序执行异步操作并处理错误 public async Task SequenceAsyncOps() &#123; try &#123; string resultA = await GetDataAAsync(); string resultB = await GetDataBAsync(resultA); string resultC = await GetDataCAsync(resultB); Console.WriteLine($&quot;Result C: &#123;resultC&#125;&quot;); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;An error occurred: &#123;ex.Message&#125;&quot;); &#125; &#125; 练习 5: 异步并发控制创建一个任务列表 tasks，其中每个任务都是一个返回 Task 的异步方法。编写一个方法 RunTasksConcurrentlyAsync，该方法可以同时执行最多5个异步操作，当一个操作完成时，自动从任务列表中取下一个任务执行。 12345678910111213141516171819202122232425262728293031// 练习 5: 异步并发控制 public async Task RunTasksConcurrentlyAsync(Task[] tasks, int limit) &#123; var semaphore = new SemaphoreSlim(limit); var runningTasks = new List&lt;Task&gt;(); foreach (var task in tasks) &#123; await semaphore.WaitAsync(); runningTasks.Add( task.ContinueWith(t =&gt; &#123; semaphore.Release(); &#125;)); &#125; await Task.WhenAll(runningTasks); &#125; Main()&#123; // 练习 5 var tasks = new Task[] &#123; exercises.GetDataAAsync(), exercises.GetDataBAsync(&quot;&quot;), exercises.GetDataCAsync(&quot;&quot;), // 添加更多任务... &#125;; await exercises.RunTasksConcurrentlyAsync(tasks, 5); &#125; 1SemaphoreSlim semaphore = new SemaphoreSlim(initialCount, maximumCount); initialCount：信号量初始化时允许的最大并发访问数。 maximumCount：信号量可以允许的最大并发访问数。 等待信号 当要进入临界区之前，需要调用 WaitAsync 方法来等待信号。 1await semaphore.WaitAsync(); 或者同步版本： 1semaphore.Wait(); 如果信号量计数大于0，则立即进入临界区。如果计数为0，则线程会阻塞，直到其他线程释放信号量。 释放信号 完成对共享资源的访问后，需要调用 Release 方法来释放信号量，增加其计数。 1semaphore.Release(); 如果释放操作导致信号量的计数超过了最大值，将会抛出异常。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"fly"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"WPF - 编程","slug":"WPF-编程","permalink":"http://example.com/tags/WPF-%E7%BC%96%E7%A8%8B/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"}]}