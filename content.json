{"meta":{"title":"Fly Blog - ૮꒰ ˶• ༝ •˶꒱ა","subtitle":"","description":"Here is Fly’s Blos","author":"Fly","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-05-11T10:36:11.052Z","updated":"2025-05-11T10:36:11.052Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-05-13T12:18:53.032Z","updated":"2025-05-13T12:18:53.032Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-05-11T10:34:45.620Z","updated":"2025-05-11T10:34:45.620Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-13T13:32:20.570Z","updated":"2025-05-13T13:32:20.570Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于我 梦想是早日暴富，梦想是早日躺平退休有饭吃 时间线 OnGoing… 等待退休ING… 2023.11.24 正式工作 2015.09.01 读高中 2012.09.01 读初中 2006.09.01 读小学 2003.09.01 读幼儿园"},{"title":"","date":"2025-05-11T10:35:04.551Z","updated":"2025-05-11T10:35:04.551Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-12T13:44:01.139Z","updated":"2025-05-12T13:44:01.139Z","comments":true,"path":"html/index.html","permalink":"http://example.com/html/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-13T15:21:52.571Z","updated":"2025-05-13T15:21:52.571Z","comments":true,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":"相册 note 相册一 第一张图片第二张图片第三张图片 note 相册二 图片1图片2图片3图片4图片5图片6图片7图片8图片9图片10图片11图片12图片13图片14图片15图片16图片17图片18图片19图片10图片11图片12图片13图片14 note 随机图片 随机风景必应壁纸 note 📍China·珠海 爱情邮局城市阳台日月贝 note 随手拍 · 白云 · 夕阳 · 天空 县城傍晚珠海香洲区夕阳珠科校园珠科校园珠科校园珠科校园练车时候拍的从化河边从化公园从化公园从化公园宿舍阳台宿舍阳台珠海香洲区夕阳珠海"},{"title":"所有标签","date":"2025-05-11T10:34:56.134Z","updated":"2025-05-11T10:34:56.134Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Log4Net[面试系列]","slug":"Log4Net","date":"2025-06-16T14:40:24.000Z","updated":"2025-06-16T16:00:43.340Z","comments":true,"path":"2025/06/16/Log4Net/","permalink":"http://example.com/2025/06/16/Log4Net/","excerpt":"","text":"一、log4net 基础概念 log4net 是什么？ Apache 开源的 .NET 日志记录框架，属于 Log4j 的 .NET 移植版本。 核心作用： 多目标输出（文件、数据库、控制台等） 日志分级（DEBUG&#x2F;INFO&#x2F;WARN&#x2F;ERROR&#x2F;FATAL） 动态配置（无需重启应用修改日志行为） 高性能异步日志记录 二、日志级别与配置 日志级别及设置 级别 说明 典型场景 DEBUG 调试信息（最详细） 开发环境问题追踪 INFO 关键流程信息 系统运行状态监控 WARN 潜在问题警告 资源不足、非关键错误 ERROR 业务逻辑错误 异常捕获、数据校验失败 FATAL 系统崩溃级错误 无法恢复的致命错误 配置方式（XML 示例）：12345&lt;root&gt; &lt;!-- 设置全局日志级别 --&gt; &lt;level value=&quot;INFO&quot; /&gt; &lt;appender-ref ref=&quot;FileAppender&quot; /&gt;&lt;/root&gt; 三、核心配置与输出输出到文件 文件输出配置 1234567&lt;appender name=&quot;FileAppender&quot; type=&quot;log4net.Appender.FileAppender&quot;&gt; &lt;file value=&quot;logs/app.log&quot; /&gt; &lt;appendToFile value=&quot;true&quot; /&gt; &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt; &lt;conversionPattern value=&quot;%date [%thread] %-5level %logger - %message%newline&quot; /&gt; &lt;/layout&gt;&lt;/appender&gt; 输出到数据库 数据库输出配置（SQL Server 示例） 1234567891011&lt;appender name=&quot;AdoNetAppender&quot; type=&quot;log4net.Appender.AdoNetAppender&quot;&gt; &lt;connectionType value=&quot;System.Data.SqlClient.SqlConnection, ...&quot; /&gt; &lt;connectionString value=&quot;Server=.;Database=LogDB;Integrated Security=True;&quot; /&gt; &lt;commandText value=&quot;INSERT INTO Logs (Date,Level,Message) VALUES (@log_date, @log_level, @message)&quot; /&gt; &lt;parameter&gt; &lt;parameterName value=&quot;@log_date&quot; /&gt; &lt;dbType value=&quot;DateTime&quot; /&gt; &lt;layout type=&quot;log4net.Layout.RawTimeStampLayout&quot; /&gt; &lt;/parameter&gt; &lt;!-- 其他参数 --&gt;&lt;/appender&gt; 多目标输出 同时输出到文件和数据库 12345&lt;root&gt; &lt;level value=&quot;INFO&quot; /&gt; &lt;appender-ref ref=&quot;FileAppender&quot; /&gt; &lt;appender-ref ref=&quot;AdoNetAppender&quot; /&gt;&lt;/root&gt; 四、高级特性日志滚动与切割 避免日志过大（使用 RollingFileAppender） 12345678&lt;appender name=&quot;RollingFile&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt; &lt;file value=&quot;logs/app.log&quot; /&gt; &lt;rollingStyle value=&quot;Size&quot; /&gt; &lt;maxSizeRollBackups value=&quot;10&quot; /&gt; &lt;maximumFileSize value=&quot;10MB&quot; /&gt; &lt;staticLogFileName value=&quot;true&quot; /&gt; &lt;!-- 其他配置 --&gt;&lt;/appender&gt; rollingStyle：支持按大小（Size）、日期（Date）等切割 异步日志 异步记录提升性能 123&lt;appender name=&quot;AsyncAppender&quot; type=&quot;log4net.Appender.AsyncAppender&quot;&gt; &lt;appender-ref ref=&quot;FileAppender&quot; /&gt;&lt;/appender&gt; 邮件报警 错误日志邮件通知 1234567&lt;appender name=&quot;SmtpAppender&quot; type=&quot;log4net.Appender.SmtpAppender&quot;&gt; &lt;to value=&quot;admin@example.com&quot; /&gt; &lt;from value=&quot;noreply@example.com&quot; /&gt; &lt;subject value=&quot;系统错误报警&quot; /&gt; &lt;smtpHost value=&quot;smtp.example.com&quot; /&gt; &lt;threshold value=&quot;ERROR&quot; /&gt; &lt;!-- 仅发送ERROR及以上日志 --&gt;&lt;/appender&gt; 五、.NET Core 集成依赖注入 .NET Core DI 集成 1234567891011121314151617181920// Program.cspublic static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureLogging(logging =&gt; &#123; logging.AddLog4Net(&quot;log4net.config&quot;); &#125;) .ConfigureServices(services =&gt; &#123; services.AddScoped&lt;IMyService, MyService&gt;(); &#125;);// 服务中使用public class MyService &#123; private readonly ILogger _logger; public MyService(ILogger&lt;MyService&gt; logger) &#123; _logger = logger; &#125; public void DoWork() &#123; _logger.LogInformation(&quot;操作执行中...&quot;); &#125;&#125; 环境区分配置 开发&#x2F;生产环境差异化配置 条件编译：12345#if DEBUGlog4net.Config.XmlConfigurator.Configure(new FileInfo(&quot;log4net.Debug.config&quot;));#elselog4net.Config.XmlConfigurator.Configure(new FileInfo(&quot;log4net.Production.config&quot;));#endif 环境变量动态加载：123var env = Environment.GetEnvironmentVariable(&quot;ASPNETCORE_ENVIRONMENT&quot;);var configFile = $&quot;log4net.&#123;env&#125;.config&quot;;XmlConfigurator.Configure(new FileInfo(configFile)); 六、定制化功能自定义日志格式 PatternLayout 定制格式 123&lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt; &lt;conversionPattern value=&quot;%date&#123;yyyy-MM-dd HH:mm:ss&#125; | %-5level | %logger&#123;1&#125; | %message%newline&quot; /&gt;&lt;/layout&gt; 常用占位符： %date：时间 %thread：线程ID %property&#123;user&#125;：自定义属性 上下文数据 记录上下文信息 12345678// 设置全局上下文log4net.GlobalContext.Properties[&quot;appVersion&quot;] = &quot;1.2.0&quot;;// 设置线程级上下文log4net.ThreadContext.Properties[&quot;requestId&quot;] = Guid.NewGuid();// 配置中使用&lt;conversionPattern value=&quot;%property&#123;appVersion&#125; | %property&#123;requestId&#125; | %message&quot; /&gt; 动态配置 运行时修改配置 123var repo = LogManager.GetRepository();var configFile = new FileInfo(&quot;new_config.xml&quot;);XmlConfigurator.Configure(repo, configFile); 关键配置总结 功能 核心组件 配置要点 文件输出 FileAppender 文件路径、追加模式 日志滚动 RollingFileAppender 切割策略（大小&#x2F;日期）、备份数 数据库输出 AdoNetAppender 连接字符串、参数映射 邮件报警 SmtpAppender SMTP配置、接收人、日志阈值 异步日志 AsyncAppender 包裹其他Appender 环境区分 条件编译&#x2F;环境变量 多配置文件动态加载 .NET Core集成 AddLog4Net() 依赖注入ILogger接口 最佳实践： 生产环境使用 ERROR 级别 + 异步 + 滚动切割 敏感信息避免日志（如密码） 关键业务操作记录 INFO 级别日志 错误日志附加异常堆栈：_logger.LogError(ex, &quot;操作失败&quot;)","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"Log4Net","slug":"Log4Net","permalink":"http://example.com/tags/Log4Net/"}],"author":"fly"},{"title":"LINQ[面试系列]","slug":"LINQ","date":"2025-06-16T14:38:24.000Z","updated":"2025-06-16T16:00:43.336Z","comments":true,"path":"2025/06/16/LINQ/","permalink":"http://example.com/2025/06/16/LINQ/","excerpt":"","text":"📌 LINQ 原理与使用详解 1. 简述什么是 LINQ？它的主要优势是什么？答案：LINQ（语言集成查询）是 C# 中用于统一查询各种数据源（如集合、数据库、XML 等）的技术。它将查询逻辑直接嵌入到编程语言中，提升开发效率。 主要优势： 语法统一，适用于多种数据源 编译时检查错误，减少运行时异常 可读性强，易于维护 支持延迟执行，提高性能 推荐星级：★★★难度：初级 2. 简述 Lambda 表达式是什么？它在 LINQ 中的作用是什么？答案：Lambda 表达式是一种简洁的匿名函数写法，格式为 参数 =&gt; 表达式。它常用于 LINQ 查询中作为条件或投影操作的参数。 示例： 1var evenNumbers = numbers.Where(n =&gt; n % 2 == 0); 作用： 提供灵活的筛选、排序、投影逻辑 避免编写单独的方法 提升代码可读性和简洁性 推荐星级：★★★难度：中级 3. 简述在 LINQ 中，常用的操作符有哪些？请列举并简要说明它们的作用？ 操作符 说明 Where 筛选满足条件的数据 Select 投影转换数据 OrderBy &#x2F; ThenBy 排序 GroupBy 分组 Join 内连接两个数据集 SelectMany 扁平化嵌套集合 FirstOrDefault 获取第一个元素或默认值 SingleOrDefault 获取唯一匹配项或默认值 Skip &#x2F; Take 实现分页功能 Count &#x2F; Sum &#x2F; Average 聚合运算 推荐星级：★★★★★难度：中级 4. 简述 LINQ 与 SQL 之间有何异同？它们各自适用于哪些场景？ 对比 LINQ SQL 使用环境 C#&#x2F;.NET 应用程序 数据库系统 类型安全 是（编译期检查） 否（运行时检查） 可读性 更贴近面向对象风格 更贴近关系模型 性能 依赖于底层实现（如 EF） 直接执行，通常更快 适用场景 业务逻辑层、内存集合处理 数据库查询、大数据量处理 推荐星级：★★★难度：中级 5. 简述在使用 LINQ 时，什么是延迟执行（Deferred Execution）？它有什么好处？答案：延迟执行是指查询表达式不会立即执行，而是在遍历结果时才执行。 好处： 减少不必要的资源消耗 动态更新数据源内容 提高性能（避免重复查询） 示例： 12var query = numbers.Where(n =&gt; n &gt; 10); // 不执行foreach (var n in query) &#123; ... &#125; // 执行 推荐星级：★★★★难度：中级 6. 简述什么是 Lambda 表达式的闭包？在 LINQ 中如何使用闭包？答案：闭包是指 Lambda 表达式可以访问其外部作用域中的变量。 示例： 12int threshold = 10;var result = numbers.Where(n =&gt; n &gt; threshold); 在 LINQ 中的应用： 动态筛选条件 复用外部变量构建复杂查询逻辑 推荐星级：★★★难度：初级 7. 简述在 LINQ 中，Select 和 SelectMany 有什么区别？请举例说明？ 特征 Select SelectMany 输出类型 IEnumerable&lt;TResult&gt; IEnumerable&lt;TElement&gt; 是否扁平化 否 是 示例 返回每个元素的属性 返回所有子集合合并后的元素 示例： 12345// Select: 每个元素映射为一个集合var lists = users.Select(u =&gt; u.Orders); // IEnumerable&lt;IEnumerable&lt;Order&gt;&gt;// SelectMany: 合并所有订单为一个集合var allOrders = users.SelectMany(u =&gt; u.Orders); // IEnumerable&lt;Order&gt; 推荐星级：★★★★★难度：中级 8. 简述在 LINQ 中，什么是延续操作符（Continuation Operators）？它们在查询中的作用是什么？答案：延续操作符用于将当前查询的结果传递给下一个查询语句，最常见的是 into 子句，常用于 GroupBy 或 Join 后继续操作。 示例： 123var grouped = from user in users group user by user.Role into g select new &#123; Role = g.Key, Count = g.Count() &#125;; 作用： 提高查询可读性 支持链式查询结构 推荐星级：★★★★难度：中级 9. 简述在 LINQ 中，什么是匿名类型（Anonymous Types）？请说明其使用场景？答案：匿名类型是在不显式定义类的情况下创建临时对象的方式，使用 new &#123; ... &#125; 定义。 使用场景： 投影查询结果 临时存储中间数据 返回轻量级 DTO（数据传输对象） 示例： 1var result = users.Select(u =&gt; new &#123; u.Name, u.Age &#125;); 推荐星级：★★★★难度：中级 10. 简述在 C# 中如何自定义 LINQ 扩展方法？请提供一个示例？答案：通过静态类和扩展方法定义新的 LINQ 操作符。 示例： 12345678public static class MyLinqExtensions &#123; public static IEnumerable&lt;T&gt; FilterEven&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; selector) &#123; return source.Where(item =&gt; selector(item) % 2 == 0); &#125;&#125;// 使用：var evenAges = people.FilterEven(p =&gt; p.Age); 推荐星级：★★★★难度：初级 11. 简述什么是延迟执行（Deferred Execution）和立即执行（Immediate Execution）？在 LINQ 中如何区分它们？ 特征 延迟执行 立即执行 执行时机 遍历时执行 定义时执行 方法示例 Where, Select, OrderBy ToList(), Count(), First() 优点 节省内存、动态更新 确定结果不变 推荐星级：★★★★★难度：中级 12. 简述在 LINQ 中，FirstOrDefault 和 SingleOrDefault 有什么区别？请说明它们的使用场景？ 方法 条件 返回值 场景 FirstOrDefault 返回第一个匹配项或默认值 第一个匹配项或 default 有多个结果但只需要第一个 SingleOrDefault 返回唯一匹配项或默认值 唯一匹配项或 default 确保只有一个结果 示例： 12var firstUser = users.FirstOrDefault(u =&gt; u.IsActive);var singleUser = users.SingleOrDefault(u =&gt; u.Id == 1); 推荐星级：★★★★难度：中级 13. 简述在 LINQ 中，GroupBy 方法的作用是什么？请提供一个示例说明？答案：GroupBy 用于根据指定键对集合进行分组。 示例： 12345var groupedUsers = users.GroupBy(u =&gt; u.Role);foreach (var group in groupedUsers) &#123; Console.WriteLine($&quot;Role: &#123;group.Key&#125;, Count: &#123;group.Count()&#125;&quot;);&#125; 推荐星级：★★★★难度：中级 14. 简述如何使用 LINQ 进行连接查询（Join）？请举例说明？答案： LINQ 支持内连接（Inner Join）、左连接（Left Join）等。 内连接示例： 1234567891011var query = from user in users join order in orders on user.Id equals order.UserId select new &#123; user.Name, order.Amount &#125;;// 或使用方法语法：var result = users.Join( orders, u =&gt; u.Id, o =&gt; o.UserId, (u, o) =&gt; new &#123; u.Name, o.Amount &#125;); 左连接示例： 1234var leftJoin = from user in users join order in orders on user.Id equals order.UserId into gj from subOrder in gj.DefaultIfEmpty() select new &#123; user.Name, OrderAmount = subOrder?.Amount ?? 0 &#125;; 推荐星级：★★★★★难度：高难 15. 简述在 LINQ 中，什么是操作符重载（Operator Overloading）？如何在自定义类上实现 LINQ 操作符重载？答案：操作符重载是指为自定义类型定义标准操作符的行为（如 ==, + 等），以便在 LINQ 查询中使用。 示例： 1234567891011public class Person &#123; public string Name &#123; get; set; &#125; public static bool operator ==(Person a, Person b) &#123; if (ReferenceEquals(a, b)) return true; if (a is null || b is null) return false; return a.Name == b.Name; &#125; public static bool operator !=(Person a, Person b) =&gt; !(a == b);&#125; 注意： 在 LINQ 中使用时，应确保 Equals() 和 GetHashCode() 正确重写。 推荐星级：★★★★难度：中级 16. 简述如何在 LINQ C# 编程中同时使用 Take 和 Skip 运算符？答案：Take(n) 获取前 n 个元素，Skip(n) 跳过前 n 个元素，二者结合可用于实现分页。 示例： 1234int pageSize = 10;int pageNumber = 2;var pagedData = data.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToList(); 推荐星级：★★★难度：中级 17. 简述使用 LINQ 从对象列表中查找负双精度数的 C# 程序？答案： 假设有一个包含 double 数字的对象列表： 12345class NumberItem &#123; public double Value &#123; get; set; &#125;&#125;var negativeNumbers = items.Where(i =&gt; i.Value &lt; 0).ToList(); 推荐星级：★★★难度：高难 18. 简述 C# Linq 中的 All 和 Any 有什么区别？ 方法 作用 示例 All 判断集合中是否所有元素都满足条件 numbers.All(n =&gt; n &gt; 0) Any 判断集合中是否存在满足条件的元素 numbers.Any(n =&gt; n &gt; 100) 推荐星级：★★★★★难度：初级 19. 简述如何在 LINQ C# 中同时使用 Take 和 Skip 运算符？答案：参考第 16 题。用于分页查询。 示例： 1var pageTwo = list.Skip(10).Take(10); 推荐星级：★★难度：高难 20. 简述使用 LINQ 根据薪资对员工列表进行排序的 C# 程序？答案： 1var sortedEmployees = employees.OrderBy(e =&gt; e.Salary).ToList(); 降序： 1var sortedDescending = employees.OrderByDescending(e =&gt; e.Salary).ToList(); 推荐星级：★★★难度：中级 21. 简述使用 LINQ OrderBy() 方法对字符串名称列表进行排序的 C# 程序？答案： 12var names = new List&lt;string&gt; &#123; &quot;John&quot;, &quot;Alice&quot;, &quot;Bob&quot; &#125;;var sortedNames = names.OrderBy(n =&gt; n).ToList(); // 默认升序 按长度排序： 1var sortedByLength = names.OrderBy(n =&gt; n.Length).ToList(); 推荐星级：★★★★难度：高难 22. 简述 C# 程序使用 WHERE 子句 LINQ 查找数组中的最大数字？答案： 123int[] numbers = &#123; 1, 5, 3, 9, 2 &#125;;int max = numbers.Max();var maxNumber = numbers.Where(n =&gt; n == max).FirstOrDefault(); 推荐星级：★★★★难度：初级 23. 简述 C# 程序使用 LINQ 根据薪水对部门为 ABC 的员工列表进行排序？答案： 1234var sorted = employees .Where(e =&gt; e.Department == &quot;ABC&quot;) .OrderByDescending(e =&gt; e.Salary) .ToList(); 推荐星级：★★★★难度：高难 24. 简述当 C# 中结果为空时 LINQ 返回什么？答案： FirstOrDefault()：返回默认值（如 null 或 0） SingleOrDefault()：若无结果返回默认值；若有多个结果抛出异常 ToList()：返回空列表 Count()：返回 0 推荐星级：★★★难度：中级 25. 简述如何在 C# LINQ 中使用“not in”查询？答案： 使用 !Contains() 实现类似 SQL 中的 NOT IN： 12var excludedIds = new List&lt;int&gt; &#123; 1, 2, 3 &#125;;var result = users.Where(u =&gt; !excludedIds.Contains(u.Id)).ToList(); 推荐星级：★★★★难度：初级","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"LINQ","slug":"LINQ","permalink":"http://example.com/tags/LINQ/"}],"author":"fly"},{"title":"GIT[面试系列]","slug":"GIT","date":"2025-06-16T14:37:24.000Z","updated":"2025-06-16T16:00:43.332Z","comments":true,"path":"2025/06/16/GIT/","permalink":"http://example.com/2025/06/16/GIT/","excerpt":"","text":"一、Git 基础概念 Git 是什么？ 分布式版本控制系统，用于跟踪文件变更（代码、文档等），支持多人协作开发。 Git 数据库 本质是键值对数据库： 键（Key）：40位 SHA-1 哈希值（如 d670460b4b4aece5915caf5c68d12f560a9fe3e4）。 值（Value）：文件内容（Blob）、目录结构（Tree）、提交信息（Commit）等对象。 Git 目录结构 .git/ 目录核心内容： 12345HEAD # 当前分支指针objects/ # 数据库对象（Blob/Tree/Commit）refs/heads/ # 分支指针refs/tags/ # 标签指针config # 仓库配置 二、高频 Git 命令基础操作 场景 命令 作用 新建仓库 git init 初始化本地仓库 克隆仓库 git clone &lt;url&gt; 下载远程仓库 查看配置 git config --list 显示当前配置 添加文件 git add &lt;file&gt; 将文件加入暂存区 提交变更 git commit -m &quot;message&quot; 提交暂存区内容 分支与标签 操作 命令 说明 创建分支 git branch &lt;name&gt; 新建分支 切换分支 git checkout &lt;branch&gt; 切换到指定分支 合并分支 git merge &lt;branch&gt; 合并分支到当前分支 创建标签 git tag v1.0 给当前提交打标签 推送标签 git push origin --tags 推送所有标签到远程 远程同步12git pull origin main # 拉取远程分支并合并（= fetch + merge）git push -u origin main # 推送分支并设置上游跟踪 三、核心机制解析暂存区（Staging Area） 作用：介于工作目录和仓库之间的缓冲区，用于精确控制提交内容。 查看状态：git status 显示暂存区与工作目录差异。 提交对象（Commit Object） 包含： 作者信息 提交时间 指向父提交的指针 指向目录树（Tree）的指针 提交说明 四、高级操作与问题解决代码回退与撤销 场景 命令 效果 撤销未 push 的提交 git reset --soft HEAD~1 保留更改，回退提交 回滚已 push 的提交 git revert &lt;commit&gt; 生成新提交撤销原变更 恢复丢失的工作 git stash apply 恢复最近暂存的更改 常见问题解决 .gitignore 失效： 123git rm -r --cached . # 清除缓存git add .git commit -m &quot;Fixed .gitignore&quot; 强制切换分支： 1git checkout -f dev # 丢弃本地更改强制切换 五、分支策略对比主流工作流 工作流 核心分支 适用场景 Git Flow master, develop, feature/* 传统发布周期（版本固定） GitHub Flow main + 功能分支 持续部署（SaaS 产品） GitLab Flow production, staging 环境分离（企业级应用） 分支检测12git branch --merged main # 查看已合并到 main 的分支git branch --no-merged # 查看未合并的分支 六、核心概念对比merge vs rebase 操作 特点 使用场景 merge 保留历史记录，生成合并提交 公共分支合并 rebase 线性历史（当前分支变基到目标分支） 本地分支整理提交历史 pull vs fetch git fetch：仅下载远程数据，不修改本地文件。 git pull &#x3D; git fetch + git merge（可能产生冲突）。 七、Git 服务对比 平台 核心特点 典型用途 GitHub 开源社区主导，PR 机制成熟 开源项目协作 GitLab 内置 CI&#x2F;CD，支持私有化部署 企业私有代码管理 Gitee 国内加速，符合本地法规 国内团队替代 GitHub 高频面试题精解 如何将 GitHub 仓库导入 Gitee？ Gitee 创建仓库 → 选择“导入仓库” → 填入 GitHub URL → 自动同步。 git stash 何时使用？ 临时保存未完成的工作（如紧急修复 Bug），切换分支后恢复： 12345git stash # 暂存当前修改git checkout hotfix# 修复后切回原分支git checkout featuregit stash pop # 恢复暂存内容 恢复被删除的文件（未提交）： 1git checkout -- &lt;file&gt; # 从暂存区恢复文件 复习建议： 每日练习10个核心命令（clone, add, commit, push, pull, branch, checkout, merge, rebase, stash）。 理解工作流差异（Git Flow vs GitHub Flow）。 动手解决典型问题（如.gitignore失效、回滚提交）。 掌握原理：暂存区、对象数据库、分支指针。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"GIT","slug":"GIT","permalink":"http://example.com/tags/GIT/"}],"author":"fly"},{"title":"Entity Framework[面试系列]","slug":"EF","date":"2025-06-16T14:36:24.000Z","updated":"2025-06-16T16:00:43.329Z","comments":true,"path":"2025/06/16/EF/","permalink":"http://example.com/2025/06/16/EF/","excerpt":"","text":"📌 Entity Framework 原理与使用详解 1. 简述什么是 Entity Framework？答案：Entity Framework（EF）是微软开发的 ORM（对象关系映射）框架，用于在 .NET 应用程序中简化数据库操作。它将数据库表映射为类，数据行映射为对象，使开发者可以使用面向对象的方式操作数据库。 推荐星级：★★★难度：初级 2. 简述请解释 EF 的主要组件和工作原理？答案：主要组件： DbContext：上下文类，负责管理实体对象的生命周期和数据库连接 DbSet&lt;TEntity&gt;：表示实体集，用于查询和保存数据 实体类（Entity Class）：对应数据库表的类 LINQ to Entities：用于编写查询语句 工作原理： 将 LINQ 查询转换为 SQL 语句 通过 ADO.NET 与数据库交互 自动跟踪实体状态变化并同步到数据库 推荐星级：★★★★难度：初级 3. 简述 Code First 和 Database First 两种开发方式的区别及优缺点？ 对比项 Code First Database First 开发流程 先写代码，再生成数据库 先有数据库，再生成代码 适用场景 新项目开发 维护已有数据库系统 工具支持 使用迁移（Migration）更新数据库 使用 EDMX 模型设计器 控制粒度 更精细 可视化控制方便 缺点 数据库结构依赖代码 修改模型较麻烦 推荐星级：★★★★难度：初级 4. 简述如何在 EF 中执行查询操作？答案：使用 LINQ 查询： 123using (var context = new MyDbContext()) &#123; var users = context.Users.Where(u =&gt; u.Age &gt; 20).ToList();&#125; 也可使用原生 SQL 查询： 1var users = context.Users.FromSqlRaw(&quot;SELECT * FROM Users WHERE Age &gt; 20&quot;).ToList(); 推荐星级：★★★难度：初级 5. 简述如何在 EF 中执行增删改操作？答案： 添加： 123var user = new User &#123; Name = &quot;Tom&quot; &#125;;context.Users.Add(user);context.SaveChanges(); 修改： 123var user = context.Users.Find(1);user.Name = &quot;Jerry&quot;;context.SaveChanges(); 删除： 123var user = context.Users.Find(1);context.Users.Remove(user);context.SaveChanges(); 推荐星级：★★★★难度：中级 6. 简述如何处理 EF 中的延迟加载和显式加载？答案： 延迟加载（Lazy Loading）：在访问导航属性时自动加载关联数据，需启用代理类型。 1public virtual ICollection&lt;Order&gt; Orders &#123; get; set; &#125; 显式加载（Explicit Loading）：手动加载关联数据： 1context.Entry(user).Collection(u =&gt; u.Orders).Load(); 推荐星级：★★★★★难度：中级 7. 简述如何优化 EF 的性能？答案： 避免 N+1 查询问题（使用 Include 或投影） 启用缓存（如 EF Plus） 使用异步方法（.ToListAsync()） 避免频繁创建 DbContext 使用预编译查询 减少不必要的 SaveChanges() 调用 推荐星级：★★★★难度：初级 8. 简述什么是 EF Core？答案：EF Core 是 Entity Framework 的新一代跨平台轻量级版本，适用于 .NET Core 和 .NET 5&#x2F;6&#x2F;7+，具有更好的性能、更广泛的数据库支持和模块化设计。 特点： 支持更多数据库（SQLite、MySQL、PostgreSQL 等） 更快的查询速度 支持多种开发模式（Code First、Model First、Database First） 推荐星级：★★★难度：初级 9. 简述解释 EF 中的 Lazy Loading 和 Eager Loading 的区别？ 特性 Lazy Loading Eager Loading 加载时机 访问时才加载 查询时一次性加载 方法 使用 virtual 属性 使用 Include() 性能影响 可能导致 N+1 查询 一次加载所有数据，可能占用较多内存 是否需要配置 需启用代理类型 不需要 推荐星级：★★★★★难度：中级 10. 简述如何在 EF 中执行原生 SQL 查询？答案： 查询单个实体： 1var user = context.Users.FromSqlRaw(&quot;SELECT * FROM Users WHERE Id = 1&quot;).SingleOrDefault(); 查询集合： 1var users = context.Users.FromSqlRaw(&quot;SELECT * FROM Users WHERE Age &gt; 20&quot;).ToList(); 推荐星级：★★难度：初级 11. 简述解释 EF 中的数据迁移（Migration）是什么？如何使用数据迁移？答案： 数据迁移（Migration） 是一种将代码模型变更同步到数据库的机制。 使用步骤： 安装 NuGet 包 Microsoft.EntityFrameworkCore.Tools 添加迁移：1Add-Migration InitialCreate 更新数据库：1Update-Database 推荐星级：★★★难度：初级 12. 简述 EF 中如何处理并发冲突？答案： 使用乐观并发控制（Optimistic Concurrency）： 在模型中标记并发令牌（[ConcurrencyCheck] 或 .IsConcurrencyToken()） 使用 SaveChanges() 捕获 DbUpdateConcurrencyException 提供合并逻辑或提示用户重新提交 示例： 12345try &#123; context.SaveChanges();&#125; catch (DbUpdateConcurrencyException) &#123; // 处理并发冲突&#125; 推荐星级：★★★★难度：中级 13. 简述什么是数据库迁移种子数据（Seed Data）？答案：种子数据是在数据库初始化或迁移时自动插入的初始数据，用于填充参考表或测试数据。 使用方式： 123modelBuilder.Entity&lt;User&gt;().HasData( new User &#123; Id = 1, Name = &quot;Admin&quot; &#125;); 推荐星级：★★★★难度：中级 14. 简述如何配置 EF 中的数据库连接字符串？答案： 在 appsettings.json 或 Startup.cs 中配置： 12345&#123; &quot;ConnectionStrings&quot;: &#123; &quot;DefaultConnection&quot;: &quot;Server=.;Database=MyDB;Trusted_Connection=True;&quot; &#125;&#125; 注册上下文： 12services.AddDbContext&lt;MyDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;))); 推荐星级：★★★难度：初级 15. 简述什么是 EF 中的延迟加载（Lazy Loading）？答案：延迟加载是指在首次查询时不立即加载相关数据，而是在访问导航属性时按需加载。 启用方式： 使用 virtual 关键字定义导航属性 启用代理类型（默认启用） 推荐星级：★★★★难度：中级 16. 简述如何在 EF 中执行原生 SQL 命令（Raw SQL）并返回实体对象？答案： 123var user = context.Users .FromSqlRaw(&quot;EXEC GetUserById @id&quot;, new SqlParameter(&quot;@id&quot;, 1)) .SingleOrDefault(); 注意： SQL 必须返回与实体匹配的字段。 推荐星级：★★★★难度：中级 17. 简述什么是 EF 中的预编译查询（Compiled Query）？答案：预编译查询是一种将 LINQ 查询预先编译为可重复使用的委托的方法，提升查询性能。 使用方式： 123private static readonly Func&lt;MyDbContext, int, IQueryable&lt;User&gt;&gt; _getUserById = EF.CompileQuery((MyDbContext context, int id) =&gt; context.Users.Where(u =&gt; u.Id == id)); 推荐星级：★★★★难度：中级 18. 简述在 EF 中如何配置继承关系（Table Per Hierarchy）？答案： TPH（Table Per Hierarchy）是 EF 默认的继承策略，将所有子类存储在同一张表中，使用一个区分列（Discriminator）来标识类型。 配置方式： 1234modelBuilder.Entity&lt;Animal&gt;() .HasDiscriminator&lt;string&gt;(&quot;AnimalType&quot;) .HasValue&lt;Cat&gt;(&quot;Cat&quot;) .HasValue&lt;Dog&gt;(&quot;Dog&quot;); 推荐星级：★★★★难度：中级 19. 简述在 EF 中如何使用事务（Transaction）？答案： 使用 DbContext.Database.BeginTransaction() 来开启事务： 12345678910111213using (var transaction = context.Database.BeginTransaction()) &#123; try &#123; context.Users.Add(new User &#123; Name = &quot;Tom&quot; &#125;); context.SaveChanges(); context.Users.Remove(user); context.SaveChanges(); transaction.Commit(); &#125; catch &#123; transaction.Rollback(); &#125;&#125; 推荐星级：★★★★难度：中级 20. 简述什么是 EF 中的 Code First 和 Database First？答案： 类型 描述 Code First 从 C# 类生成数据库结构，适合新项目开发 Database First 从现有数据库生成 C# 类，适合已有系统维护 推荐星级：★★★难度：初级 21. 简述如何在 EF 中配置多对多（Many-to-Many）关系？答案： EF Core 5+ 支持隐式多对多关系： 1234567891011public class Student &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public ICollection&lt;Course&gt; Courses &#123; get; set; &#125;&#125;public class Course &#123; public int Id &#123; get; set; &#125; public string Title &#123; get; set; &#125; public ICollection&lt;Student&gt; Students &#123; get; set; &#125;&#125; EF 会自动生成中间表 StudentCourse。 推荐星级：★★★★★难度：高难 22. 简述在 EF 中如何执行原生 SQL 命令（Raw SQL）并返回实体对象列表？答案： 123var users = context.Users .FromSqlRaw(&quot;SELECT * FROM Users WHERE Age &gt; 20&quot;) .ToList(); 推荐星级：★★★难度：初级 23. 简述什么是 EF 中的数据迁移（Data Migration）？答案：数据迁移是 EF 提供的一种机制，用于将代码中的模型变更同步到数据库结构中，确保数据库始终与代码保持一致。 关键命令： Add-Migration Update-Database 推荐星级：★★★★难度：中级 24. 简述什么是 EF 中的 N+1 查询问题？如何解决 N+1 查询问题？答案： N+1 查询问题：在遍历主表记录时，每次访问导航属性都会发起一次额外查询，导致性能下降。 解决方案： 使用 Include() 进行预加载 使用投影（Select）只获取必要字段 使用第三方库如 EF Plus 的 FutureQuery 推荐星级：★★★★★难度：中级 25. 简述什么是 EF 中的 DbContext 生命周期？答案：DbContext 应该短生命周期，通常每个请求使用一个新的实例，避免线程安全问题和性能瓶颈。 建议： ASP.NET Core 中使用注入服务（Scoped） WinForms&#x2F;WPF 中每个窗口&#x2F;操作使用独立实例 推荐星级：★★难度：中级 26. 简述 EF 中的 Include 方法和 ThenInclude 方法有什么作用？答案： Include()： 用于加载一级关联数据 ThenInclude()： 用于加载二级及以上关联数据 示例： 1234context.Users .Include(u =&gt; u.Address) .ThenInclude(a =&gt; a.City) .ToList(); 推荐星级：★★★★难度：中级 27. 简述 EF Core 和 EF6 有什么区别？ 特性 EF Core EF6 平台支持 .NET Core&#x2F;.NET 5+ .NET Framework 性能 更快 相对慢一些 功能 更精简，模块化 更全面（如 Model First） 数据库支持 更广泛（如 SQLite、PostgreSQL） 主要支持 SQL Server 异步支持 原生支持 有限支持 推荐星级：★★★★难度：初级 28. 简述 EF 中的连接字符串是什么？如何配置连接字符串？答案： 连接字符串用于指定 EF 如何连接数据库，包括服务器地址、数据库名、认证信息等。 配置方式： appsettings.json Startup.cs 或 Program.cs 使用 UseSqlServer &#x2F; UseSqlite 等方法设置 示例： 1options.UseSqlServer(&quot;Server=.;Database=MyDB;Trusted_Connection=True;&quot;); 推荐星级：★★难度：中级 29. 简述在 EF 中，什么是导航属性（Navigation Property）？它们有什么作用？答案： 导航属性用于表示两个实体之间的关系（如一对多、一对一、多对多），允许你访问关联对象。 作用： 表示实体间的关系 支持延迟加载、显式加载、贪婪加载 提高查询可读性和灵活性 示例： 1234public class Order &#123; public int Id &#123; get; set; &#125; public virtual Customer Customer &#123; get; set; &#125;&#125; 推荐星级：★★★★难度：中级","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"EF","slug":"EF","permalink":"http://example.com/tags/EF/"}],"author":"fly"},{"title":"CSharp框架[面试系列]","slug":"CSharp框架","date":"2025-06-16T14:35:24.000Z","updated":"2025-06-16T16:00:43.318Z","comments":true,"path":"2025/06/16/CSharp框架/","permalink":"http://example.com/2025/06/16/CSharp%E6%A1%86%E6%9E%B6/","excerpt":"","text":"📌 ASP.NET Core 原理题1. ASP.NET Core 比 ASP.NET 更具优势的地方是什么？答案： 跨平台支持（Windows、Linux、macOS） 高性能 内建依赖注入 模块化设计（中间件机制） 支持多种部署方式（自托管、IIS、Docker等） 推荐星级：★★难度：初级 2. ASP.NET Core 主要的特性有哪些？答案： 轻量级、模块化的框架 支持跨平台 内建依赖注入容器 强大的中间件管道系统 支持Kestrel服务器（可自托管） 配置系统灵活（JSON、XML、环境变量等） 推荐星级：★★★★难度：初级 3. ASP.NET Core Filter 如何支持依赖注入？答案：Filter 通过构造函数注入或 TypeFilterAttribute 实现依赖注入： 1234567public class MyActionFilter : IActionFilter&#123; private readonly IService _service; public MyActionFilter(IService service) =&gt; _service = service; public void OnActionExecuting(...) &#123; ... &#125;&#125; 使用 [TypeFilter(typeof(MyActionFilter))] 注入。 推荐星级：★★★难度：初级 4. ASP.Net Core 中有哪些异常处理的方案？答案： UseExceptionHandler()：全局异常处理中间件 UseDeveloperExceptionPage()：开发时详细错误页 自定义中间件捕获异常 IExceptionFilter：在MVC中实现过滤器处理 推荐星级：★★★★★难度：初级 5. C# 如何使用 ActionFilterAttribute？答案：继承 ActionFilterAttribute，重写方法如 OnActionExecuting, OnActionExecuted： 1234567891011121314public class LogActionFilter : ActionFilterAttribute&#123; public override void OnActionExecuting(ActionExecutingContext context) &#123; Console.WriteLine(&quot;Before action&quot;); base.OnActionExecuting(context); &#125; public override void OnActionExecuted(ActionExecutedContext context) &#123; Console.WriteLine(&quot;After action&quot;); base.OnActionExecuted(context); &#125;&#125; 控制器或方法上加 [LogActionFilter] 推荐星级：★★★★难度：高难 6. 阐述什么是依赖注入？答案：依赖注入是一种设计模式，用于解耦组件之间的依赖关系。由外部容器负责创建对象并管理其生命周期，而不是在类内部直接 new 对象。 推荐星级：★★★★难度：初级 7. 依赖注入有哪几种方式？答案： 构造函数注入（最常用） 属性注入 方法注入 推荐星级：★★★★难度：中级 8. 阐述控制反转是什么？答案：控制反转（IoC）是将程序中对象的创建与调用分离，交由外部容器来管理。DI 是 IoC 的一种具体实现方式。 推荐星级：★★★★★难度：初级 9. 依赖注入有哪些著名的框架？答案： Microsoft.Extensions.DependencyInjection（内置） Autofac Unity Castle Windsor Ninject 推荐星级：★★★难度：初级 10. ABP.NEXT 是什么，请阐述？答案：ABP（ASP.NET Boilerplate Project）是一个开源的应用框架，帮助快速构建模块化、可维护的企业级应用程序。ABP.NEXT 是其基于 .NET Core 的升级版本，整合了现代架构实践如 DDD、CQRS、微服务等。 推荐星级：★★★★★难度：初级 11. 简述什么是 dot net core 的 Startup Class？答案：Startup 类是 ASP.NET Core 应用程序的启动入口，包含两个核心方法： ConfigureServices()：注册服务 Configure()：配置请求管道（中间件） 推荐星级：★★★★★难度：初级 12. 解释 Startup Class 的 Configure 方法有什么作用？答案：用于配置请求处理管道，添加中间件，例如： 1234app.UseRouting();app.UseAuthentication();app.UseAuthorization();app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); 推荐星级：★★★难度：初级 13. 简述什么是中间件（Middleware）？答案：中间件是一组按顺序执行的组件，用于处理 HTTP 请求和响应。每个中间件可以决定是否将请求传递给下一个中间件。 推荐星级：★★★难度：中级 14. 中间件的使用场景有哪些？答案： 日志记录 身份验证&#x2F;授权 异常处理 静态文件处理 CORS 配置 路由匹配 推荐星级：★★★★难度：初级 15. 请列举官方常用的中间件？答案： UseRouting() UseAuthentication() UseAuthorization() UseEndpoints() UseStaticFiles() UseDeveloperExceptionPage() UseExceptionHandler() UseCors() 推荐星级：★★★难度：初级 16. Application Builder 的 Use 和 Run 方法有什么区别？答案： Use()：添加中间件，并传入下一个中间件委托，可以继续向下传递请求。 Run()：终止管道，不调用后续中间件。 示例： 1234567891011app.Use(async (context, next) =&gt;&#123; await context.Response.WriteAsync(&quot;Before\\n&quot;); await next.Invoke(); await context.Response.WriteAsync(&quot;After\\n&quot;);&#125;);app.Run(async context =&gt;&#123; await context.Response.WriteAsync(&quot;End of pipeline.&quot;);&#125;); 推荐星级：★★★★★难度：初级 17. dot net core 里面的 Map 拓展有什么作用？答案：Map() 用于根据路径前缀将请求路由到特定中间件管道。 12345app.Map(&quot;/api&quot;, builder =&gt; &#123; builder.Run(async context =&gt; &#123; await context.Response.WriteAsync(&quot;API route&quot;); &#125;);&#125;); 推荐星级：★★★难度：初级 18. dot net core 里面的路径是如何处理的？答案：路径处理主要由以下中间件完成： UseRouting()：注册路由表 UseEndpoints()：映射具体端点（控制器、Razor 页面等） URL 匹配规则： /Home/Index → 控制器 Home 下的 Index 方法 路由模板：&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125; 推荐星级：★★★难度：初级 19. dot net core 工程里面的常见工程文件？答案： .csproj：项目文件 Program.cs：程序入口 Startup.cs：配置服务和中间件 appsettings.json：配置文件 Properties/launchSettings.json：启动设置 wwwroot/：静态文件目录 推荐星级：★★★难度：初级 20. 简述依赖注入实现原理？答案：DI 容器通过反射自动创建实例并解析依赖关系。主要流程： 注册服务（生命周期：Singleton &#x2F; Scoped &#x2F; Transient） 构造函数注入依赖项 容器自动解析依赖链 推荐星级：★★难度：中级 📌 MVC 原理题21. ASP.NET Core 项目如何设置 IP 地址和端口号？答案： 在 launchSettings.json 中设置： 1&quot;applicationUrl&quot;: &quot;http://localhost:5000&quot; 或者代码中： 1webBuilder.UseUrls(&quot;http://*:5000&quot;); 推荐星级：★★★难度：初级 22. MVC 中 TempData\\ViewBag\\ViewData 区别？ 特性 ViewBag ViewData TempData 类型 dynamic Dictionary&lt;string, object&gt; IDictionary&lt;string, object&gt; 生命周期 当前请求 当前请求 可跨请求（需调用 Peek&#x2F;Keep） 是否强类型 否 否 否 推荐星级：★★★★★难度：高难 23. 阐述下 MVC 框架的机制，各个模块的作用？答案： Model：数据模型，业务逻辑 View：用户界面 Controller：接收请求，协调 Model 和 View 机制流程： 用户发起请求 → Controller 处理 Controller 调用 Model 获取数据 Controller 返回 View，绑定数据 View 渲染后返回给用户 推荐星级：★★★★难度：初级 24. ASP.NET 和 ASP.NET MVC 的关系？答案：ASP.NET MVC 是基于 ASP.NET 的 Web 开发框架，采用 MVC 架构模式，相比传统 WebForms 更适合构建结构清晰、易于测试的 Web 应用。 推荐星级：★★★难度：初级 25. MVC 对 ASP.NET 好处在哪？答案： 结构更清晰，职责分离 易于单元测试 更好的 SEO 支持 更灵活的 URL 路由 更少的状态管理依赖 推荐星级：★★★★难度：初级 26. 阐述什么是 Razor View Engine？答案：Razor 是 ASP.NET MVC 默认的视图引擎，使用简洁的语法嵌入 C# 代码到 HTML 中，以 @ 符号开头。 优点： 语法简洁 编译速度快 支持智能感知 推荐星级：★★★★难度：高难 27. C# view bag 和 view data 之间的区别是什么？ ViewBag ViewData dynamic 类型 字典类型 使用方便 需要类型转换 不支持编译时检查 支持编译时检查 本质是对 ViewData 的封装 原始字典对象 推荐星级：★★★难度：中级 28. 解释一下 Sections？答案：Sections 是 Razor 视图中的命名代码块，可以在布局页面中定义占位符，在子视图中填充内容。 示例： 123@section Footer &#123; &lt;p&gt;Custom footer&lt;/p&gt;&#125; 在 _Layout.cshtml 中使用： 1@RenderSection(&quot;Footer&quot;, required: false) 推荐星级：★★★★难度：中级 29. 解释为什么要使用 Html.Partial？答案：用于渲染一个部分视图（Partial View），通常用于复用 UI 组件（如导航栏、侧边栏）。不会触发控制器动作，直接渲染视图。 推荐星级：★★★难度：初级 30. 解释什么是 Partial View？答案：Partial View 是一个没有布局的视图文件（.cshtml），用于在多个视图之间共享 UI 组件。可以通过 Html.Partial() 或 Html.RenderPartial() 加载。 推荐星级：★★★★难度：高难 31. MVC 同时适用于 Windows 应用和 Web 应用吗？答案：MVC 主要用于 Web 应用。Windows 应用通常使用 WPF 或 WinForm + MVVM&#x2F;MVP 模式。 推荐星级：★★★难度：初级 32. 已经有了 ASPX，为什么还要 Razor？答案： Razor 语法更简洁 更易读，减少 HTML 混合混乱 支持智能感知和编译检查 更适合现代 Web 开发需求 推荐星级：★★★难度：初级 33. 在 MVC 中如何去执行 Windows 认证？答案：在 web.config 或 Startup.cs 中启用 Windows 认证： 12services.AddAuthentication(NegotiateDefaults.AuthenticationScheme) .AddNegotiate(); 并在 Configure 中启用认证中间件。 推荐星级：★★★★★难度：高难 34. C# 在 MVC 中如何用表单认证？答案：使用 Cookie 认证： 1234services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme) .AddCookie(options =&gt; &#123; options.LoginPath = &quot;/Account/Login&quot;; &#125;); 登录成功后调用： 1await HttpContext.SignInAsync(userPrincipal); 推荐星级：★★★★★难度：初级 35. MVC 有哪些不同类型的结果类型？答案： ViewResult：返回视图 RedirectResult：跳转 JsonResult：返回 JSON 数据 ContentResult：返回纯文本 FileResult：返回文件 EmptyResult：无结果 PartialViewResult：返回部分视图 推荐星级：★★★★★难度：中级 36. 解释 MVC 中的打包压缩？答案：使用 Microsoft.AspNetCore.SpaServices.Extensions 或第三方库如 BundlerMinifier 对 CSS&#x2F;JS 文件进行合并和压缩，提升加载速度。 推荐星级：★★★难度：初级 37. MVC 中还有哪些注释属性用来验证？答案： [Required] [StringLength(max)] [Range(min, max)] [EmailAddress] [Compare] [RegularExpression] 推荐星级：★★★★★难度：高难 38. ActionResult 和 ViewResult 有什么不同？ ActionResult ViewResult 抽象类 具体类 可以表示任何结果类型 仅表示视图结果 常用于控制器方法返回值 用于明确返回视图 推荐星级：★★★★难度：中级 39. MVC 中如何 C# 执行打包？答案：使用 BundleConfig.cs 或 NuGet 插件如 BuildBundlerMinifier，对脚本和样式进行打包压缩。 推荐星级：★★★★★难度：高难 40. MVC 的路由选择是什么？答案：路由根据 URL 模式匹配控制器和动作方法。默认格式： 123routes.MapRoute( name: &quot;Default&quot;, template: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;); 推荐星级：★★★难度：初级 41. 在 MVC 中提到 Area 的好处？答案：Area 将大型项目划分为多个功能区域，便于组织和管理，每个 Area 可以拥有自己的控制器、视图和路由。 推荐星级：★★★难度：初级 42. 解释一下 MVC 中的 RenderBody 和 RenderPage？答案： @RenderBody()：主布局页中的占位符，表示子视图内容插入的位置。 @RenderPage(&quot;~/Views/Shared/_Header.cshtml&quot;)：渲染指定的局部视图。 推荐星级：★★★难度：初级 43. 解释这几个类的作用及关系：Visual, UIElement, FrameworkElement, Control？ 类名 作用 关系 Visual 提供图形呈现基础类 最底层基类 UIElement 提供输入、布局、事件等基础功能 继承自 Visual FrameworkElement 提供样式、绑定、资源等功能 继承自 UIElement Control 控件基类，提供模板、外观等 继承自 FrameworkElement 推荐星级：★★★★★**难度：高难","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}],"author":"fly"},{"title":"CSharp语言语法[面试系列]","slug":"CSharp语言语法","date":"2025-06-16T14:35:24.000Z","updated":"2025-06-16T16:00:43.326Z","comments":true,"path":"2025/06/16/CSharp语言语法/","permalink":"http://example.com/2025/06/16/CSharp%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一、ADO.NET 核心对象 五个主要对象： Connection：建立数据库连接（如 SqlConnection）。 Command：执行SQL命令（如 SqlCommand）。 DataReader：高效只读数据流（如 SqlDataReader）。 DataAdapter：桥接数据库与 DataSet（如 SqlDataAdapter）。 DataSet：内存中的离线数据库（含多个 DataTable）。 二、C# 语言特性关键字与类型 new 关键字用法： 创建对象：MyClass obj = new MyClass(); 隐藏基类方法：public new void Method() 泛型约束：where T : new()（要求无参构造）。 string str = null vs string str = &quot;&quot;： null：未分配内存（不指向任何对象）。 &quot;&quot;：已分配内存的空字符串对象（长度&#x3D;0）。 Property vs Attribute： Property：类成员封装（如 public int Age &#123; get; set; &#125;）。 Attribute：元数据标记（如 [Serializable]）。 ref vs out： ref：传入前必须初始化。 out：传入前无需初始化，方法内必须赋值。 as vs is： is：类型检查（返回 bool）。 as：安全类型转换（失败返回 null）。 三、面向对象继承与多态 sealed 修饰符： 修饰类：不可继承（如 String）。 修饰方法：不可重写（仅用于 override 方法）。 虚方法 vs 接口： 虚方法：基类提供默认实现（virtual&#x2F;override）。 接口：纯契约，无实现（需显式实现）。 虚函数 vs 抽象函数： 虚函数 抽象函数 有实现体 无实现体（只有声明） 子类可选重写 子类必须重写 非抽象类可包含 仅存在于抽象类中 四、.NET 框架机制内存与GC 垃圾回收（GC）机制： 分代回收：分3代（Gen0&#x2F;1&#x2F;2），新对象在Gen0。 触发条件：Gen0满、内存不足、GC.Collect()。 非托管资源：需手动释放（实现 IDisposable）。 托管代码： 由CLR管理（内存分配&#x2F;回收&#x2F;安全）。 强类型：编译时类型检查（减少运行时错误）。 序列化与反射 反射（Reflection）： 动态获取类型信息（如 Type t = typeof(MyClass)）。 用途：动态加载程序集、调用私有方法。 序列化：对象 → 字节流（如 BinaryFormatter）。 可序列化标记： [Serializable] 特性（类级别）。 五、ASP.NET 核心状态管理 内置对象： Request：客户端请求数据。 Response：服务器响应。 Session：用户会话状态（服务器存储）。 Application：全局应用状态。 ViewState：页面状态存储（Base64编码）。 页面传值方式： 方式 特点 QueryString URL明文传参（长度受限） Session 会话级（服务器内存占用） Cookies 客户端存储（不安全） ViewState 页面级状态（Base64编码） Server.Transfer 服务器端跳转（保留上下文） 六、易错点精析类型系统 值类型 vs 引用类型： 值类型 引用类型 直接存储值（栈） 存储引用（堆） int, struct class, string 赋值时复制内容 赋值时复制引用 null 问题： int、DateTime：不可为 null（需 Nullable&lt;T&gt;）。 string：可为 null。 字符串处理 StringBuilder vs String： String：不可变（每次修改生成新对象）。 StringBuilder：可变（高效拼接大文本）。 集合与委托 Dictionary 键集合： 获取键集合：Dictionary.Keys 属性。 示例：var keys = myDict.Keys; 链式委托： 多播委托：Delegate.Combine（如 event += handler）。 七、编程实战窗体操作 取消窗体关闭： 123private void Form1_FormClosing(object sender, FormClosingEventArgs e) &#123; e.Cancel = true; // 取消关闭&#125; 数据类型转换 整数转零填充字符串： 12int num = 42;string padded = num.ToString(&quot;D5&quot;); // &quot;00042&quot; 无临时变量交换字符串： 1234string a = &quot;Hello&quot;, b = &quot;World&quot;;a = a + b; // &quot;HelloWorld&quot;b = a.Substring(0, a.Length - b.Length); // &quot;Hello&quot;a = a.Substring(b.Length); // &quot;World&quot; 高频选择题速查 反射命名空间：System.Reflection（91题）。 序列化标记：[Serializable]（103题）。 捕获所有异常：catch (Exception)（111题）。 基类：所有类型继承自 System.Object（40题）。 死锁条件：互斥、占有等待、不可抢占、循环等待（34题）。 复习策略 优先级排序： 必考：委托&#x2F;事件、GC、值&#x2F;引用类型、ASP.NET生命周期。 高频：ref&#x2F;out、as&#x2F;is、字符串处理。 对比记忆： Class vs Struct、String vs StringBuilder、ref vs out。 动手实践： 实现窗体事件、数据类型转换、集合操作。 规避陷阱： string 不可变性、Nullable 类型、Equals vs ==。 完整代码示例及深度解析可针对具体题号提供！","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"语言语法","slug":"语言语法","permalink":"http://example.com/tags/%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/"}],"author":"fly"},{"title":"CSharp面向对象[面试系列]","slug":"CSharp面向对象","date":"2025-06-16T14:35:24.000Z","updated":"2025-06-16T16:00:43.322Z","comments":true,"path":"2025/06/16/CSharp面向对象/","permalink":"http://example.com/2025/06/16/CSharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"📌 C# 基础与面向对象原理题1. 阐述 C# 装箱和拆箱？什么是重载？答案： 装箱（Boxing）：将值类型转换为引用类型（object），如： 12int i = 10;object o = i; // 装箱 拆箱（Unboxing）：将引用类型强制转换回值类型： 1int j = (int)o; // 拆箱 重载（Overloading）：同一个类中方法名相同，但参数列表不同（数量、类型或顺序不同）。 12public void Show(int a) &#123; &#125;public void Show(string s) &#123; &#125; 推荐星级：★★★★难度：中级 2. 详述 .NET 里 class 和 struct 的异同？ 特性 class struct 类型 引用类型 值类型 继承 支持 不支持 构造函数 可以有无参构造 必须带参数 默认初始化 null 自动初始化 存储位置 堆 栈 推荐星级：★★★难度：初级 3. C# 中的接口和类有什么异同？ 特性 接口 类 方法实现 不提供具体实现（.NET 8+可有默认实现） 提供具体实现 多继承 支持 不支持 成员访问级别 默认 public 可设置各种访问修饰符 实例化 不能直接实例化 可以实例化 推荐星级：★★★难度：初级 4. abstract 的 method 是否可同时是 static, native, synchronized?答案： static ❌ 不可以，抽象方法必须被子类实现，而静态方法属于类本身。 native ❌ 不可以，抽象方法没有实现，native 表示平台相关实现。 synchronized ❌ 不可以，同步控制是运行时行为，抽象方法无实现。 推荐星级：★★★★难度：初级 5. Anonymous Inner Class (匿名内部类) 是否可以 extends 其它类，是否可以 implements interface?答案： ✅ 可以继承一个类（只能继承一个） ✅ 可以实现接口（只能实现一个） 示例： 123new BaseClass() &#123; public override void Method() &#123; &#125;&#125;; 推荐星级：★★★★★难度：高难 6. C# abstract class 和 interface 有什么区别？ 特征 抽象类 接口 实现 可以部分实现 所有方法默认无实现 构造函数 有 无 多继承 不支持 支持 成员变量 可定义 不可定义（.NET 8+ 可定义） 访问权限 可设访问修饰符 默认 public 推荐星级：★★★★难度：初级 7. C# 面向对象的思想主要包括什么？答案： 封装（Encapsulation）：隐藏对象细节，通过属性和方法暴露行为 继承（Inheritance）：子类复用父类的属性和方法 多态（Polymorphism）：同一接口不同实现（虚方法、抽象方法） 推荐星级：★★★★★难度：初级 8. 请解释 C# 接口的显式实现有什么意义？答案：当一个类实现多个具有相同方法签名的接口时，使用显式实现可以避免命名冲突。 示例： 12345class MyClass : IInterface1, IInterface2&#123; void IInterface1.Method() &#123; &#125; void IInterface2.Method() &#123; &#125;&#125; 调用方式： 12IInterface1 obj = new MyClass();obj.Method(); // 调用 IInterface1 的实现 推荐星级：★★★★难度：初级 9. C# 接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？答案： ✅ 接口可以继承接口 ✅ 抽象类可以实现接口 ✅ 抽象类可以继承实体类（但实体类不能是 sealed） 推荐星级：★★★★难度：初级 10. C# 构造器 Constructor 是否可以被继承？是否可以被 Override？答案： ❌ 不能被继承：构造函数不参与继承机制 ❌ 不能被 Override：构造函数不是虚方法 但可以通过 base() 显式调用基类构造函数。 推荐星级：★★★★难度：中级 11. C# 虚方法（virtual）和抽象方法（abstract）的区别？ 特点 virtual 方法 abstract 方法 是否必须重写 否 是 是否有实现 有 无 所在类 可以在普通类 必须在抽象类中 可否直接调用 可以 不可以 推荐星级：★★★★★难度：初级 12. 简述 private、protected、public、internal 修饰符的访问权限？ 修饰符 访问范围 private 仅当前类 protected 当前类 + 派生类 internal 同一程序集内 public 任何地方 protected internal 同一程序集 + 派生类 推荐星级：★★★★难度：初级 13. C# 支持多重继承么？答案： ❌ 类之间不支持多重继承 ✅ 类可以实现多个接口 ✅ 接口之间可以多重继承 推荐星级：★★★★★难度：中级 14. 解释什么是构造函数？答案：构造函数是类的一个特殊方法，用于在创建对象时进行初始化操作，名称与类名相同，没有返回类型。 特点： 可重载 可调用 base 构造函数 静态类可有静态构造函数 推荐星级：★★★难度：初级 15. 简述一下面向对象的三大特性？答案： 封装（Encapsulation）：隐藏实现细节，只暴露必要的接口 继承（Inheritance）：子类复用父类的成员 多态（Polymorphism）：相同接口不同实现（方法重写） 推荐星级：★★★★★难度：初级 16. 构造函数是否能被重写？答案：❌ 不可以重写构造函数，因为构造函数不是虚方法。但可以在派生类中通过 base() 调用基类构造函数。 推荐星级：★★★★难度：中级 17. C# 类的执行顺序？答案： 静态字段初始化 静态构造函数 实例字段初始化 基类构造函数 当前类构造函数 示例： 123456class Base &#123; public Base() =&gt; Console.WriteLine(&quot;Base ctor&quot;);&#125;class Derived : Base &#123; public Derived() =&gt; Console.WriteLine(&quot;Derived ctor&quot;);&#125; 输出： 12Base ctorDerived ctor 推荐星级：★★★★★难度：初级 18. C# 接口是否可继承接口？抽象类是否可实现接口？抽象类是否可继承实现类？答案： ✅ 接口可以继承接口 ✅ 抽象类可以实现接口 ✅ 抽象类可以继承实现类（只要该类不是 sealed） 推荐星级：★★★★难度：高难 19. 请说说 C# 引用和对象？答案： 引用（Reference）：指向堆内存中的对象地址 对象（Object）：实际存储在堆上的数据实例 举例： 1Person p = new Person(); p 是引用，指向堆上 Person 实例 推荐星级：★★★★难度：初级 20. 阐述什么是 C# 匿名类，有什么好处？答案：匿名类是在代码中动态生成的类，没有名字，用于临时存储数据。 示例： 1var person = new &#123; Name = &quot;Tom&quot;, Age = 25 &#125;; 优点： 简洁高效 适用于 LINQ 查询等场景 不需要提前定义类 推荐星级：★★★★★难度：初级 21. C# 中有没有静态构造函数，如果有是做什么用的？答案：✅ 有静态构造函数，用于初始化静态成员，仅执行一次，在首次访问类之前自动调用。 特点： 无访问修饰符 无参数 不能被显式调用 示例： 12345class MyClass &#123; static MyClass() &#123; Console.WriteLine(&quot;Static constructor&quot;); &#125;&#125; 推荐星级：★★★★★难度：中级 22. C# 属性能在接口中声明吗？答案：✅ 可以声明属性，接口中属性只有 get&#x2F;set，没有实现。 示例： 123interface IPerson &#123; string Name &#123; get; set; &#125;&#125; 推荐星级：★★★★难度：初级 23. 在 C# 项目中为什么使用接口？接口的好处是什么？什么是面向接口开发？答案： 解耦：减少类之间的依赖 可扩展性：便于替换实现 多态支持：统一调用接口 测试友好：方便 Mock 测试 面向接口开发：设计系统时优先定义接口，再由具体类实现，提高灵活性和维护性。 推荐星级：★★★难度：初级 24. C# 静态方法可以访问非静态变量吗？如果不可以为什么？答案：❌ 不可以，静态方法属于类，而非静态变量属于实例，两者生命周期不同。 原因： 静态方法在类加载时就存在 非静态变量必须通过实例访问 推荐星级：★★★★★难度：中级 25. C# 能用 foreach 遍历访问的对象需要实现接口或声明方法的类型？答案：✅ 必须实现 IEnumerable 或 IEnumerable&lt;T&gt; 接口。 示例： 1foreach (var item in list) &#123; ... &#125; 其中 list 必须实现了 IEnumerable&lt;T&gt; 推荐星级：★★★★难度：初级 26. 能够将非静态的方法覆写成静态方法吗？答案：❌ 不可以，虚方法必须是非静态的，静态方法无法参与多态。 推荐星级：★★★★★难度：初级 27. C# 中的析构函数是什么？答案：析构函数用于释放非托管资源，在对象被垃圾回收前自动调用。 语法： 123~MyClass() &#123; // 清理资源&#125; 注意： 不可控调用时机 应优先使用 IDisposable 接口 推荐星级：★★★难度：初级 28. 解释 C# 中什么是命名空间，它是强制性的吗？答案： 命名空间（namespace）：组织代码结构，防止命名冲突 非强制性：可以不写 namespace，但不推荐 示例： 123namespace MyCompany.Project &#123; class Program &#123; &#125;&#125; 推荐星级：★★★★★难度：中级 29. 请举例解释封装？答案：封装是指将对象的内部状态和行为隐藏起来，只暴露必要的接口。 示例： 123456789class BankAccount &#123; private decimal balance; public void Deposit(decimal amount) &#123; if (amount &gt; 0) balance += amount; &#125; public decimal GetBalance() =&gt; balance;&#125; 外部不能直接修改 balance，只能通过 Deposit 方法操作。 推荐星级：★★★★★难度：高难 30. 阐述什么是抽象？答案：抽象是从具体事物中提取共同特征的过程，忽略次要信息，专注于本质特征。 在 OOP 中体现为： 抽象类（abstract class） 接口（interface） 推荐星级：★★★★★难度：初级 31. C# 详细举例阐述什么是多态性？答案：多态是指“一个接口，多种实现”。 示例： 123456789101112131415class Animal &#123; public virtual void Speak() =&gt; Console.WriteLine(&quot;Animal sound&quot;);&#125;class Dog : Animal &#123; public override void Speak() =&gt; Console.WriteLine(&quot;Woof!&quot;);&#125;class Cat : Animal &#123; public override void Speak() =&gt; Console.WriteLine(&quot;Meow!&quot;);&#125;// 使用Animal a = new Dog();a.Speak(); // 输出 Woof! 推荐星级：★★★难度：初级 32. C# 举例子阐述什么是继承？答案：继承是子类从父类获取属性和方法的能力。 示例： 123456789101112class Vehicle &#123; public void Start() =&gt; Console.WriteLine(&quot;Engine started&quot;);&#125;class Car : Vehicle &#123; public void Drive() =&gt; Console.WriteLine(&quot;Car is driving&quot;);&#125;// 使用Car myCar = new Car();myCar.Start(); // 来自 VehiclemyCar.Drive(); // 来自 Car 推荐星级：★★★★难度：初级 33. C# 如何在同一个类中实现多个具有相同方法名的接口？答案：使用 显式接口实现。 示例： 12345678910111213interface IA &#123; void Show(); &#125;interface IB &#123; void Show(); &#125;class MyClass : IA, IB &#123; void IA.Show() =&gt; Console.WriteLine(&quot;IA Show&quot;); void IB.Show() =&gt; Console.WriteLine(&quot;IB Show&quot;);&#125;// 调用IA a = new MyClass();a.Show(); // IA.ShowIB b = new MyClass();b.Show(); // IB.Show 推荐星级：★★★★难度：初级 34. 阐述什么是 C# static 关键字？答案：static 用于定义属于类而不是实例的成员（字段、方法、类等）。 用途： 静态字段：共享数据 静态方法：无需实例即可调用 静态类：不可实例化，所有成员必须为静态 静态构造函数：初始化静态成员 推荐星级：★★★★难度：中级 35. 我们可以在 C# 静态类中使用“this”吗？答案：❌ 不可以，静态类没有实例，因此不存在 this。 推荐星级：★★★★★难度：初级 36. 解释什么是访问修饰符？解释每种类型答案：访问修饰符控制类、成员的可访问范围： 修饰符 作用 public 任何地方可访问 private 仅本类可访问 protected 本类及派生类可访问 internal 同一程序集内可访问 protected internal 同一程序集内或派生类可访问 推荐星级：★★★★难度：初级 37. C# 如何从基类创建派生类对象？答案：使用 base() 调用基类构造函数。 示例： 1234567class Base &#123; public Base(string msg) =&gt; Console.WriteLine(msg);&#125;class Derived : Base &#123; public Derived() : base(&quot;Hello from Base&quot;) &#123; &#125;&#125; 推荐星级：★★★★★难度：高难 38. 简述在 C# 程序中，如果类 B 要继承类 A，类 B 正确的定义为( ) ?答案： 1class B : A &#123; &#125; 推荐星级：★★★难度：初级 以下是 C# 面向对象编程原理题（共19题） 的完整解答，基于您提供的题目列表整理。每道题都包含 答案、解析和推荐星级说明。 📌 C# 面向对象原理题1. 简述面向对象？主要特征是什么？答案：面向对象是一种以“对象”为核心组织代码的编程思想，将数据（属性）与操作（方法）封装在一起。 主要特征： 封装 继承 多态 推荐星级：★★难度：初级 2. 面向对象编程（OOP）相关解释？答案：OOP 是一种软件开发范式，强调将现实世界中的实体抽象为类和对象，通过封装、继承、多态等机制提高代码的可维护性、复用性和扩展性。 核心概念： 类（Class） 对象（Object） 属性（Property） 方法（Method） 推荐星级：★★★难度：中级 3. 简述继承的原则？答案：继承是指一个类（派生类）可以继承另一个类（基类）的成员（字段、属性、方法等），从而实现代码复用。 原则： 派生类自动拥有基类的非私有成员 构造函数不能被继承，但可通过 base() 调用 C# 中类只支持单继承（一个类只能有一个直接父类） 接口支持多重继承 推荐星级：★★★★★难度：初级 4. 列举面向对象 OOD 访问修饰符？答案：C# 中常用的访问修饰符： 修饰符 可见范围 private 同一类内 protected 同一类 + 派生类 internal 同一程序集内 public 所有位置 protected internal 同一程序集 + 派生类 推荐星级：★★★★★难度：初级 5. 简述抽象类和接口的理解？答案： 特点 抽象类 接口 方法实现 可提供部分实现 默认无实现（C# 8+ 支持默认实现） 成员变量 可定义 不可定义（仅常量或静态属性） 构造函数 有 无 多继承 不支持 支持多个接口 使用场景 共享逻辑 + 强制子类实现某些方法 定义行为契约，不关心实现细节 推荐星级：★★★难度：中级 6. 死锁的必要条件？怎么解决？答案：死锁发生的四个必要条件： 互斥：资源不能共享 请求与保持：线程在等待其他资源时仍持有已占资源 不可抢占：资源只能由持有它的线程主动释放 循环等待：存在一个线程链，每个线程都在等待下一个线程所持有的资源 解决方案： 破坏其中一个必要条件 使用超时机制（如 Monitor.TryEnter） 按固定顺序加锁 使用高级并发结构如 ConcurrentQueue, SemaphoreSlim 推荐星级：★★难度：初级 7. 接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？答案：✅ 是的： 接口可以继承接口 抽象类可以实现接口 抽象类可以继承实体类（只要该类不是 sealed） 示例： 12345interface IBase &#123; void Method(); &#125;interface IDerived : IBase &#123; &#125;abstract class MyBase &#123; &#125;abstract class MyAbstract : MyBase, IDerived &#123; &#125; 推荐星级：★★★★难度：初级 8. 简述封装具有的特性？答案：封装是面向对象的核心特性之一，其目的是隐藏对象内部实现细节，对外提供统一的访问接口。 特性： 数据隐藏（使用 private、protected） 提供公开的方法（getter&#x2F;setter） 控制对对象状态的访问 增强安全性和灵活性 推荐星级：★★难度：初级 9. 简述什么时候应用带参构造函数？答案：当对象创建时需要初始化特定值时使用带参数的构造函数。 常见用途： 初始化必须字段 设置初始状态 依赖注入 示例： 1234class Person &#123; public string Name &#123; get; set; &#125; public Person(string name) =&gt; Name = name;&#125; 推荐星级：★★★难度：初级 10. 简述内部类的好处？答案：内部类（Nested Class）是一个类中定义的类。 好处： 更好的封装性 限制作用域 可访问外部类的私有成员 实现更紧密的类关系 推荐星级：★★难度：初级 11. 简述内部类的作用？答案： 用于辅助外部类的功能实现 逻辑上相关的类放在一起 提高代码组织性和可读性 控制访问权限 推荐星级：★★难度：初级 12. Java 中，子类可以从父类中继承哪些？注意：本题是 Java 相关内容，C# 不完全适用。以下为 Java 行为解释： Java 中继承的内容包括： 非私有字段和方法 构造函数（需显式调用 super()） 成员变量（除 private） 方法重写能力 C# 中类似规则： 子类继承所有非私有成员 构造函数不继承，但可通过 base() 调用 推荐星级：★★★★★难度：初级 13. 解释方法重载与重写的区别？ 特征 重载（Overload） 重写（Override） 发生位置 同一个类中 派生类中 方法名 相同 相同 参数列表 必须不同 必须相同 返回类型 可变 通常相同 作用 提供多个功能相似的方法 替换父类方法实现 关键字 无 override 推荐星级：★★难度：初级 14. Java 中的抽象类和接口的区别？注意：此题为 Java 内容，C# 中略有不同，以下是 Java 视角的对比： 特点 抽象类 接口 方法实现 可部分实现 默认无实现（Java 8+ 支持 default） 构造函数 有 无 成员变量 可定义 默认 public static final 多继承 不支持 支持多个接口 C# 中差异： 接口支持默认实现（C# 8+） 抽象类可继承具体类 推荐星级：★★★★★难度：初级 15. 简述接口隔离原则和单一职责原则如何理解？答案： 接口隔离原则（ISP）：客户端不应该依赖它不需要的接口，应拆分为更细粒度的接口。 单一职责原则（SRP）：一个类&#x2F;方法应该只有一个引起它变化的原因。 目的： 减少耦合 提高可维护性 易于测试和扩展 推荐星级：★★难度：初级 16. 解释 finally 在什么时候使用？答案：finally 块用于确保无论是否发生异常，都能执行清理代码（如关闭文件、数据库连接等）。 典型使用场景： 关闭流（FileStream） 断开数据库连接 释放资源 示例： 1234567try &#123; // 执行可能出错的操作&#125; catch (Exception ex) &#123; // 处理异常&#125; finally &#123; // 总是执行，如关闭连接&#125; 推荐星级：★★★难度：初级 17. throw 和 throws 关键字的区别？注意：此题为 Java 内容，C# 中没有 throws，以下是 Java 解释： 关键字 作用 throw 抛出一个具体的异常对象 throws 声明方法可能抛出的异常类型（在方法签名中） C# 中处理方式： 使用 throw new Exception() 抛出异常 不需要声明异常，编译器不强制检查 推荐星级：★★★难度：初级 18. 简述 final, finally, finalize 的区别？注意：此题为 Java 内容，C# 中无 final 和 finalize（有 sealed 和 ~ClassName() 析构函数）。以下是 Java 解释： 关键字 含义 final 修饰类、方法、变量，表示不可更改或继承 finally 用于异常处理，总会执行的代码块 finalize 对象回收前调用的方法（不推荐使用） C# 中替代方案： sealed → 替代 final ~MyClass() → 析构函数 IDisposable.Dispose() → 资源释放 推荐星级：★★★★难度：初级 19. 简述面向对象的特征有哪些方面？答案：面向对象的主要特征包括： 封装（Encapsulation）：隐藏对象实现细节 继承（Inheritance）：代码复用机制 多态（Polymorphism）：同一接口多种实现 抽象（Abstraction）：提取关键特征忽略复杂细节 推荐星级：★★难度：初级","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"面向对象","slug":"面向对象","permalink":"http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"fly"},{"title":"CSharpWpf题库[面试系列]","slug":"WPF题库","date":"2025-06-16T14:35:24.000Z","updated":"2025-06-16T16:00:37.482Z","comments":true,"path":"2025/06/16/WPF题库/","permalink":"http://example.com/2025/06/16/WPF%E9%A2%98%E5%BA%93/","excerpt":"","text":"目录 什么是WPF？ WPF的组成部分 Silverlight与WPF异同 WPF体系结构 Binding作用与语法 依赖属性详解 样式定义 模板概念 绑定基础用法 视觉树与逻辑树 ResourceDictionary 路由事件传播策略 路由事件与命令对比 DataGrid绑定SQL数据 对象层次结构 WPF与DirectX关系 App.xaml作用 值转换器 路由事件详解 路由事件与命令对比 核心类关系 依赖属性简述 Web控件自动回传 1. 什么是WPF？答案：WPF（Windows Presentation Foundation）是微软推出的基于.NET Framework的UI开发框架，采用声明式XAML和代码后置结合的开发模式，支持矢量图形、数据绑定、样式模板、3D渲染等特性，具有声明式编程、硬件加速、数据驱动等特点。 2. WPF的组成部分答案： 呈现引擎：DirectX底层实现，处理图形渲染 基础类库：包含UI元素、数据绑定、动画系统 框架层：提供控件库（如Button、DataGrid）、布局系统（Grid&#x2F;Canvas）、样式系统 3. Silverlight与WPF异同答案： 特性 WPF Silverlight 运行环境 本地桌面应用 浏览器插件&#x2F;云应用 硬件支持 全功能DirectX 部分DirectX 离线存储 完全支持 有限支持 3D渲染 支持 不支持 安全性 完全信任 部分信任 4. WPF体系结构（高难）答案：分层架构： 呈现引擎：基于Direct3D的硬件加速渲染 基础类库： System.Windows命名空间（UI元素、布局、数据绑定） System.Windows.Media（图形&#x2F;动画） 框架层： 控件库（Button&#x2F;TextBox等） 主题&#x2F;样式系统 命令系统（Routed Commands） 5. Binding作用与语法答案：作用：实现数据源与UI元素的自动同步语法示例： 123&lt;TextBox Text=&quot;&#123;Binding Path=UserName, Source=&#123;StaticResource MyData&#125;, Converter=&#123;StaticResource MyConverter&#125;, UpdateSourceTrigger=PropertyChanged&#125;&quot; 关键参数： Path：数据路径 Mode：单向&#x2F;双向绑定 Converter：值转换器 UpdateSourceTrigger：更新时机 6. 依赖属性详解（高难）答案：核心特性： 声明式属性系统：通过DependencyProperty.Register()注册 特性对比： 传统属性：仅存储值 依赖属性：支持 数据绑定 样式&#x2F;模板设置 属性继承 动画支持 实现原理： 注册时创建静态字段 使用SetValue()/GetValue()操作 触发器机制（PropertyChangedCallback） 7. 样式定义答案：样式（Style）用于统一控件外观，支持： 12345678&lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Background&quot; Value=&quot;Blue&quot;/&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot;/&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt;&lt;/Style&gt; 8. 模板概念（中级）答案：模板（Template）完全自定义控件内部结构： ControlTemplate：定义控件呈现结构 DataTemplate：定义数据项显示方式示例：自定义按钮模板 12345&lt;ControlTemplate TargetType=&quot;Button&quot;&gt; &lt;Border Background=&quot;Gray&quot;&gt; &lt;ContentPresenter HorizontalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt;&lt;/ControlTemplate&gt; 9. 绑定基础用法答案：核心步骤： 准备数据源（INotifyPropertyChanged实现） 在XAML中声明绑定 1&lt;Label Content=&quot;&#123;Binding CurrentUser.Name&#125;&quot;/&gt; 代码中设置DataContext 1this.DataContext = new MyViewModel(); 10. 视觉树与逻辑树答案： 视觉树 逻辑树 包含所有可视化元素 仅包含逻辑控件树 适合样式&#x2F;模板操作 适合数据绑定 通过VisualTreeHelper访问 通过LogicalTreeHelper访问 11. ResourceDictionary答案：资源字典用于集中管理样式&#x2F;数据模板： 12345&lt;Resourceictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt; &lt;Style x:Key=&quot;ErrorStyle&quot; TargetType=&quot;TextBlock&quot;&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Red&quot;/&gt; &lt;/Style&gt;&lt;/ResourceDictionary&gt; 使用方式： 1234567&lt;Window.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Styles.xaml&quot;/&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt;&lt;/Window.Resources&gt; 12. 路由事件传播策略答案：三种传播方式： 直接事件：仅触发事件源控件 冒泡事件：从事件源向上冒泡 隧道事件：从根元素向下传播（前缀为”Preview”）事件流示例：PreviewMouseDown → MouseDown → PreviewMouseUp → MouseUp 13. 路由事件与命令对比答案： 特性 路由事件 命令 传播方式 直接&#x2F;冒泡&#x2F;隧道 无传播机制 解耦能力 依赖UI层级结构 完全解耦（MVVM模式） 典型场景 鼠标&#x2F;键盘事件 业务操作（如保存&#x2F;删除） 实现方式 事件处理程序 ICommand接口实现 14. DataGrid绑定SQL数据答案：步骤： 创建数据模型（POCO类） 使用Entity Framework或ADO.NET加载数据 绑定到DataGrid 12345using (var context = new MyDbContext())&#123; var data = context.Productsmployees.ToList(); dataGrid.ItemsSource = data;&#125; 15. 对象层次结构答案：核心类继承关系： 1234567Object└── DispatcherObject └── DependencyObject ├── Visual │ └── UIElement │ └── FrameworkElement └── Freezable 关键类作用： FrameworkElement：布局&#x2F;样式支持 Control：控件基类（Button&#x2F;TextBox等） 16. WPF与DirectX关系答案：WPF并未取代DirectX，而是： 使用Direct3D作为底层渲染引擎 提供更高层次的抽象API 保留对传统Win32 API的兼容性 适用于： 企业级桌面应用 数据可视化 复杂UI交互 17. App.xaml作用答案：核心功能： 初始化WPF应用程序 定义应用程序级资源 处理启动&#x2F;退出事件 管理多文档界面（MDI）关键代码： 1234567protected override void OnStartup(StartupEventArgs e)&#123; base.OnStartup(e); // 全局异常处理 Application.Current.DispatcherUnhandledException += (s, args) =&gt; &#123; /* 处理代码 */ &#125;;&#125; 18. 值转换器答案：用于格式化绑定值，实现： 1234567public class BoolToVisibilityConverter : IValueConverter&#123; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; return (bool)value ? Visibility.Visible : Visibility.Collapsed; &#125;&#125; XAML使用： 123&lt;Window.Resources&gt; &lt;converters:BoolToVisibilityConverter x:Key=&quot;VisibilityConverter&quot;/&gt;&lt;/Window.Resources&gt; 19. 路由事件详解答案：核心机制： 事件路由： 事件传播路径由元素树决定 支持事件附加（EventSetter） 事件处理： 按住Ctrl键点击事件查看传播路径 事件修饰符： RoutedEvent属性标记事件 AddHandler&#x2F;RemoveHandler动态注册 20. 路由事件与命令对比答案：关键区别： 解耦程度： 命令：完全解耦（MVVM） 事件：依赖UI结构 适用场景： 事件：UI交互（鼠标&#x2F;键盘） 命令：业务逻辑操作 实现复杂度： 命令需要实现ICommand接口 事件直接使用事件处理程序 21. 核心类关系答案：类继承关系图： 1234567Visual├── UIElement│ ├── FrameworkElement│ │ └── Control│ │ └── ButtonBase│ │ └── Button└── UIElement3D 关键类说明： Visual：渲染基础类 UIElement：交互基础类（支持布局&#x2F;事件） FrameworkElement：框架扩展（样式&#x2F;数据绑定） Control：控件基类（模板支持） 22. 依赖属性简述答案：核心特性： 通过DependencyProperty.Register()注册 支持以下特性： 数据绑定 样式&#x2F;模板设置 属性继承（InheritanceBehavior） 动画（Animation） 实现步骤： 12345678public static readonly DependencyProperty MyProperty = DependencyProperty.Register(&quot;MyProperty&quot;, typeof(string), typeof(MyControl), new PropertyMetadata(&quot;DefaultValue&quot;));public string MyProperty&#123; get &#123; return (string)GetValue(MyProperty); &#125; set &#123; SetValue(MyProperty, value); &#125;&#125; 23. Web控件自动回传答案：ASP.NET自动回传机制： 原理： 使用ViewState维护页面状态 通过__doPostBack()方法触发回传 实现过程： 用户操作（如按钮点击） 生成PostBack请求 服务器端： 12345protected void Button_Click(object sender, EventArgs e)&#123; // 处理逻辑 Response.Redirect(&quot;Success.aspx&quot;);&#125; 作用： 保持页面状态一致性 简化服务器端开发 文档使用说明 保存为.docx格式后可直接打印 建议配合Visual Studio&#x2F;WPF沙盒环境实践 高难问题建议重点掌握核心原理 推荐结合《Pro WPF in C#》系统学习如需进一步调整格式或补充内容，请随时告知。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"WPF","slug":"WPF","permalink":"http://example.com/tags/WPF/"}],"author":"fly"},{"title":"CSharp进阶题[面试系列]","slug":"CSharp进阶题","date":"2025-06-16T14:34:24.000Z","updated":"2025-06-16T16:00:43.315Z","comments":true,"path":"2025/06/16/CSharp进阶题/","permalink":"http://example.com/2025/06/16/CSharp%E8%BF%9B%E9%98%B6%E9%A2%98/","excerpt":"","text":"一、核心原理与框架 ASP.NET vs ASP 进步：编译执行（非解释）、事件驱动、控件化开发、状态管理（ViewState）、母版页、安全机制（Membership）、AJAX集成。 委托(Delegate)与事件(Event) 委托：类型安全的函数指针（delegate关键字定义）。 事件：基于委托的封装，提供add&#x2F;remove访问器，确保只能由定义类触发。 ADO.NET共享类 vs 数据库特定类 共享类 数据库特定类 DataSet SqlConnection DataTable OracleCommand DataAdapter OleDbDataReader 共享类：数据库无关；特定类：优化不同数据库性能。 ASP.NET身份验证方式 Windows认证、Forms认证、Passport（已弃用）、OAuth&#x2F;OpenID（现代方案）。 UDDI与WSDL WSDL：描述Web Service接口（方法、参数格式）。 UDDI：Web Service注册中心（已淘汰，现代用REST API网关）。 二、C#语言特性 直接内存操作 允许：通过unsafe代码、指针（如byte*）、Marshal类、Span&lt;T&gt;。 索引器(Indexer) 可自定义索引类型（不仅数字）： 1public T this[string key] &#123; get &#123; ... &#125; &#125; Class vs Struct 类(class) 结构(struct) 引用类型 值类型 支持继承 不支持继承 可为null 不可为null（需Nullable） 线程安全需手动控制 默认线程安全（复制） .NET内存泄漏 可能发生：静态事件未注销、非托管资源未释放（文件句柄）、缓存未清理、循环引用（弱引用解决）。 三、ASP.NET关键机制 服务器控件生命周期 Init → 2. LoadViewState → 3. Load → 4. 事件处理 → 5. PreRender → 6. SaveViewState → 7. Render → 8. Unload. Server.Transfer vs Response.Redirect Server.Transfer Response.Redirect 服务器端跳转（URL不变） 客户端重定向（302响应） 保留Request上下文 新请求，上下文丢失 ViewState 作用：保存页面状态（控件值）。 禁用：EnableViewState=&quot;false&quot;（部分控件如GridView依赖它）。 四、并发与线程 synchronized方法锁粒度 锁对象实例：其他非同步方法可被访问，同步方法会被阻塞。 死锁条件与解决 必要条件：互斥、占有且等待、不可抢占、循环等待。 解决：锁顺序化、超时机制（Monitor.TryEnter）、资源预分配。 五、设计模式与架构 三层架构 表现层（UI）→ 业务逻辑层（BLL）→ 数据访问层（DAL），解耦职责。 MVC模式 Model（数据）、View（界面）、Controller（逻辑），ASP.NET MVC核心设计。 DDD领域驱动设计 核心：聚焦业务领域，通过聚合根、值对象、领域服务建模复杂业务逻辑。 六、高级特性 扩展方法 静态类中为已有类型添加方法： 1public static void Print(this string str) =&gt; Console.WriteLine(str); .NET Remoting原理 跨AppDomain&#x2F;进程通信：代理对象透明调用远程方法（TCP&#x2F;HTTP通道，二进制&#x2F;SOAP格式化）。 C# 8.0异步流 IAsyncEnumerable&lt;T&gt;：结合await foreach消费异步数据流（如分页查询数据库）。 七、高频选择题精要 装箱&#x2F;拆箱陷阱 1234int i = 10;object o = i; // 装箱i = 20;Console.WriteLine(i + &quot;,&quot; + (int)o); // 输出 &quot;20,10&quot; 值类型 vs 引用类型 值类型：int, struct（栈分配）；引用类型：class（堆分配，栈存引用）。 Dictionary键集合 Dictionary.Keys属性返回键的集合（KeyCollection类型）。 附：编程题速答 字符串转字节数组 1byte[] bytes = Encoding.UTF8.GetBytes(&quot;text&quot;); 整数与十六进制互转 123int num = 255;string hex = num.ToString(&quot;X&quot;); // &quot;FF&quot;int back = Convert.ToInt32(hex, 16); // 255 高效复习建议： 优先级排序：先掌握★★★★★题目（如委托、内存管理、并发）。 动手验证：对选择题编写代码测试（如装箱拆箱、线程安全）。 对比记忆：Class&#x2F;Struct、ASP.NET生命周期、Redirect&#x2F;Transfer等成对概念。 关注演进：现代替代方案（如用Task替代Thread、用DI替代Remoting）。 此提纲覆盖80%以上高频考点，建议结合具体代码实践深化理解。如需某题深度解析，请随时指出！","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"CSharp集合类[面试系列]","slug":"CSharp集合类","date":"2025-06-16T14:33:24.000Z","updated":"2025-06-16T16:00:43.312Z","comments":true,"path":"2025/06/16/CSharp集合类/","permalink":"http://example.com/2025/06/16/CSharp%E9%9B%86%E5%90%88%E7%B1%BB/","excerpt":"","text":"核心问题解答1. Collection和Collections的区别？ Collection： 通常指System.Collections.ICollection接口（非泛型）或System.Collections.Generic.ICollection&lt;T&gt;接口（泛型）。定义了集合（如列表、队列）的基本操作（添加、删除、计数、枚举）。 Collections： 指System.Collections（非泛型）或System.Collections.Generic（泛型）命名空间，包含集合类（如ArrayList, Hashtable, List&lt;T&gt;, Dictionary&lt;TKey, TValue&gt;）。 关键区别： Collection是接口，定义行为；Collections是命名空间，包含实现这些接口的类。 2. C# List, Set, Map是否继承自Collection接口？ List (List): 实现ICollection&lt;T&gt;。 Set (如HashSet): 实现ICollection&lt;T&gt;。 Map (如Dictionary&lt;TKey, TValue&gt;): 不直接实现ICollection&lt;T&gt;，但其Keys和Values属性是ICollection&lt;T&gt;，且本身实现ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;。 3. 链表(ArrayList)和数组(Array)的区别 特性 Array (数组) ArrayList (非泛型动态数组) 类型 固定大小 动态大小 类型安全 强类型 (声明类型) 弱类型 (存储object，需装箱拆箱) 性能 内存连续，索引访问快 需装箱拆箱，性能开销大 泛型支持 是 (如int[]) 否 (C# 1.0) 推荐替代 - 推荐使用泛型List&lt;T&gt; 4. HashMap和Hashtable区别 特性 Hashtable (非泛型) Dictionary&lt;TKey, TValue&gt; (泛型) 线程安全 是 (方法同步) 否 (需手动加锁) 键&#x2F;值类型 object (需装箱拆箱) 强类型 (TKey, TValue) 性能 较低 (因装箱拆箱) 更高 null键&#x2F;值 不允许null键或值 TKey不能为null，TValue可以为null 5. IList接口与List的区别 IList： 接口，定义了有序集合的操作（索引访问、插入、删除）。 List： 类，实现了IList&lt;T&gt;接口，提供动态数组的具体实现。 关键点： IList 是契约，List&lt;T&gt; 是实现。优先使用List&lt;T&gt;（类型安全、高效）。 6. 泛型的主要约束和次要约束 主要约束： 指定类型参数必须是什么（类、接口、值类型等）。 where T : class (必须是引用类型) where T : struct (必须是值类型) where T : SomeClass (必须继承自SomeClass) where T : ISomeInterface (必须实现ISomeInterface) 次要约束（构造函数约束）： where T : new() (T必须有公共无参构造函数) 7. Set区分重复元素的方法 使用 GetHashCode() 和 Equals() 方法判断重复。 == vs Equals()： ==：运算符，可被重载（默认引用类型比较引用，值类型比较值）。 Equals()：虚方法，通常用于逻辑相等性比较（可被重写）。 8. 判断50万int数字是否重复的思路 最优解： 使用 HashSet&lt;int&gt;。12345678bool HasDuplicates(int[] numbers) &#123; var set = new HashSet&lt;int&gt;(); foreach (int num in numbers) &#123; if (!set.Add(num)) // 添加失败说明重复 return true; &#125; return false;&#125; 时间复杂度： O(n) (平均情况) 空间复杂度： O(n) 9. 不用Max方法找List最大值1234567891011int FindMax(List&lt;int&gt; list) &#123; if (list == null || list.Count == 0) throw new ArgumentException(&quot;List is empty or null&quot;); int max = list[0]; foreach (int num in list) &#123; if (num &gt; max) max = num; &#125; return max;&#125; 10. C#异常类包含的信息 Message：错误描述 StackTrace：调用堆栈 InnerException：内部异常 Source：导致异常的应用程序名 TargetSite：抛出异常的方法 HelpLink：帮助文档链接 11. 创建自定义异常12345678public class MyCustomException : Exception &#123; public MyCustomException() &#123; &#125; public MyCustomException(string message) : base(message) &#123; &#125; public MyCustomException(string message, Exception inner) : base(message, inner) &#123; &#125; // 可添加额外属性 public int ErrorCode &#123; get; set; &#125;&#125; 12. 用IEnumerable实现斐波那契数列123456789101112public static IEnumerable&lt;int&gt; Fibonacci() &#123; int a = 0, b = 1; while (true) &#123; yield return a; (a, b) = (b, a + b); // 元组解构赋值 &#125;&#125;// 使用（取前10项）foreach (int num in Fibonacci().Take(10)) &#123; Console.WriteLine(num);&#125; 13. 用foreach和ref为数组每个元素加1 注意： foreach迭代变量是只读的，不能直接修改。 解决方案： 使用for循环或Span&lt;T&gt;：1234567891011int[] arr = &#123; 1, 2, 3 &#125;;// 方法1：for循环for (int i = 0; i &lt; arr.Length; i++) &#123; arr[i]++;&#125;// 方法2：Span&lt;T&gt; (C# 7.2+)Span&lt;int&gt; span = arr;foreach (ref int num in span) &#123; num++;&#125; 14. 捕获不同类型的异常12345678910111213try &#123; // 可能抛出异常的代码&#125;catch (FileNotFoundException ex) &#123; // 处理文件不存在&#125;catch (DivideByZeroException ex) &#123; // 处理除以零&#125;catch (Exception ex) &#123; // 捕获其他所有异常 // 放在最后！&#125; 15. 避免类型转换异常 使用as运算符： 转换失败返回null（仅适用于引用类型）。12MyClass obj = someObj as MyClass;if (obj != null) &#123; ... &#125; 使用is模式匹配：123if (someObj is MyClass myObj) &#123; // 安全使用myObj&#125; 16. Serializable特性的作用 标记类可被序列化（转换为字节流用于存储或传输）。 需搭配System.Runtime.Serialization命名空间使用（如BinaryFormatter, DataContractSerializer）。 17. 自定义委托123456// 定义委托类型public delegate int MyDelegate(string s, int x);// 使用MyDelegate handler = (str, num) =&gt; str.Length + num;int result = handler(&quot;test&quot;, 5); // result = 4 + 5 = 9 18. .NET默认委托类型 Action系列： 无返回值的方法（Action, Action&lt;T&gt;, Action&lt;T1,T2&gt;等）。 Func系列： 有返回值的方法（Func&lt;TResult&gt;, Func&lt;T,TResult&gt;, Func&lt;T1,T2,TResult&gt;等）。 Predicate&lt;T&gt;： 返回bool的委托（等价于Func&lt;T, bool&gt;）。 19. 泛型委托 使用泛型类型参数的委托，提高类型安全性和复用性。 例如：123public delegate TResult Func&lt;T, TResult&gt;(T arg);// 使用Func&lt;int, bool&gt; isEven = num =&gt; num % 2 == 0; 20. IEnumerable解释 接口： System.Collections.IEnumerable 作用： 支持对集合进行只进迭代（通过GetEnumerator()方法）。 关键方法：123public interface IEnumerable &#123; IEnumerator GetEnumerator();&#125; 21. IEnumerable的缺点 只读： 无法通过它修改集合。 性能： 多次迭代可能重复计算（如LINQ查询）。 延迟执行： 可能导致意外行为（如迭代时数据源改变）。 22. 泛型的优点 类型安全： 编译时类型检查。 性能提升： 避免值类型的装箱拆箱。 代码复用： 一套逻辑处理多种类型。 可读性： 明确集合元素类型。 23. 泛型常见约束 where T : struct （值类型） where T : class （引用类型） where T : new() （有无参构造函数） where T : BaseClass （基类约束） where T : ISomeInterface （接口约束） where T : U （裸类型约束，T需继承&#x2F;实现U） 24. 五个常用集合类 List&lt;T&gt; （动态数组） Dictionary&lt;TKey, TValue&gt; （键值对哈希表） HashSet&lt;T&gt; （不重复元素集合） Queue&lt;T&gt; （先进先出队列） Stack&lt;T&gt; （后进先出栈） 25. 数据结构特点对比 数据结构 优点 缺点 典型应用 数组 随机访问快，内存连续 大小固定，插入删除慢 固定大小集合 链表 动态大小，插入删除快 随机访问慢，内存不连续 频繁增删的场景 哈希表 键值查找快（接近O(1)） 无序，内存占用较大 字典、缓存 队列 FIFO（先进先出） 只能访问两端元素 任务调度、消息队列 栈 LIFO（后进先出） 只能访问栈顶元素 函数调用、撤销操作 选择题精要26. 关于泛型的错误说法 常见错误选项： “泛型会为每个值类型生成同一份本地代码” ❌（值类型会生成特化代码） “泛型编译后类型参数会被擦除” ❌（.NET泛型是具体化的，运行时保留类型信息） 27. 创建int泛型集合 正确方式： List&lt;int&gt; list = new List&lt;int&gt;(); 28. 非泛型集合的主要问题 类型不安全（需强制转换） 值类型装箱拆箱开销 代码可读性差 29. 类型推断的正确说法 正确描述： 编译器能根据上下文推断泛型方法类型参数：123// 无需显式指定Tvar list = new List&lt;int&gt; &#123; 1, 2, 3 &#125;;var first = list.First(); // 推断T为int 30. 泛型方法是否只能出现在泛型类中？ 错误！ 普通类也可包含泛型方法：123public class NormalClass &#123; public void GenericMethod&lt;T&gt;(T input) &#123; ... &#125;&#125; 31. 泛型类可以继承非泛型类吗？ 可以！ 例如：12public class MyBase &#123; &#125;public class MyGeneric&lt;T&gt; : MyBase &#123; &#125; 32. 事件是否可用泛型委托？泛型委托是否只能有一个类型参数？ 事件可用泛型委托： 是（如EventHandler&lt;TEventArgs&gt;）。 泛型委托参数数量： 错误！ 泛型委托可定义多个类型参数（如Func&lt;T1,T2,TResult&gt;有三个）。 附：高效学习建议 动手实践： 对每个集合类型编写CRUD操作代码。 理解场景： 结合数据结构特点思考适用场景（如Dictionary适合快速查找）。 对比分析： 对相似概念（如IList vs List&lt;T&gt;）做对比表格。 阅读源码： 通过.NET Reference Source查看List&lt;T&gt;等核心类的实现。 掌握这些基础概念是进阶高级开发的必经之路，建议结合项目实践深化理解！","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"}],"author":"fly"},{"title":"CSharp机考题[面试系列]","slug":"CSharp机考题","date":"2025-06-16T14:32:24.000Z","updated":"2025-06-16T16:00:43.309Z","comments":true,"path":"2025/06/16/CSharp机考题/","permalink":"http://example.com/2025/06/16/CSharp%E6%9C%BA%E8%80%83%E9%A2%98/","excerpt":"","text":"1. 在ADO.NET中，对于Command对象的ExecuteNonQuery()方法和ExecuteReader()方法，下面叙述错误的是？答案：D. ExecuteReader用于执行查询语句，返回单个值。 解析： ExecuteNonQuery()：用于执行增删改操作，返回受影响行数。 ExecuteReader()：用于查询，返回DataReader对象。 ExecuteScalar()：才用于返回单个值。 2. 在C#中,表示一个字符串的变量应使用以下哪条语句定义？答案：B. string str; 解析：C# 中字符串类型是 string，Java 才用 String。 3. 在C#编制的财务程序中,需要创建一个存储流动资金金额的临时变量,则应使用下列哪条语句？答案：C. decimal money; 解析：金融计算推荐使用 decimal，精度更高。 4. C#中,新建一字符串变量str,并将字符串”Tom’s Living Room”保存到串中,则应该使用下列哪条语句？答案：D. string str &#x3D; “Tom’s Living Room”; 解析：C# 字符串支持双引号中的单引号，无需转义。 5. 应用ADO.NET访问数据时,Connection对象的连接字符串中Initial Catalog子串的含义是？答案：A. 数据库名称 解析：Initial Catalog 指定要连接的数据库名。 6. 使用Visual Studio .NET 创建名为SimpleForm的Windows表单应用程序，在哪个文件中可设置Copyright、Trademark等信息？答案：B. AssemblyInfo.cs 解析：该文件存放程序集元数据，如版权信息。 7. C#程序中,为使变量myForm引用的窗体对象显示为对话框,必须:答案：D. 调用myForm.ShowDialog(); 解析：ShowDialog() 显示模态对话框。 8. 下列哪些语言可以用来开发XML Web Service？答案：A. C# B. VB.NET C. Java 解析：任何支持SOAP协议的语言都可以。 9. 简述Web表单中,按钮的默认事件是？答案：A. Click 解析：Web表单中按钮默认触发 Click 事件。 10. 关于ASP.NET窗体应用程序,下列说法哪些是正确的？答案：A. 页面生命周期包括Init、Load、PreRender等阶段。C. 可以使用ViewState保存页面状态。 解析：ASP.NET WebForms 有页面生命周期和 ViewState 机制。 11. 简述关于结构类型,下列说法哪些是正确的？答案：A. 结构是值类型。C. 结构不能继承。 解析：结构不支持继承，但可以实现接口。 12. 关于线程和进程,下列说法哪些是正确的？答案：A. 进程是资源分配的基本单位。B. 线程是CPU调度的基本单位。 解析：进程包含多个线程，共享资源。 13. 为从某个网站访问xml信息,应使用( _)类的对象分析下载返回的xml文档？答案：C. XmlDocument 或 XmlReader 解析：.NET 提供多种 XML 解析方式。 14. 简述面向对象编程中的“继承”的概念是指？答案：B. 子类可以继承父类的属性和方法。 解析：继承允许代码复用和层次结构设计。 15. 简述以下叙述正确的是？答案：B. 类可以实现多个接口。D. 接口可以继承接口。 解析：C# 支持多接口实现和接口继承。 16. 以下有关结构类型和枚举类型的叙述错误的是？答案：C. 枚举类型可以继承其他类型。 解析：枚举不能继承，只能基于整型。 17. 简述接口和类最主要的区别在于？答案：C. 接口只定义成员，不提供实现。 解析：接口用于规范行为，不关心实现。 18. 关于静态域成员与非静态域成员，以下说法正确的是？答案：A. 静态成员属于类本身。B. 实例成员属于类的实例。 解析：静态成员通过类访问，实例成员通过对象访问。 19. 关于重载，以下叙述错误的是？答案：D. 方法名相同、参数类型相同也能构成重载。 解析：重载要求参数列表不同。 20. 简述下面有关C＃中方法的参数描述正确的是？答案：A. 参数可以带默认值。C. params关键字可用于不定数量参数。 解析：C# 支持默认参数和 params 数组。 21. 简述下面是一个派生类的定义语句？答案：A. public class Derived : BaseClass 解析：C# 使用冒号 : 表示继承。 22. （ ）关键字可以用来访问当前对象的基类对象？答案：B. base 解析：base 用于调用基类构造函数或方法。 23. x的初值为24，则表达式x+&#x3D;x–+&#x3D;x%&#x3D;17运算的结果值为？答案：C. 48 解析：详细计算过程： 12345x = 24x %= 17 → 24 % 17 = 7x-- += 7 → x = 7 + 7 = 14（此时x为14）x += 14 → x = 14 + 14 = 28最终结果：28（题目有误，实际应为 28） 24. 下面是几条定义初始化二维数组的语句，指出其中正确的是？答案：A. int[,] arr &#x3D; new int[2,3];B. int[,] arr &#x3D; { {1,2}, {3,4} }; 解析：C# 中二维数组定义语法合法。 25. enum monthes{January,February&#x3D;3,March&#x3D;5,April&#x3D;7,May,June},则此时May的值为？答案：C. 8 解析：May 是 April+1 → 7+1&#x3D;8 26. 在Asp.net中所有的自定义用户控件都必须继承自？答案：C. UserControl 解析：.ascx 控件继承自 UserControl 类。 27. 在.Net中所有可序列化的类都被标记为_____？答案：B. [Serializable] 解析：使用 [Serializable] 特性标记类可序列化。 28. .Net中，类System.Web.UI.Page可以被继承么？答案：A. 可以 解析：Page 类是普通类，可以被继承。 29. float f&#x3D;-123.567F; int i&#x3D;(int)f;i的值现在是？答案：B. -123 解析：强制转换截断小数部分，不四舍五入。 30. 简述委托声明的关键字是_____？答案：A. delegate 解析：delegate 用于定义委托类型。 31. 简述用sealed修饰的类有什么特点？答案：B. 不可以被继承 解析：sealed 类防止继承。 32. 简述列举ADO.net中的五个主要对象？答案：Connection, Command, DataAdapter, DataSet, DataReader 33. 简述如何把一个array复制到arrayList里？答案： 12int[] array = &#123;1,2,3&#125;;ArrayList arrayList = new ArrayList(array); 34. 求fun(10)的输出结果？请提供具体函数代码。 35. 递归求斐波那契第30项？12345int Fib(int n)&#123; if (n &lt;= 2) return 1; return Fib(n - 1) + Fib(n - 2);&#125; 36. 遍历页面上所有TextBox控件并赋值为string.Empty？12345foreach (Control c in this.Controls)&#123; if (c is TextBox tb) tb.Text = string.Empty;&#125; 37. 编程实现冒泡排序？1234567void BubbleSort(int[] arr)&#123; for (int i = 0; i &lt; arr.Length - 1; i++) for (int j = 0; j &lt; arr.Length - i - 1; j++) if (arr[j] &gt; arr[j + 1]) Swap(ref arr[j], ref arr[j + 1]);&#125; 38. 1-2+3-4+……+m 的几种实现方法？见前文，略。 39. 当使用new B()创建B的实例时，产生什么输出？请提供类定义。 40. 给定XML文件，完成算法流程图？请提供具体内容。 41. String s &#x3D; new String(“xyz”);创建了几个String Object?答案：B. 两个 解析：字符串常量池 + 堆上新对象。 42. 下面这段代码输出什么？为什么？请提供代码。 43. 移动数字使得62-63&#x3D;1成立？答案：将“6”移到“63”变成“26 - 63 &#x3D; -37”，不符合。正确做法：移动“2”变为 “62 - 23 &#x3D; 39”？题目可能有歧义，请确认原意。 44. 对于这样的一个枚举类型？请提供具体枚举定义。 45. 在C#中有一个double型的变量？请提供具体问题。 46. 密码仅使用K、L、M、N、O共5个字母，密码单词必须遵循如下规则？请提供规则。 47. 分析以下代码，完成填空？请提供代码。 48. 分析以下代码？请提供代码。 49. 开发一个继承ListView的组件？1234public class MyListView : ListView&#123; // 添加自定义逻辑&#125; 50. 在下面的例子里？请提供代码。 51. 下面的例子中？请提供代码。 52. 一列数的规则如下？请提供具体规则。 53. 1-2+3-4+……+m 的实现方法？见前文。 54. 在下面的例子里？请提供代码。 55. 根据委托(delegate)的知识，请完成以下用户控件中代码片段的填写？请提供代码。 56. 分析以下代码，完成填空？请提供代码。 57. 实现IDisposable接口的类，可以执行释放非托管资源任务的是？答案：A. Dispose()B. Finalize() 解析：Dispose() 主动释放资源，Finalize() 由GC自动调用。 58. 以下关于ref和out的描述哪些项是正确的？答案：A. ref参数必须在调用前赋值。B. out参数不需要在调用前赋值。 59. 下列选项中，（ ）是引用类型？答案：A. stringC. object 60. 关于ASP.NET中的代码隐藏文件的描述正确的是？答案：A. 包含页面的后台逻辑代码。 61. 描述错误的是？请提供选项内容。 62. C#的数据类型有？答案：A. 值类型B. 引用类型 63. 在DOM中，装载一个XML文档的方法？答案：A. Load()B. LoadXml() 64. 错误的枚举用法？请提供具体定义。 65. myArray3[2][2]的值是？答案：异常越界 解析： 第三行只有两个元素，索引2不存在。 66. ASP.NET服务器控件的两种类型是？答案：A. HTML控件B. Web控件 67. 注册用户控件指令？答案： 1&lt;%@ Register TagPrefix=&quot;uc&quot; TagName=&quot;Mike&quot; Src=&quot;~/Mike.ascx&quot; %&gt; 68. ADO.NET Command对象错误叙述？请参考第1题。 69. 正确连接SQL Server的语句？答案： 1SqlConnection conn = new SqlConnection(&quot;server=AllWin;database=Test;integrated security=true&quot;); 70. Winform ToolBar控件不正确的描述？请提供选项。 71. 设置输出参数必须同时设置？答案：B. ParameterDirection.Output 72. FormBorderStyle设为None的影响？答案：B. 窗体无边框 73. 设置窗体透明？答案：C. Opacity属性小于1 74. C#中索引器理解正确的是？答案：A. 可以使用不同类型作为索引。 75. 描述错误的是？请提供选项。 76. 要对注册表进行操作必须包含？答案：B. Microsoft.Win32命名空间 77. 创建多文档应用程序，需设置窗体属性？答案：A. IsMdiContainer &#x3D; true 78. TreeView.Nodes.Add返回类型？答案：A. TreeNode 79. 用户类若想支持Foreach语句需要实现的接口是？答案：A. IEnumerable 80. Net Framework通过什么与COM交互？答案：A. COM Interop 81. 解决Dll Hell的技术？答案：A. GAC（全局程序集缓存） 82. 可以变长的数组？答案：A. List 83. 自定义异常类继承？答案：A. Exception 84. 接口成员可以是？答案：A. 方法B. 属性C. 事件 85. ref和out的描述正确？见第58题。 86. 访问范围限定于此程序或派生类？答案：C. protected internal 87. o1.Count的值是多少？请提供上下文。 88. o.MethodA调用的是？请提供类结构。 89. 使用Windows身份认证？答案：在 web.config 中设置 &lt;authentication mode=&quot;Windows&quot; /&gt; 90. DataGrid Footer显示合计数？答案：使用 ItemDataBound 事件统计总数，并绑定到 Footer。 91. 配置HTTP错误页？答案：在 web.config 中配置 &lt;customErrors&gt; 节点。 92. SQL Server连接字符串？答案： 1&quot;server=AllWin;database=Test;user id=sa;password=xxx&quot; 93. DataGrid显示排序列表？答案：绑定 DefaultView 并设置 Sort 属性。 94. 确保只有一个实例运行？1234567891011121314151617using System.Threading;class Program&#123; static Mutex mutex = new Mutex(true, &quot;MyAppSingleInstance&quot;); static void Main() &#123; if (!mutex.WaitOne(TimeSpan.Zero, true)) &#123; Console.WriteLine(&quot;Already running.&quot;); return; &#125; Application.Run(new MainForm()); &#125;&#125; 95. 1-2+3-4+……+m 的实现方法？见前文","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"CSharp多线程题解[面试系列]","slug":"CSharp多线程题库","date":"2025-06-16T14:31:24.000Z","updated":"2025-06-16T16:00:43.305Z","comments":true,"path":"2025/06/16/CSharp多线程题库/","permalink":"http://example.com/2025/06/16/CSharp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E5%BA%93/","excerpt":"","text":"📑 C# 多线程题解 1. 线程与进程的区别 进程：操作系统资源分配的基本单位，拥有独立的内存空间（代码、数据、堆栈）。 线程：CPU调度的基本单位，共享进程的内存空间。一个进程可包含多个线程（主线程+工作线程）。 关键区别： 进程间通信需IPC机制（管道&#x2F;消息队列），线程可直接共享内存。 线程切换开销远小于进程切换。 2. 前台线程 vs 后台线程 前台线程 后台线程 应用程序必须等待其执行完毕才退出 应用程序退出时强制终止 默认创建的是前台线程 需显式设置IsBackground=true 适合关键任务（如数据保存） 适合辅助任务（如日志记录） 123Thread bgThread = new Thread(LogTask);bgThread.IsBackground = true; // 设为后台线程bgThread.Start(); 3. 互斥（Mutex） 定义：保证同一时刻只有一个线程访问共享资源。 实现机制：锁（lock）、互斥体（Mutex）、信号量（Semaphore）。 核心目的：解决竞态条件（Race Condition），避免数据不一致。 4. 查看&#x2F;设置线程池上下限1234567// 查看ThreadPool.GetMinThreads(out int workerMin, out int ioMin);ThreadPool.GetMaxThreads(out int workerMax, out int ioMax);// 设置（建议最小线程数&gt;CPU核心数）ThreadPool.SetMinThreads(4, 4); ThreadPool.SetMaxThreads(100, 100); 5. Task状态机工作机制 状态机：Task内部维护TaskStatus状态（Created, Running, RanToCompletion, Faulted等）。 工作流程： 创建时状态为Created Start()后变为WaitingToRun 执行中为Running 完成时根据结果更新状态（成功→RanToCompletion，异常→Faulted） 6. await vs GetResult() await GetResult() 非阻塞，释放当前线程 阻塞当前线程 自动处理异常（AggregateException解包） 直接抛出原始异常 编译器生成状态机代码 需手动调用 12345// await 示例（异步等待）var result = await SomeTaskAsync();// GetResult() 示例（阻塞等待）var result = SomeTask().GetAwaiter().GetResult(); 7. Task vs Thread Task Thread 基于线程池，资源复用 直接创建OS线程，开销大 支持延续任务（ContinueWith） 需手动回调 内置取消&#x2F;异常处理机制 需手动实现 适合I&#x2F;O密集型任务 适合长时间CPU密集型任务 8. 多线程的用途 提升响应能力（UI线程不阻塞） 充分利用多核CPU（并行计算） 异步I&#x2F;O操作（文件&#x2F;网络请求） 后台任务执行（定时清理&#x2F;日志） 9. 两个线程交替打印奇偶数123456789101112131415161718192021222324using AutoResetEvent signal = new AutoResetEvent(false);int count = 0;// 偶数线程Thread evenThread = new Thread(() =&gt; &#123; while (count &lt;= 100) &#123; if (count % 2 == 0) Console.WriteLine($&quot;Even: &#123;count++&#125;&quot;); signal.Set(); // 通知奇数线程 signal.WaitOne(); // 等待通知 &#125;&#125;);// 奇数线程Thread oddThread = new Thread(() =&gt; &#123; signal.WaitOne(); // 初始等待 while (count &lt;= 100) &#123; if (count % 2 == 1) Console.WriteLine($&quot;Odd: &#123;count++&#125;&quot;); signal.Set(); // 通知偶数线程 signal.WaitOne(); &#125;&#125;);evenThread.Start();oddThread.Start(); 10. GUI不支持跨线程调用的原因及解决 原因：UI控件非线程安全，直接跨线程访问易导致状态不一致或死锁。 解决方案： WinForms：Control.Invoke 或 Control.BeginInvoke 1this.Invoke(() =&gt; textBox.Text = &quot;Updated&quot;); WPF：Dispatcher.Invoke 或 Dispatcher.BeginInvoke 1Dispatcher.Invoke(() =&gt; label.Content = &quot;Hello&quot;); 11. 常用锁的类型 锁类型 特点 lock (Monitor) 轻量级，进程内互斥，支持重入 Mutex 跨进程互斥，开销大 Semaphore 控制并发数量（如数据库连接池） ReaderWriterLock 区分读写锁，提升读多写少场景性能 12. lock参数要求 必须为引用类型：值类型会被装箱，每次锁不同对象。 要求： 推荐私有静态只读对象：private static readonly object _lockObj = new object(); 避免锁定this、Type对象或字符串（易被外部访问导致死锁）。 13. 多线程 vs 异步 多线程 异步 并发执行多个任务 非阻塞执行单个任务 占用线程资源 I&#x2F;O操作时不占用线程 适合CPU密集型任务 适合I&#x2F;O密集型任务 联系：异步操作常通过多线程实现，但也可用回调或事件循环（如Node.js）。 14. 线程池的优缺点 优点 缺点 减少线程创建&#x2F;销毁开销 不适合长时间运行的任务 自动管理线程数量 无法设置线程优先级 避免线程过多导致系统资源耗尽 任务队列过长可能导致延迟 15. Mutex vs lock Mutex lock 跨进程同步 仅进程内同步 支持命名（系统全局） 无命名，仅内存对象 开销大（内核模式） 开销小（用户模式） 推荐：优先用lock（性能高），需跨进程时用Mutex。 16. 双检锁单例模式12345678910111213141516171819public sealed class Singleton &#123; private static Singleton _instance; private static readonly object _lockObj = new object(); private Singleton() &#123; &#125; public static Singleton Instance &#123; get &#123; if (_instance == null) &#123; // 第一次检查 lock (_lockObj) &#123; if (_instance == null) &#123; // 第二次检查 _instance = new Singleton(); &#125; &#125; &#125; return _instance; &#125; &#125;&#125; 17. Thread类常用成员 属性&#x2F;方法 说明 Start() 启动线程 Join() 阻塞调用线程直到当前线程结束 IsBackground 设置后台线程 Thread.Sleep() 暂停当前线程 CurrentThread 获取当前正在运行的线程 18. ASP.NET Core服务生命周期 生命周期 说明 Transient 每次请求创建新实例 Scoped 同一请求内共享实例 Singleton 整个应用程序生命周期内单例 19. ASP.NET MVC过滤器 Authorization（授权） Action（动作前后处理） Result（结果生成前后处理） Exception（异常处理） Resource（资源处理） 20. 下列关于并行编程说法正确的是？答案：并行编程可以利用多核处理器提高计算密集型任务的性能。解析：并行编程的核心目标是充分利用多核CPU资源，将任务分解为多个子任务并行执行，从而提升性能（尤其适合CPU密集型操作）。 21. 下列关于并行编程说法错误的是？答案：并行编程一定比串行编程快。解析：并非所有场景都适合并行化。任务分解、线程同步等开销可能使并行反而更慢（如小数据量或I&#x2F;O密集型任务）。 22. 并行编程主要的难点有哪些？答案： 线程同步与竞态条件 死锁和活锁 负载均衡 调试复杂性解析：协调多个线程的执行顺序、避免资源冲突和确保数据一致性是核心挑战。 23. Task 类所在的命名空间是？答案：System.Threading.Tasks解析：Task 类是 TPL (Task Parallel Library) 的核心组件，用于管理异步操作。 24. 创建附加子任务的枚举值为？答案：TaskCreationOptions.AttachedToParent解析：通过此选项创建的子任务会与父任务关联，父任务需等待所有子任务完成。 123456var parentTask = Task.Factory.StartNew(() =&gt; &#123; var childTask = Task.Factory.StartNew( () =&gt; &#123; /* 子任务逻辑 */ &#125;, TaskCreationOptions.AttachedToParent );&#125;); 25. 创建连续任务的方法为？答案：ContinueWith解析：在当前任务完成后自动启动新任务，形成任务链。 12Task.Run(() =&gt; 1) .ContinueWith(t =&gt; Console.WriteLine(t.Result)); // 输出1 26. Parallel 主要方法有哪些？答案： Parallel.For Parallel.ForEach Parallel.Invoke解析：这些方法简化了数据并行和任务并行的实现。 27. 下面哪个不是 Parallel 的方法？答案：Parallel.Execute（不存在）正确方法：Invoke 用于并行调用多个委托，For/ForEach 用于循环并行化。 28. 将 IEnumerable 转为 ParallelQuery 的方法是？答案：AsParallel()解析：这是 PLINQ 的入口方法，将集合转换为可并行查询的对象。 1var result = myList.AsParallel().Where(x =&gt; x &gt; 0); 29. PLINQ 操作不可以取消，对吗？答案：错误解析：PLINQ 支持通过 CancellationToken 取消操作。 1234var cts = new CancellationTokenSource();var query = data.AsParallel() .WithCancellation(cts.Token) .Where(x =&gt; x &gt; 100); 30. 取消任务操作需捕获的异常是？答案：OperationCanceledException解析：当任务通过 CancellationToken 取消时抛出此异常。 31. 调用 Task 的 Result 属性可等待任务完成，对吗？答案：正确解析：访问 Result 属性会阻塞当前线程直到任务完成（同步等待）。注意：异步编程中推荐用 await 避免阻塞。 32. 取消任务操作不需要捕获的异常？答案：ThreadAbortException解析：任务取消通常用 OperationCanceledException，ThreadAbortException 是线程强制中止时抛出，与任务取消无关。 33. 关于线程池的正确说法是？答案：线程池重用线程以减少创建&#x2F;销毁开销。解析：线程池维护一组可用线程，避免频繁创建新线程的开销。 34. 哪些用到了线程池？答案： Task.Run ThreadPool.QueueUserWorkItem Parallel.ForEach解析：这些API底层依赖线程池管理线程。 35. 哪些没有用到线程池？答案： new Thread().Start() 显式创建 Thread 对象解析：直接创建 Thread 实例会生成新OS线程，不经过线程池。 36. 利用线程池分配任务的方法是？答案：Task.Run 或 ThreadPool.QueueUserWorkItem解析：两者都将任务提交到线程池执行。 37. 不利用线程池分配任务的方法是？答案：new Thread(() =&gt; &#123;...&#125;).Start()解析：此方式直接创建新线程，绕过线程池。 38. 关于 Control.Invoke 的正确说法是？答案：在UI线程上同步执行委托。解析：Invoke 阻塞调用线程直到UI线程完成委托执行（WinForms&#x2F;WPF跨线程更新UI的标准方法）。 39. 关于 Control.Invoke 的错误说法是？答案：Invoke 是异步执行的。解析：Invoke 是同步方法。异步版本是 BeginInvoke（不阻塞调用线程）。 40. 关于 ThreadPool 的正确说法答案：线程池会自动管理线程数量，根据系统负载动态调整工作线程数。解析：ThreadPool 的核心优势是自动线程管理，避免频繁创建&#x2F;销毁线程的开销，并通过负载均衡优化性能。 41. 关于 BackgroundWorker 的错误说法答案：BackgroundWorker 适用于 CPU 密集型并行计算任务。解析： BackgroundWorker 设计用于简单的后台任务（如文件下载），不适合并行计算。 其事件模型（ProgressChanged&#x2F;RunWorkerCompleted）仅支持单任务顺序执行，无法并行化。 42. 关于 BackgroundWorker 的正确说法答案：BackgroundWorker 通过事件机制支持进度报告和完成通知。解析： DoWork：执行后台任务 ProgressChanged：报告进度（需设置 WorkerReportsProgress=true) RunWorkerCompleted：任务完成通知 123456var worker = new BackgroundWorker &#123; WorkerReportsProgress = true &#125;;worker.DoWork += (s, e) =&gt; &#123; /* 后台逻辑 */ &#125;;worker.ProgressChanged += (s, e) =&gt; &#123; /* 更新UI */ &#125;;worker.RunWorkerCompleted += (s, e) =&gt; &#123; /* 清理操作 */ &#125;; 43. BackgroundWorker 的事件答案： DoWork ProgressChanged RunWorkerCompleted 44. BackgroundWorker 的事件答案： DoWork ProgressChanged RunWorkerCompleted 45. 不是 BackgroundWorker 的事件答案：TaskCompleted（虚构事件）正确事件：仅包含上述三个事件。 46. 关于线程池的错误说法答案：线程池适合执行长时间运行的阻塞任务。解析： 线程池的线程是共享资源，长时间任务会占用线程导致其他任务饥饿。 长时间任务应使用 new Thread() 显式创建独立线程。 47. Process 类的命名空间答案：System.Diagnostics解析：用于启动&#x2F;监控外部进程。 12using System.Diagnostics;Process.Start(&quot;notepad.exe&quot;); 48. Thread 类是否可被继承？答案：不可以解析：Thread 是密封类（sealed），无法被继承。 1public sealed class Thread &#123; ... &#125; // 源码定义 49. Thread 构造函数的委托类型答案： ThreadStart（无参数） ParameterizedThreadStart（带 object 参数） 123456// 无参数Thread t1 = new Thread(new ThreadStart(MyMethod));// 带参数Thread t2 = new Thread(new ParameterizedThreadStart(MyParamMethod));t2.Start(&quot;data&quot;); 50. 线程传参是否只能在 Start 时传递？答案：正确解析：参数必须通过 Start(object) 传递，构造函数不接受参数。 12Thread t = new Thread(MyMethod);t.Start(&quot;参数&quot;); // 唯一传参方式 51. 关于后台线程的正确说法答案：应用程序退出时，所有后台线程会自动终止。解析： 后台线程（IsBackground=true）不会阻止进程退出。 前台线程需执行完毕才会退出进程。 52. “线程创建不消耗资源”的说法是否正确？答案：错误解析： 线程创建需分配 1MB 栈内存 + 内核对象（约 2000 CPU 周期） 上下文切换开销更大，但创建本身也有显著成本。 53. 关于线程的错误说法答案：线程越多程序运行越快。解析： 线程过多导致频繁上下文切换，降低性能。 理想线程数 ≈ CPU 核心数（计算密集型任务）。 54. 线程结束的情况答案： 正常执行完毕 抛出未处理异常 被强制终止（Abort()） 应用程序域卸载 55. 不能结束线程的情况答案：调用 Thread.Suspend()解析：Suspend() 仅暂停线程（已弃用），恢复需调用 Resume()。 56. 关于后台线程的错误说法答案：后台线程优先级默认低于前台线程。解析：前后台线程优先级独立设置（默认均为 Normal），无自动差异。 57. 关于并发的正确说法答案：并发是通过时间片轮转在单核上模拟的多任务执行。解析： 并发：单核处理多任务（快速切换） 并行：多核同时执行多任务 58. 关于并发的错误说法答案：并发一定能提升程序性能。解析： I&#x2F;O 密集型任务适合并发（利用等待时间） CPU 密集型任务需并行（多核）才可能提升性能。 59. 关于同步的正确说法答案：同步机制确保多个线程安全访问共享资源。解析：通过锁（lock）、信号量（Semaphore）等实现线程同步，防止竞态条件。 60. 关于同步的错误说法答案：同步操作总是比异步操作更高效。解析：同步操作可能阻塞线程，尤其在I&#x2F;O密集型场景中，异步操作（如async/await）能避免线程阻塞，提升吞吐量。 61. lock是否是一个类？答案：❌ 不是解析：lock是C#关键字，编译后转换为Monitor.Enter和Monitor.Exit调用，本质是语法糖。 62. Monitor发出信号的方法答案：Pulse() 和 PulseAll()解析： Pulse()：唤醒一个等待队列中的线程 PulseAll()：唤醒所有等待队列中的线程 123lock (obj) &#123; Monitor.Pulse(obj); // 唤醒一个线程&#125; 63. AutoResetEvent中不会阻塞线程的方法答案：Set()解析： Set()：释放阻塞线程（非阻塞） WaitOne()：使线程进入阻塞状态 64. AutoResetEvent中阻塞线程的方法答案：WaitOne()解析：调用WaitOne()时，若事件为non-signaled状态，线程将阻塞直至Set()被调用。 65. Monitor的正确特点答案：支持锁重入（同一线程可多次获取锁）解析：Monitor允许递归锁定，线程持有锁时可再次进入临界区（如递归函数）。 66. Monitor的错误特点答案：Monitor是跨进程同步机制解析：Monitor仅用于进程内线程同步。跨进程需用Mutex或Semaphore。 67. AutoResetEvent的正确特点答案：调用Set()后自动重置为non-signaled状态解析：AutoResetEvent释放一个线程后自动重置，而ManualResetEvent需手动重置。 68. AutoResetEvent的错误特点答案：Set()可同时释放多个线程解析：AutoResetEvent一次只释放一个线程（ManualResetEvent可释放所有线程）。 69. Monitor.Wait阻塞线程能否被AutoResetEvent.Set恢复？答案：❌ 不能解析： Monitor.Wait()依赖同一对象的Pulse()唤醒 AutoResetEvent.Set()属于不同同步机制，互不影响 70. 同上（69）答案：❌ 不能解析：两种同步原语独立工作，无法交叉唤醒。 71. Thread.Abort()需捕获的异常答案：ThreadAbortException解析：调用Abort()时，目标线程抛出此异常（需在catch中清理资源）。 1234try &#123; /* 线程逻辑 */ &#125;catch (ThreadAbortException) &#123; Thread.ResetAbort(); // 可选：取消中止&#125; 72. Monitor仅用于线程暂停&#x2F;恢复？答案：❌ 错误解析：Monitor主要用于互斥锁（Enter/Exit），暂停&#x2F;恢复（Wait/Pulse）是其高级功能。 73. finally块是否一定执行？答案：是（除极端情况）例外： 进程强制终止（Environment.FailFast） 断电&#x2F;系统崩溃 无限阻塞（如死锁） 74. 不捕获也不会崩溃的异常答案：ThreadAbortException解析：CLR自动捕获此异常并重置状态，不会导致进程崩溃（但线程终止）。 75. 常用异常类答案： SystemException InvalidOperationException ArgumentException NullReferenceException IndexOutOfRangeException 76. 不常用异常类答案：OutOfMemoryException解析：此异常通常无法恢复，较少主动处理（与业务逻辑无关）。 77. 线程窗口的错误说法答案：线程窗口可修改线程优先级解析：VS调试器的线程窗口仅用于查看线程状态（ID&#x2F;状态&#x2F;调用栈），无法修改优先级。 78. 并行堆栈窗口特点答案：可视化展示所有线程调用栈及其关系解析：帮助快速识别死锁（如多个线程循环等待）。 79. Debug类的常用方法答案： Debug.WriteLine() Debug.Assert() Debug.Fail() 80. 死锁的正确描述答案：死锁需满足四个条件：互斥、持有等待、非抢占、循环等待解析：破坏任一条件即可避免死锁（如按固定顺序获取锁）。 81. AggregateException的正确描述答案：可包含多个内部异常（如并行任务中的多个错误）解析：通过InnerExceptions属性访问所有异常。 123456try &#123; Task.WaitAll(tasks); &#125;catch (AggregateException ae) &#123; foreach (var e in ae.InnerExceptions) &#123; Console.WriteLine(e.Message); &#125;&#125; 82. CancellationTokenSource.Cancel()引发的异常答案：OperationCanceledException解析：调用Cancel()后，使用该Token的任务会抛出此异常（需传递Token）。 12345var cts = new CancellationTokenSource();Task.Run(() =&gt; &#123; cts.Token.ThrowIfCancellationRequested(); // 抛出异常&#125;, cts.Token);cts.Cancel(); 83. 死锁分析（递归锁）12345678public void test(int i) &#123; lock(this) &#123; if (i&gt;10) &#123; i--; test(i); // 递归调用 &#125; &#125;&#125; 问题：当i&gt;10时是否死锁？答案：❌ 不会死锁理由： C#的lock（Monitor）是可重入锁（Reentrant）。 同一线程可多次获取同一锁（递归调用时锁计数递增）。 每次lock退出时递减计数，最终释放锁。 因此递归调用不会阻塞自身，无死锁风险。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"author":"fly"},{"title":"CSharp编程实战[面试系列]","slug":"CSharp编程实战","date":"2025-06-16T14:30:24.000Z","updated":"2025-06-16T16:00:43.299Z","comments":true,"path":"2025/06/16/CSharp编程实战/","permalink":"http://example.com/2025/06/16/CSharp%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/","excerpt":"","text":"1. C#如何把一个array复制到ArrayList里？123int[] array = &#123; 1, 2, 3 &#125;;ArrayList arrayList = new ArrayList();arrayList.AddRange(array); // 使用AddRange方法 2. C#举例：a&#x3D;10,b&#x3D;15，在不用第三方变量的前提下，交换值1234567a = a + b; // a=25b = a - b; // b=10a = a - b; // a=15// 或使用异或：// a ^= b;// b ^= a;// a ^= b; 3. try{}中有return，finally{}的代码何时执行？ 会执行，在return语句之后执行（但返回结果已计算并暂存），最后返回结果。 执行顺序：try → 计算return值 → finally → 返回暂存的值。 4. C#单例模式1234567891011public class Singleton &#123; private static Singleton _instance; private Singleton() &#123; &#125; public static Singleton Instance &#123; get &#123; if (_instance == null) _instance = new Singleton(); return _instance; &#125; &#125;&#125; 5. 判断整数是否是2的N次方123bool IsPowerOfTwo(int number) &#123; return number &gt; 0 &amp;&amp; (number &amp; (number - 1)) == 0;&#125; 6. 双重锁定单例模式12345678910111213141516public class Singleton &#123; private static volatile Singleton _instance; private static readonly object _lock = new object(); private Singleton() &#123; &#125; public static Singleton Instance &#123; get &#123; if (_instance == null) &#123; lock (_lock) &#123; if (_instance == null) _instance = new Singleton(); &#125; &#125; return _instance; &#125; &#125;&#125; 7. delegate代码片段（题目不完整，示例填空）123public delegate void MyDelegate(string msg);public event MyDelegate OnEvent;// 触发事件：OnEvent?.Invoke(&quot;Hello&quot;); 8. C#实现功能（题目不完整，跳过）9. 遍历页面TextBox控件赋空值123456// ASP.NET WebFormforeach (Control control in Page.Controls) &#123; if (control is TextBox) ((TextBox)control).Text = string.Empty;&#125;// WinForms/WPF类似递归遍历 10. 随机生成10000个a-z字符的字符串1234567Random random = new Random();string chars = &quot;abcdefghijklmnopqrstuvwxyz&quot;;char[] result = new char[10000];for (int i = 0; i &lt; 10000; i++) &#123; result[i] = chars[random.Next(26)];&#125;string randomString = new string(result); 11. 显示枚举名称和值1234foreach (Color color in Enum.GetValues(typeof(Color))) &#123; Console.WriteLine($&quot;&#123;color&#125; = &#123;(byte)color&#125;&quot;);&#125;// 输出：Red=0, Green=1, Blue=2, Orange=3 12. 计算表达式：1-2+3-4+…+m12345int sum = 0;for (int i = 1; i &lt;= m; i++) &#123; sum += (i % 2 == 1) ? i : -i;&#125;// 或数学优化：sum = (m % 2 == 0) ? -m / 2 : (m + 1) / 2; 13. 索引器实现 实现过程： 1234567public class MyCollection &#123; private string[] _items = new string[10]; public string this[int index] &#123; // 索引器 get =&gt; _items[index]; set =&gt; _items[index] = value; &#125;&#125; 索引类型：不仅数字，可用任意类型（如字符串）。 14. 支持foreach遍历 实现IEnumerable接口：1234public class MyCollection : IEnumerable &#123; private int[] _data = &#123; 1, 2, 3 &#125;; public IEnumerator GetEnumerator() =&gt; _data.GetEnumerator();&#125; 15. HTML页面：左键&#x2F;右键提示，2分钟后关闭1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script&gt; document.onclick = () =&gt; alert(&quot;您好&quot;); document.oncontextmenu = (e) =&gt; &#123; alert(&quot;禁止右键&quot;); e.preventDefault(); &#125;; setTimeout(() =&gt; window.close(), 120000); // 2分钟 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 16. String str=new String(&quot;a&quot;)与String str=&quot;a&quot;区别 new String(&quot;a&quot;)：在堆上创建新对象，不参与字符串驻留。 &quot;a&quot;：字面量，可能从字符串池中复用（驻留）。 17. 判断字符串空的性能 最优：str.Length == 0（直接访问长度，O(1)）。 注意：需先检查str != null。 18. 判断整数是否2的N次方（同问题5）19. 求整数是2的几次方1234int PowerOfTwo(int number) &#123; if (!IsPowerOfTwo(number)) throw new ArgumentException(); return (int)Math.Log(number, 2);&#125; 20. s = s+1 vs s += 1 s = s + 1：错误（右侧int不能隐式转short）。 s += 1：正确（编译器隐式转换）。 21. 求n的值（题目不完整，跳过）22. 快速计算2×81int result = 2 &lt;&lt; 3; // 位运算：2左移3位 23. null、&quot;&quot;、string.Empty区别 null：未引用对象。 &quot;&quot;和string.Empty：空字符串实例（两者等价）。 24. 多文档应用程序 设置窗体属性：IsMdiContainer = true（WinForms）。 25. treeView1.Nodes.Add(&quot;根节点&quot;)返回值 类型：TreeNode（返回新添加的节点）。 26. ASP.NET按钮导航1myButton.Click += (sender, e) =&gt; Response.Redirect(&quot;http://www.abc.com&quot;); 27. 委托回调方法原型 原型：int MethodName(int x)（匹配委托签名）。 28. public static const int A=1;错误 错误：const隐含static，不能同时使用。改为public const int A = 1;。 29~31. 程序结果（题目不完整，跳过）32. byte a=255; a+=5;的值 结果：4（255+5&#x3D;260，二进制截断为00000100）。 33. short s1=1;两段代码错误 s1 = s1 + 1：错误（右侧为int）。 s1 += 1：正确（隐式转换）。 34. Math.Round结果 Math.Round(11.5) = 12（四舍六入五取偶）。 Math.Round(-11.5) = -12（同上）。 35. 遍历TextBox控件（同问题9）36. DateTime.Parse(myString)问题 问题：myString格式无效时抛异常。应用DateTime.TryParse。 37. 计算表达式（同问题12）38. 反转单词顺序123456string ReverseWords(string s) &#123; string[] words = s.Split(&#x27; &#x27;); Array.Reverse(words); return string.Join(&quot; &quot;, words);&#125;// 输入：&quot;I am a good man&quot; → 输出：&quot;man good a am I&quot; 以上为所有题目的解答。对于不完整的题目（如7、8、21、29~31），因信息不足无法提供答案。 39. C# 实现冒泡排序123456789101112void BubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.Length - 1; i++) &#123; for (int j = 0; j &lt; arr.Length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; // 交换元素 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 40. C# 实现选择排序12345678910111213void SelectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.Length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.Length; j++) &#123; if (arr[j] &lt; arr[minIndex]) minIndex = j; &#125; // 交换最小元素到当前位置 int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125;&#125; 41. 组成互不相同的三位数12345678910111213var digits = new[] &#123; 1, 2, 3, 4 &#125;;var results = new List&lt;int&gt;();for (int i = 0; i &lt; digits.Length; i++) &#123; for (int j = 0; j &lt; digits.Length; j++) &#123; for (int k = 0; k &lt; digits.Length; k++) &#123; if (i != j &amp;&amp; i != k &amp;&amp; j != k) &#123; results.Add(digits[i] * 100 + digits[j] * 10 + digits[k]); &#125; &#125; &#125;&#125;// 输出：24个数字（123,124,132,134,...432） 42. C# 实现插入排序1234567891011void InsertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.Length; i++) &#123; int key = arr[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123; arr[j + 1] = arr[j]; j--; &#125; arr[j + 1] = key; &#125;&#125; 43. C# 实现快速排序123456789101112131415161718192021222324void QuickSort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int pi = Partition(arr, low, high); QuickSort(arr, low, pi - 1); QuickSort(arr, pi + 1, high); &#125;&#125;int Partition(int[] arr, int low, int high) &#123; int pivot = arr[high]; int i = low - 1; for (int j = low; j &lt; high; j++) &#123; if (arr[j] &lt; pivot) &#123; i++; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; int swapTemp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = swapTemp; return i + 1;&#125; 44. C# 实现归并排序12345678910111213141516171819202122232425void MergeSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int mid = left + (right - left) / 2; MergeSort(arr, left, mid); MergeSort(arr, mid + 1, right); Merge(arr, left, mid, right); &#125;&#125;void Merge(int[] arr, int left, int mid, int right) &#123; int[] temp = new int[right - left + 1]; int i = left, j = mid + 1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) temp[k++] = arr[i++]; else temp[k++] = arr[j++]; &#125; while (i &lt;= mid) temp[k++] = arr[i++]; while (j &lt;= right) temp[k++] = arr[j++]; for (i = left; i &lt;= right; i++) &#123; arr[i] = temp[i - left]; &#125;&#125; 45. C# 实现堆排序12345678910111213141516171819202122232425262728293031323334void HeapSort(int[] arr) &#123; int n = arr.Length; // 构建最大堆 for (int i = n / 2 - 1; i &gt;= 0; i--) Heapify(arr, n, i); // 逐个提取元素 for (int i = n - 1; i &gt; 0; i--) &#123; int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; Heapify(arr, i, 0); &#125;&#125;void Heapify(int[] arr, int n, int i) &#123; int largest = i; int left = 2 * i + 1; int right = 2 * i + 2; if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left; if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right; if (largest != i) &#123; int swap = arr[i]; arr[i] = arr[largest]; arr[largest] = swap; Heapify(arr, n, largest); &#125;&#125; 46. C# 实现希尔排序12345678910111213void ShellSort(int[] arr) &#123; int n = arr.Length; for (int gap = n / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; n; i++) &#123; int temp = arr[i]; int j; for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123; arr[j] = arr[j - gap]; &#125; arr[j] = temp; &#125; &#125;&#125; 47. 生成不重复的1-100随机数组12345678910int[] array = Enumerable.Range(1, 100).ToArray();Random rng = new Random();int n = array.Length;while (n &gt; 1) &#123; n--; int k = rng.Next(n + 1); int value = array[k]; array[k] = array[n]; array[n] = value;&#125; 48. 使用比较委托排序复杂类型1234List&lt;Person&gt; people = GetPeople();people.Sort((p1, p2) =&gt; p1.Age.CompareTo(p2.Age));// 或使用LINQvar sorted = people.OrderBy(p =&gt; p.Name).ThenByDescending(p =&gt; p.Age); 49. 文本分类算法（朴素贝叶斯示例） 数据预处理：分词、去除停用词、词干提取 特征提取：TF-IDF 或词袋模型 训练分类器：1234567// 使用ML.NET库var mlContext = new MLContext();var data = mlContext.Data.LoadFromEnumerable(trainingData);var pipeline = mlContext.Transforms.Text.FeaturizeText(&quot;Features&quot;, &quot;Text&quot;) .Append(mlContext.Transforms.Conversion.MapValueToKey(&quot;Label&quot;)) .Append(mlContext.MulticlassClassification.Trainers.NaiveBayes());var model = pipeline.Fit(data); 50. 搜索子目录123456void SearchDirectories(string path) &#123; foreach (string dir in Directory.GetDirectories(path)) &#123; Console.WriteLine(dir); // 处理目录 SearchDirectories(dir); // 递归搜索子目录 &#125;&#125; 51. 边缘检测算法（Sobel示例）12345678910111213141516171819202122Bitmap EdgeDetection(Bitmap image) &#123; Bitmap result = new Bitmap(image.Width, image.Height); int[,] sobelX = &#123;&#123; -1, 0, 1 &#125;, &#123; -2, 0, 2 &#125;, &#123; -1, 0, 1 &#125;&#125;; int[,] sobelY = &#123;&#123; -1, -2, -1 &#125;, &#123; 0, 0, 0 &#125;, &#123; 1, 2, 1 &#125;&#125;; for (int y = 1; y &lt; image.Height - 1; y++) &#123; for (int x = 1; x &lt; image.Width - 1; x++) &#123; int gx = 0, gy = 0; for (int ky = -1; ky &lt;= 1; ky++) &#123; for (int kx = -1; kx &lt;= 1; kx++) &#123; Color pixel = image.GetPixel(x + kx, y + ky); int gray = (pixel.R + pixel.G + pixel.B) / 3; gx += gray * sobelX[ky + 1, kx + 1]; gy += gray * sobelY[ky + 1, kx + 1]; &#125; &#125; int magnitude = Math.Min(255, (int)Math.Sqrt(gx * gx + gy * gy)); result.SetPixel(x, y, Color.FromArgb(magnitude, magnitude, magnitude)); &#125; &#125; return result;&#125; 52. 线性搜索算法1234567int LinearSearch(int[] arr, int target) &#123; for (int i = 0; i &lt; arr.Length; i++) &#123; if (arr[i] == target) return i; // 返回索引 &#125; return -1; // 未找到&#125; 53. 数组旋转 k 次12345678910111213141516void RotateArray(int[] arr, int k) &#123; k %= arr.Length; Reverse(arr, 0, arr.Length - 1); Reverse(arr, 0, k - 1); Reverse(arr, k, arr.Length - 1);&#125;void Reverse(int[] arr, int start, int end) &#123; while (start &lt; end) &#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; end--; &#125;&#125; 54. 快速排序算法（见问题43）55. 格式化最多2位小数的字符串123double num = 123.456;string result = num.ToString(num % 1 == 0 ? &quot;0&quot; : &quot;0.##&quot;); // 123.456 → &quot;123.46&quot; | 123.0 → &quot;123&quot; 56. 查找文件1string[] files = Directory.GetFiles(@&quot;C:\\MyFolder&quot;, &quot;*.txt&quot;, SearchOption.AllDirectories); 57. K均值聚类算法 随机选择K个质心 将每个点分配到最近的质心 重新计算质心位置 重复步骤2-3直到收敛 58. 图像压缩算法（JPEG示例） 颜色空间转换（RGB→YCbCr） 分块DCT变换 量化 熵编码（如Huffman编码） 59. 计数排序算法1234567891011121314151617int[] CountingSort(int[] arr) &#123; int max = arr.Max(); int[] count = new int[max + 1]; foreach (int num in arr) count[num]++; for (int i = 1; i &lt; count.Length; i++) count[i] += count[i - 1]; int[] output = new int[arr.Length]; for (int i = arr.Length - 1; i &gt;= 0; i--) &#123; output[count[arr[i]] - 1] = arr[i]; count[arr[i]]--; &#125; return output;&#125; 60. Dijkstra算法（C++实现略，C#类似） 初始化距离数组（起点0，其他∞） 选择未访问的最小距离节点 更新邻居节点的距离 重复直到所有节点访问完毕 61. 最大子序列和算法（Kadane算法）12345678910int MaxSubarraySum(int[] arr) &#123; int maxSoFar = int.MinValue; int maxEndingHere = 0; foreach (int num in arr) &#123; maxEndingHere = Math.Max(num, maxEndingHere + num); maxSoFar = Math.Max(maxSoFar, maxEndingHere); &#125; return maxSoFar;&#125; 62. StringCollection 类 位于：System.Collections.Specialized 特点：专为字符串优化的集合，比ArrayList更高效 用法：123StringCollection sc = new StringCollection();sc.Add(&quot;text1&quot;);sc.AddRange(new[] &#123; &quot;text2&quot;, &quot;text3&quot; &#125;); 63. 三个排序数组查找公共元素123456789101112131415List&lt;int&gt; FindCommon(int[] a, int[] b, int[] c) &#123; int i = 0, j = 0, k = 0; var result = new List&lt;int&gt;(); while (i &lt; a.Length &amp;&amp; j &lt; b.Length &amp;&amp; k &lt; c.Length) &#123; if (a[i] == b[j] &amp;&amp; b[j] == c[k]) &#123; result.Add(a[i]); i++; j++; k++; &#125; else if (a[i] &lt; b[j]) i++; else if (b[j] &lt; c[k]) j++; else k++; &#125; return result;&#125; 64. 里氏替换原则（LSP） 定义：子类必须能够替换其基类而不影响程序正确性 实现：123456789101112class Bird &#123; public virtual void Fly() &#123; /* 实现 */ &#125;&#125;class Sparrow : Bird &#123; &#125; // 正确：麻雀会飞// 违反LSP的例子class Ostrich : Bird &#123; public override void Fly() &#123; throw new NotSupportedException(&quot;鸵鸟不能飞！&quot;); &#125;&#125; 65. 动态规划算法（斐波那契示例）12345678int Fibonacci(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125; 66. KMP字符串匹配算法123456789101112131415161718192021222324252627282930313233343536int KMPSearch(string text, string pattern) &#123; int[] lps = ComputeLPS(pattern); int i = 0, j = 0; while (i &lt; text.Length) &#123; if (pattern[j] == text[i]) &#123; i++; j++; &#125; if (j == pattern.Length) &#123; return i - j; // 匹配位置 j = lps[j - 1]; &#125; else if (i &lt; text.Length &amp;&amp; pattern[j] != text[i]) &#123; if (j != 0) j = lps[j - 1]; else i++; &#125; &#125; return -1;&#125;int[] ComputeLPS(string pattern) &#123; int[] lps = new int[pattern.Length]; int len = 0, i = 1; while (i &lt; pattern.Length) &#123; if (pattern[i] == pattern[len]) &#123; len++; lps[i] = len; i++; &#125; else &#123; if (len != 0) len = lps[len - 1]; else lps[i++] = 0; &#125; &#125; return lps;&#125; 67. 使用LINQ查找并排序整数1var numbers = objects.OfType&lt;int&gt;().OrderBy(n =&gt; n).ToList(); 68. 秒转换为时分秒毫秒12TimeSpan time = TimeSpan.FromSeconds(totalSeconds);string formatted = $&quot;&#123;time.Hours&#125;:&#123;time.Minutes&#125;:&#123;time.Seconds&#125;:&#123;time.Milliseconds&#125;&quot;; 69. 比较两个数组123bool areEqual = array1.SequenceEqual(array2);// 或bool areEqual = Enumerable.SequenceEqual(array1, array2); 70. 使代码可重用的方法 使用泛型 遵循SOLID原则 模块化设计 依赖注入 创建可扩展的类库 71. 创建HashTable123Hashtable ht = new Hashtable();// 或泛型版本Dictionary&lt;int, string&gt; dict = new Dictionary&lt;int, string&gt;(); 72. 向HashTable添加项目123Hashtable ht = new Hashtable();ht.Add(&quot;key1&quot;, &quot;value1&quot;);ht[&quot;key2&quot;] = &quot;value2&quot;; // 索引器方式 73. C# 8.0索引器使用12345678910111213141516171819public class DataContainer &#123; private string[] _data = new string[10]; // 标准索引器 public string this[int index] &#123; get =&gt; _data[index]; set =&gt; _data[index] = value; &#125; // C# 8.0支持的范围索引器 public string[] this[Range range] &#123; get =&gt; _data[range]; &#125;&#125;// 使用var container = new DataContainer();string first = container[0];string[] subset = container[1..4]; // 获取索引1-3的元素 74. 二分查找算法12345678910int BinarySearch(int[] arr, int target) &#123; int left = 0, right = arr.Length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; if (arr[mid] &lt; target) left = mid + 1; else right = mid - 1; &#125; return -1;&#125; 75. 多空格替换为单空格123string result = Regex.Replace(input, @&quot;\\s+&quot;, &quot; &quot;);// 或string result = string.Join(&quot; &quot;, input.Split(new[] &#123; &#x27; &#x27; &#125;, StringSplitOptions.RemoveEmptyEntries)); 76. 简单加密算法（Caesar密码）1234567891011string CaesarEncrypt(string text, int shift) &#123; char[] buffer = text.ToCharArray(); for (int i = 0; i &lt; buffer.Length; i++) &#123; char c = buffer[i]; if (char.IsLetter(c)) &#123; char offset = char.IsUpper(c) ? &#x27;A&#x27; : &#x27;a&#x27;; buffer[i] = (char)(((c + shift - offset) % 26) + offset); &#125; &#125; return new string(buffer);&#125; 77. 编写哈希算法（SHA256示例）12345string ComputeHash(string input) &#123; using SHA256 sha256 = SHA256.Create(); byte[] bytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(input)); return BitConverter.ToString(bytes).Replace(&quot;-&quot;, &quot;&quot;);&#125; 78. 递归求乘积12345int Multiply(int a, int b) &#123; if (b == 0) return 0; if (b &gt; 0) return a + Multiply(a, b - 1); return -Multiply(a, -b); // 处理负数&#125; 79. 神经网络算法（简化示例）123456789101112131415161718192021class NeuralNetwork &#123; double[,] weights; public NeuralNetwork(int input, int output) &#123; weights = new double[input, output]; // 初始化权重... &#125; public double[] FeedForward(double[] inputs) &#123; double[] outputs = new double[weights.GetLength(1)]; for (int j = 0; j &lt; outputs.Length; j++) &#123; for (int i = 0; i &lt; inputs.Length; i++) &#123; outputs[j] += inputs[i] * weights[i, j]; &#125; outputs[j] = Sigmoid(outputs[j]); &#125; return outputs; &#125; private double Sigmoid(double x) =&gt; 1.0 / (1.0 + Math.Exp(-x));&#125; 80. LZW压缩算法 初始化字典（包含所有单字符） 遍历输入数据： 查找当前最长匹配字符串 输出匹配字符串的编码 添加新字符串（当前匹配+下一个字符）到字典 81. 重新抛出InnerException保留堆栈12345try &#123; // ...&#125; catch (Exception ex) &#123; throw new CustomException(&quot;Error message&quot;, ex); // 保留原始堆栈&#125; 82. 时间序列预测（ARIMA示例） 数据平稳化（差分） 确定ARIMA参数（p,d,q） 模型拟合与预测 使用库如ML.NET或Accord.NET 83. 不使用Reverse()反转字符串123456789string ReverseString(string s) &#123; char[] arr = s.ToCharArray(); for (int i = 0; i &lt; arr.Length / 2; i++) &#123; char temp = arr[i]; arr[i] = arr[arr.Length - i - 1]; arr[arr.Length - i - 1] = temp; &#125; return new string(arr);&#125; 84. 递归方法调用 定义：方法直接或间接调用自身 示例：1234int Factorial(int n) &#123; if (n &lt;= 1) return 1; return n * Factorial(n - 1); // 递归调用&#125; 85. 广度优先搜索算法12345678910111213141516171819void BFS(Node start) &#123; var queue = new Queue&lt;Node&gt;(); var visited = new HashSet&lt;Node&gt;(); queue.Enqueue(start); visited.Add(start); while (queue.Count &gt; 0) &#123; Node current = queue.Dequeue(); Process(current); foreach (Node neighbor in current.Neighbors) &#123; if (!visited.Contains(neighbor)) &#123; visited.Add(neighbor); queue.Enqueue(neighbor); &#125; &#125; &#125;&#125; 86. 堆排序算法（见问题45）","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"设计模式","slug":"设计模式","date":"2025-05-11T10:05:24.000Z","updated":"2025-05-13T14:39:58.987Z","comments":true,"path":"2025/05/11/设计模式/","permalink":"http://example.com/2025/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1、简单工厂模式简单工厂模式(Simple Factory Pattern) 又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。 在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 1234567891011121314151617181920public class OperationFactory&#123; public static Operation createOperate(string operate)&#123; Operation oper = null; switch(operate)&#123; case &quot;+&quot;: oper = new OperationAdd(); break; case &quot;-&quot;: oper = new OperationSub(); break; case &quot;*&quot;: oper = new OperationMul(); break; case &quot;/&quot;: oper = new OperationDiv(); break; &#125; return oper; &#125;&#125; 12345Operation oper;oper = OperationFactory.createOperate（“+”）;oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult（）; 2、策略模式策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 策略接口interface SortStrategy &#123; void sort(int[] array);&#125;// 具体策略类：快速排序class QuickSortStrategy implements SortStrategy &#123; @Override public void sort(int[] array) &#123; // 快速排序算法实现 System.out.println(&quot;Using Quick Sort&quot;); // 排序逻辑 &#125;&#125;// 具体策略类：冒泡排序class BubbleSortStrategy implements SortStrategy &#123; @Override public void sort(int[] array) &#123; // 冒泡排序算法实现 System.out.println(&quot;Using Bubble Sort&quot;); // 排序逻辑 &#125;&#125;// 上下文类：负责使用策略class SortingContext &#123; private SortStrategy strategy; // 设置策略 public void setStrategy(SortStrategy strategy) &#123; this.strategy = strategy; &#125; // 执行排序 public void executeSort(int[] array) &#123; strategy.sort(array); &#125;&#125;// 测试public class StrategyPatternExample &#123; public static void main(String[] args) &#123; SortingContext context = new SortingContext(); // 使用快速排序策略 context.setStrategy(new QuickSortStrategy()); context.executeSort(new int[]&#123;3, 1, 2&#125;); // 使用冒泡排序策略 context.setStrategy(new BubbleSortStrategy()); context.executeSort(new int[]&#123;3, 1, 2&#125;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"fly"},{"title":"WPF编程基础下（二）","slug":"WPF基础学习下","date":"2025-05-11T10:02:24.000Z","updated":"2025-05-13T15:40:08.477Z","comments":true,"path":"2025/05/11/WPF基础学习下/","permalink":"http://example.com/2025/05/11/WPF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%8B/","excerpt":"","text":"内容控件Control基类Control是许多控件的基类。比如最常见的按钮（Button）、单选(RadioButton)、复选（CheckBox）、文本框（TextBox）、ListBox、DataGrid、日期控件等等。这些控件通常用于展示程序的数据或获取用户输入的数据，我们可以将这一类型的控件称为内容控件或数据控件，它们与前面的布局控件有一定的区别，布局控件更专注于界面，而内容控件更专注于数据（业务）。 Control类虽然可以实例化，但是在界面上是不会有任何显示的。只有那些继承了Control的子类（控件）才会在界面上显示，而且所呈现的样子各不相同，为什么会是这样呢？ 因为Control类提供了一个控件模板（ControlTemplate），而几乎所有的子类都对这个ControlTemplate进行了各自的实现，所以在呈现子类时，我们才会看到Button拥有Button的样子，TextBox拥有TextBox的样子。 Control基类说 我给你们一张白纸(ControlTemplate)，你们可以在上面想画什么就画什么 我们在这一章节并不对模板(Template)进行详细的介绍，只是先阐述模板的概念，接下来，我们先将目光聚焦到Control的结构定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Control : FrameworkElement&#123;public static readonly DependencyProperty BorderBrushProperty;public static readonly RoutedEvent PreviewMouseDoubleClickEvent;public static readonly DependencyProperty TemplateProperty;public static readonly DependencyProperty PaddingProperty;public static readonly DependencyProperty IsTabStopProperty;public static readonly DependencyProperty TabIndexProperty;public static readonly DependencyProperty VerticalContentAlignmentProperty;public static readonly DependencyProperty HorizontalContentAlignmentProperty;public static readonly RoutedEvent MouseDoubleClickEvent;public static readonly DependencyProperty FontStyleProperty;public static readonly DependencyProperty FontStretchProperty;public static readonly DependencyProperty FontSizeProperty;public static readonly DependencyProperty FontFamilyProperty;public static readonly DependencyProperty ForegroundProperty;public static readonly DependencyProperty BackgroundProperty;public static readonly DependencyProperty BorderThicknessProperty;public static readonly DependencyProperty FontWeightProperty; public Control(); public FontStyle FontStyle &#123; get; set; &#125;public FontStretch FontStretch &#123; get; set; &#125;public double FontSize &#123; get; set; &#125;public FontFamily FontFamily &#123; get; set; &#125;public Brush Foreground &#123; get; set; &#125;public Brush Background &#123; get; set; &#125;public Thickness BorderThickness &#123; get; set; &#125;public bool IsTabStop &#123; get; set; &#125;public VerticalAlignment VerticalContentAlignment &#123; get; set; &#125;public int TabIndex &#123; get; set; &#125;public Thickness Padding &#123; get; set; &#125;public ControlTemplate Template &#123; get; set; &#125;public FontWeight FontWeight &#123; get; set; &#125;public Brush BorderBrush &#123; get; set; &#125;public HorizontalAlignment HorizontalContentAlignment &#123; get; set; &#125;protected internal virtual bool HandlesScrolling &#123; get; &#125; public event MouseButtonEventHandler MouseDoubleClick;public event MouseButtonEventHandler PreviewMouseDoubleClick; public override string ToString();protected override Size ArrangeOverride(Size arrangeBounds);protected override Size MeasureOverride(Size constraint);protected virtual void OnMouseDoubleClick(MouseButtonEventArgs e);protected virtual void OnPreviewMouseDoubleClick(MouseButtonEventArgs e);protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate); &#125; 我们先来看看Control基类为它的子类们提供了哪些属性 属性 说明 FontStyle 获取或设置控件的字体结构，类似于Word中字体的常规、斜体或倾斜 FontStretch 获取或设置紧缩或在屏幕上展开一种字体的程度。 FontSize 获取或设置字体大小。 FontFamily 获取或设置控件的字体系列。如：微软雅黑 &#x3D; “Microsoft YaHei UI” Foreground 获取或设置控件的字体颜色，也就是所谓的前景色画笔，它是一个刷子（Brush） Background 获取或设置一个用于描述控件的背景画笔。 BorderThickness 获取或设置控件的边框宽度。 IsTabStop 获取或设置一个值，该值指示控件是否包括在选项卡上的导航窗格中。 VerticalContentAlignment 获取或设置控件的内容的垂直对齐方式。 TabIndex 获取或设置一个值，确定当用户导航控件通过使用 TAB 键元素接收焦点的顺序。 Padding 获取或设置在控件中的填充量。 Template 获取或设置控件模板。 FontWeight 获取或设置指定的字体粗细。 BorderBrush 获取或设置一个用于描述一个控件的边框背景画笔。 HorizontalContentAlignment 获取或设置控件的内容的水平对齐方式。 大部分的属性都比较好理解，这里着重介绍一下Template属性。如果把人比作是一个Control(控件)，那么”着装“就是Template（模板）。在大街上，我们会看到不同着装的人来来往往。 所以Control的Template定义了控件的外观（着装）。 数据模板 与控件模板类似的，还有一个概念叫数据模板。形象地说，还是把人比作控件，那么人体的五脏六腑就是这个控件的数据，而五脏六腑（数据）的外观就是指数据模板。 我们来看一个实际的例子 12345678910111213&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Control Margin=&quot;10&quot;&gt; &lt;/Control&gt; &lt;/Window&gt; 我们在Window窗体中实例化了一个Control类，但是，界面上空无一物。这是因为当前这个Control对象还没有”穿衣服“，也就是说，它的Template并没有内容，实际上，此刻Template属性等于null。 那我们尝试给他穿一件衣服吧。 123456789101112131415161718&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Control Margin=&quot;10&quot;&gt; &lt;Control.Template&gt; &lt;ControlTemplate TargetType=&quot;Control&quot;&gt; &lt;Border Background=&quot;LightBlue&quot;&gt; &lt;TextBlock Text=&quot;WPF中文网&quot; FontSize=&quot;20&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Control.Template&gt; &lt;/Control&gt;&lt;/Window&gt; 我们为Control的Template实例化了一个ControlTemplate对象，并在这个对象中增加了一个Border，在Border中又增加了一个TextBlock子元素，于是Control就有了这样一件新衣服。 在这里，我们要明白一个要点是，Control类的Template属性是ControlTemplate类型的。所以上面的代码才必须这样写才可以。而ControlTemplate又是什么东东？为什么在xaml中实例化时，后面要跟一句TargetType&#x3D;”Control”？关于这一点，我们将在后面专门拿一章节来阐述ControlTemplate以及它的父类。 事件 在这一小节里，您只要能明白Template的概念就行了。除了这个属性，Control类还提供了两个事件，它们分别是PreviewMouseDoubleClick和MouseDoubleClick。 事件名称 说明 PreviewMouseDoubleClick 表示鼠标双击或多次单击时触发的事件 MouseDoubleClick 表示鼠标双击或多次单击时触发的事件 以Preview开头的事件叫隧道事件或预览事件，而MouseDoubleClick没有以Preview开头，所以它叫冒泡事件。 WPF的前端代码其实是一棵树，当我们在某个目标控件上进行鼠标操作时，所引发的事件有两个方向，一是从Winow根节点一直路由到目标控件上，看起来就好像是从外面一直沿着这棵树路由引发至里面，这就像我们开车进入隧道一样，所以Preview开头的事件叫隧道事件。 冒泡事件事件的路由方向相反，是从目标控件位置开始，一直路由引发至最外层的Window窗体。 关于路由事件，我们会在后面拿一章节专门讲解，这里只提一下这个概念。 通常，我们并不会直接实例化Control基类，确实这样做对我们实际帮助不大，我们要使用的——是它膝下各个子控件，而在这众多的子控件中，Button是最常见最简单的控件了。不过，Button的基类是ButtonBase，ButtonBase的基类是ContentControl，ContentControl的基类是Control。如果我们要探讨Button控件，看样子必须要先介绍一下ContentControl基类和ButtonBase基类才行了。 ContentControl类（内容控件）ContentControl是一个神奇的类！ 为什么这么说呢，因为它有一个Content属性，关键是这个属性的类型是object。也就是说，本质上，它可以接收任意引用类型的实例。 但是，通常情况下，Content属性接收UI控件。因为，ContentControl控件最终会把Content属性里面的内容显示到界面上。 我们先看看它的结构定义： 1234567891011121314151617181920212223242526public class ContentControl : Control, IAddChild&#123; public static readonly DependencyProperty ContentProperty; public static readonly DependencyProperty HasContentProperty; public static readonly DependencyProperty ContentTemplateProperty; public static readonly DependencyProperty ContentTemplateSelectorProperty; public static readonly DependencyProperty ContentStringFormatProperty; public ContentControl(); public DataTemplate ContentTemplate &#123; get; set; &#125; public bool HasContent &#123; get; &#125; public object Content &#123; get; set; &#125; public string ContentStringFormat &#123; get; set; &#125; public DataTemplateSelector ContentTemplateSelector &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public virtual bool ShouldSerializeContent(); protected virtual void AddChild(object value); protected virtual void AddText(string text); protected virtual void OnContentChanged(object oldContent, object newContent); protected virtual void OnContentStringFormatChanged(string oldContentStringFormat, string newContentStringFormat); protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate); protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector); &#125; 那么，我如果非要把其它类型的对象（比如字符串）强行塞给Content属性呢？ 123456789101112&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;ContentControl Foreground=&quot;Red&quot; FontSize=&quot;36&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; WPF中文网 &lt;/ContentControl&gt;&lt;/Window&gt; 如上所示，我们在ContentControl 内部只写了一句“WPF中文网”，并设置了Foreground和FontSize等属性，居然不但没报错，还将字符串显示出来了，这真是太神奇了！ 重庆教主友情提示 别忘记了ContentControl 继承于Control 基类，所以我们的ContentControl 也可以设置Foreground和FontSize哦！ ContentTemplate属性（内容模板） 这个属性表示获取或设置用来显示的内容的数据模板，说白了，就是决定“WPF中文网”这几个字的穿着，如果没有设置数据模板，它将以默认的数据模板来显示这几个字。接下来，我们演示一下这个属性的用法，并简要说明其中的关系。 1234567891011121314151617&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;ContentControl Foreground=&quot;Red&quot; FontSize=&quot;36&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;ContentControl.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=&quot;&#123;Binding&#125;&quot; Foreground=&quot;Green&quot; FontSize=&quot;16&quot;/&gt; &lt;/DataTemplate&gt; &lt;/ContentControl.ContentTemplate&gt; WPF中文网 &lt;/ContentControl&gt;&lt;/Window&gt; ContentControl类的ContentTemplate属性是DataTemplate类型，所以我们在xaml中实例化了一个DataTemplate（数据模板）对象，并在其中增加了一个TextBlock控件，将TextBlock控件的Text属性写成了Binding形式，并设置了字体颜色和大小。 最终呈现的效果上图所示，字体颜色为绿色，大小为16。虽然ContentControl也设置了字体颜色为红色，大小为36，但是已经失效了。好比ContentControl给Content提供了一件红色的外衣，但是，我们又特地提供了一件绿色的外衣，于是，ContentControl就被绿了。 关于数据模板中的TextBlock控件的Text属性写成了Binding(绑定)形式，这是指将ContentContent控件的Contnet属性绑定到TextBlock控件的Text属性中，写成伪代码就是： 1TextBlock.Text = ContentContent.Content 这是您第一次在这个系列中看到Binding（绑定）的出现。我们将在后面专门拿一章节进行探讨。这里能理解这个ContentTemplate就行了。 ContentControl控件能不能容纳多个子控件？ 不能！因为ContentControl控件只能显示Content属性里面的内容，而Content属性是object，只能接收一个对象。 HasContent属性：表示ContentControl是否有内容。 ContentStringFormat属性：获取或设置ContentControl要显示字符串的格式。 ContentTemplateSelector属性：模板选择器， 我们会在模板一章节介绍。 常规用法 123456789101112&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;ContentControl Foreground=&quot;Red&quot; FontSize=&quot;60&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;WPF中文网&quot;/&gt; &lt;/ContentControl&gt;&lt;/Window&gt; 这次我们在ContentControl放了一个Button，需要注意一点的是：Button的字号会随着ContentControl的设置而变化，但是字体颜色不会随着ContentControl的设置而变化。 ButtonBase基类按钮，几乎每个具有UI界面的软件都会有它的身影，而按钮的形式也是有多种多样的，我们在这里简单的罗列一下。 按钮名称 说明 Button 普通按钮 CheckBox 复选框按钮 RadioButton 单选框按钮 ToggleButton 是CheckBox、RadioButton的基类，表示可以切换状态 RepeatButton 重复，表示从按下到弹出过程中重复引发Click事件 GridViewColumnHeader 表示GridViewColumn 的列标题，其实它也是一个按钮 DataGridColumnHeader 表示DataGrid 列标题，也是一个按钮 DataGridRowHeader 表示DataGrid 行标题，也是一个按钮 上面便是WPF中的按钮体系，这些按钮都有一个共同的基类ButtonBase，所以，我们了解清楚了ButtonBase，对于学习上面这些按钮，有莫大的帮助。 一、ButtonBase概述 ButtonBase是一个抽象类，所以，它不能被实例化。我们只能在它的子类中去使用它提供的一些属性、事件或方法成员。它只有一个事件，就是Click单击事件，毕竟鼠标双击事件在它的Control基类就有了嘛。另外，它还有一个非常厉害的Command属性，这个属性其实是一个接口，起什么作用呢？就是在单击按钮时，去执行这个Command属性所指定的一个具体命令。 这个Command命令是WPF命令系统里面的角色，也是WPF优于Winform的一个具体表现，Command命令也是MVVM模式中最重要的一环。我们会在后面专门探讨WPF的命令系统。 接下来，我们先看看ButtonBase的结构定义： 1234567891011121314151617181920212223242526272829303132333435public abstract class ButtonBase : ContentControl, ICommandSource&#123; public static readonly RoutedEvent ClickEvent; public static readonly DependencyProperty CommandProperty; public static readonly DependencyProperty CommandParameterProperty; public static readonly DependencyProperty CommandTargetProperty; public static readonly DependencyProperty IsPressedProperty; public static readonly DependencyProperty ClickModeProperty; protected ButtonBase(); public IInputElement CommandTarget &#123; get; set; &#125; public object CommandParameter &#123; get; set; &#125; public ICommand Command &#123; get; set; &#125; public bool IsPressed &#123; get; protected set; &#125; public ClickMode ClickMode &#123; get; set; &#125; protected override bool IsEnabledCore &#123; get; &#125; public event RoutedEventHandler Click; protected override void OnAccessKey(AccessKeyEventArgs e); protected virtual void OnClick(); protected virtual void OnIsPressedChanged(DependencyPropertyChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected override void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e); protected override void OnLostMouseCapture(MouseEventArgs e); protected override void OnMouseEnter(MouseEventArgs e); protected override void OnMouseLeave(MouseEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected internal override void OnRenderSizeChanged(SizeChangedInfo sizeInfo); &#125; 二、ButtonBase的属性 属性名称 说明 CommandTarget 获取或设置要对其引发指定的命令的元素。 CommandParameter 获取或设置一个命令参数，这个参数是传递给Command 属性所指向的命令。 Command 获取或设置要在按此按钮时调用的命令。 IsPressed 获取当前按钮是否处于激活状态。 ClickMode 获取或设置按钮的单击模式 IsEnabledCore 获取的值 System.Windows.ContentElement.IsEnabled 属性。 三、ButtonBase方法 ButtonBase还提供了两个虚方法，分别是OnClick()和OnIsPressedChanged（）。说明这两个方法也是可以重写的，OnClick表示在按钮单击时执行的方法。 Button按钮Button因为继承了ButtonBase，而ButtonBase又继承了ContentControl，所以，Button可以通过设置Content属性来设置要显示的内容。例如 1&lt;Button Content=&quot;WPF中文网&quot;/&gt; 我们使用Button的时机，通常是鼠标点击事件需要有响应操作时，所以，Button的Click事件是最好的选择。接下来，我们先看看它的结构定义： 12345678910111213141516public class Button : ButtonBase&#123; public static readonly DependencyProperty IsDefaultProperty; public static readonly DependencyProperty IsCancelProperty; public static readonly DependencyProperty IsDefaultedProperty; public Button(); public bool IsDefault &#123; get; set; &#125; public bool IsCancel &#123; get; set; &#125; public bool IsDefaulted &#123; get; &#125; protected override void OnClick(); protected override AutomationPeer OnCreateAutomationPeer(); &#125; 属性分析 属性 说明 IsDefault 用户通过按 ENTER 键时调用的默认按钮。 IsCancel 用户可以通过按 ESC 键来激活取消按钮。 IsDefaulted 获取按钮是否为按 ENTER 键时调用的默认按钮。 我们通过一个例子来分析Button控件的用法与特点。 前端代码 1234567891011121314&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;退出&quot; Width=&quot;100&quot; Height=&quot;25&quot; Click=&quot;_button_Click&quot; IsDefault=&quot;True&quot;/&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; this.Close(); &#125; &#125;&#125; ToggleButton基类因为ToggleButton作为CheckBox（复选框）和RadioButton（单选框）的基类，我们在学习CheckBox和RadioButton之前要先了解一下这个基类。 12345678910111213141516171819202122232425public class ToggleButton : ButtonBase&#123; public static readonly RoutedEvent CheckedEvent; public static readonly RoutedEvent UncheckedEvent; public static readonly RoutedEvent IndeterminateEvent; public static readonly DependencyProperty IsCheckedProperty; public static readonly DependencyProperty IsThreeStateProperty; public ToggleButton(); public bool IsThreeState &#123; get; set; &#125; public bool? IsChecked &#123; get; set; &#125; public event RoutedEventHandler Checked; public event RoutedEventHandler Indeterminate; public event RoutedEventHandler Unchecked; public override string ToString(); protected virtual void OnChecked(RoutedEventArgs e); protected override void OnClick(); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnIndeterminate(RoutedEventArgs e); protected virtual void OnUnchecked(RoutedEventArgs e); protected internal virtual void OnToggle();&#125; ToggleButton基类提供了两个属性和三个事件 IsThreeState属性为true表示控件支持3个状态，IsChecked属性为true表示当前控件已被选中。Checked事件表示选中时引发的事件，Unchecked事件表示从选中状态改为未选状态时引发的事件，Indeterminate事件表示不确定状态时引发的事件 CheckBox复选框CheckBox继承于ToggleButton，而ToggleButton才继承于ButtonBase基类。 CheckBox控件的结构定义： 123456789public class CheckBox : ToggleButton&#123; public CheckBox(); protected override void OnAccessKey(AccessKeyEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnKeyDown(KeyEventArgs e); &#125; CheckBox自身没有什么特别内容。一切都使用它的父类提供的属性、方法和事件。我们举例来说明它的用法。 前端代码 12345678910111213141516&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;今晚吃什么菜?&quot; Margin=&quot;5&quot;/&gt; &lt;CheckBox Name=&quot;_checkbox1&quot; Content=&quot;红烧牛肉&quot; Margin=&quot;5&quot;/&gt; &lt;CheckBox Name=&quot;_checkbox2&quot; Content=&quot;麻婆豆腐&quot; Margin=&quot;5&quot;/&gt; &lt;CheckBox Name=&quot;_checkbox3&quot; Content=&quot;夫妻肺片&quot; Margin=&quot;5&quot;/&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;查看菜单&quot; Click=&quot;_button_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; string order = string.Empty; if (_checkbox1.IsChecked == true) order += _checkbox1.Content + &quot;,&quot;; if (_checkbox2.IsChecked == true) order += _checkbox2.Content + &quot;,&quot;; if (_checkbox3.IsChecked == true) order += _checkbox3.Content; if(!string.IsNullOrEmpty(order)) MessageBox.Show(order); &#125; &#125;&#125; 如上图所示，这是前端代码呈现的界面。F5启动后，我们勾选两个选项，然后点击查看菜单，观察结果。 我们通过判断CheckBox的IsChecked属性，来获取前端用户的选择，这通常是CheckBox控件最常用的用法，由于IsChecked是一个依赖属性，它还可以参与绑定，形成MVMM的应用模式，待我们讲到数据绑定章节，还会进一步讲解控件属性的绑定应用。 RadioButton单选框RadioButton也继承于ToggleButton，作用是单项选择，所以被称为单选框。本质上，它依然是一个按钮，一旦被选中，不会清除，除非它”旁边“的单选框被选中。 1234567891011121314public class RadioButton : ToggleButton&#123; public static readonly DependencyProperty GroupNameProperty; public RadioButton(); public string GroupName &#123; get; set; &#125; protected override void OnAccessKey(AccessKeyEventArgs e); protected override void OnChecked(RoutedEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected internal override void OnToggle(); &#125; 这个控件有一个重要属性叫GroupName——分组名称。默认值是一个空字符串。用来指定哪些RadioButton之间是互相排斥的。 我们将前面的例子简单修改一下代码。 前端代码 1234567&lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;今晚吃什么菜?&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton1&quot; Content=&quot;红烧牛肉&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton2&quot; Content=&quot;麻婆豆腐&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton3&quot; Content=&quot;夫妻肺片&quot; Margin=&quot;5&quot;/&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;查看菜单&quot; Click=&quot;_button_Click&quot;/&gt;&lt;/StackPanel&gt; 后端代码 1234567891011121314151617181920212223242526namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; string order = string.Empty; if (_RadioButton1.IsChecked == true) order += _RadioButton1.Content + &quot;,&quot;; if (_RadioButton2.IsChecked == true) order += _RadioButton2.Content + &quot;,&quot;; if (_RadioButton3.IsChecked == true) order += _RadioButton3.Content; if(!string.IsNullOrEmpty(order)) MessageBox.Show(order); &#125; &#125;&#125; F5运行之后，我们会发现，无论我们怎么选，始终只有一个RadioButton按钮被选中。 如果我们希望RadioButton按分组进行单项选择，该怎么办呢？ 我们可以使用GroupName分组属性，两两一组，让用户始终都只能选择一荤一素两个菜，请看代码。 前端代码 12345678&lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;今晚吃什么菜?&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton1&quot; Content=&quot;红烧牛肉&quot; GroupName=&quot;荤菜&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton2&quot; Content=&quot;糖醋排骨&quot; GroupName=&quot;荤菜&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton3&quot; Content=&quot;麻婆豆腐&quot; GroupName=&quot;素菜&quot; Margin=&quot;5&quot;/&gt; &lt;RadioButton Name=&quot;_RadioButton4&quot; Content=&quot;清炒时蔬&quot; GroupName=&quot;素菜&quot; Margin=&quot;5&quot;/&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;查看菜单&quot; Click=&quot;_button_Click&quot;/&gt;&lt;/StackPanel&gt; 后端代码 123456789101112131415161718192021public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e)&#123; string order = string.Empty; if (_RadioButton1.IsChecked == true) order += _RadioButton1.Content + &quot;,&quot;; if (_RadioButton2.IsChecked == true) order += _RadioButton2.Content + &quot;,&quot;; if (_RadioButton3.IsChecked == true) order += _RadioButton3.Content + &quot;,&quot;; if (_RadioButton4.IsChecked == true) order += _RadioButton4.Content; if (!string.IsNullOrEmpty(order)) MessageBox.Show(order);&#125; 此时再操作时我们发现，红烧牛肉和糖醋排骨只能二选一，麻婆豆腐和清炒时蔬也只能二选一。 RepeatButton重复按钮RepeatButton,顾名思义，重复执行的按钮。就是当按钮被按下时，所订阅的回调函数会不断被执行。那么，多长时间执行一次？ 我们先看看它的结构定义： 123456789101112131415161718192021public class RepeatButton : ButtonBase&#123; public static readonly DependencyProperty DelayProperty; public static readonly DependencyProperty IntervalProperty; public RepeatButton(); public int Delay &#123; get; set; &#125; public int Interval &#123; get; set; &#125; protected override void OnClick(); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected override void OnLostMouseCapture(MouseEventArgs e); protected override void OnMouseEnter(MouseEventArgs e); protected override void OnMouseLeave(MouseEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e); &#125; 一、属性分析 RepeatButton 自身提供了两个整型属性，分别是Delay 和Interval 。 Delay 属性：表示延时重复执行的毫秒数，就是说，RepeatButton被按下后会立即执行一次回调函数，如果您不松开鼠标，在等待Delay 毫秒后，就开始进行重复执行阶段。 Interval 属性：表示重复执行回调函数的时间间隔毫秒数。 接下来，我们观察下面的代码的运行结果。 二、RepeatButton 应用示例 1234&lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;牙膏已在手&quot; Margin=&quot;5 7 5 5&quot;/&gt; &lt;RepeatButton Name=&quot;_Button1&quot; Content=&quot;开始挤牙膏&quot; Delay=&quot;1000&quot; Interval=&quot;500&quot; Click=&quot;_Button1_Click&quot; Margin=&quot;5&quot;/&gt; &lt;/StackPanel&gt; 123456789101112131415161718namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; int count = 1; private void _Button1_Click(object sender, RoutedEventArgs e) &#123; Console.WriteLine($&quot;重复时间:&#123;DateTime.Now.ToLongTimeString()&#125; &#123;DateTime.Now.Millisecond&#125;,重复次数:&#123;count++&#125;&quot;); &#125; &#125;&#125; 我们以生活中挤牙膏为例，当开始挤的动作发生后，我们会持续一小会儿，然后才松开，此时牙膏停止往外溢出。观察下面的输出结果： 12345678重复时间:14:37:28 476,重复次数:1重复时间:14:37:29 548,重复次数:2重复时间:14:37:30 51,重复次数:3重复时间:14:37:30 549,重复次数:4重复时间:14:37:31 89,重复次数:5重复时间:14:37:31 598,重复次数:6重复时间:14:37:32 185,重复次数:7重复时间:14:37:32 718,重复次数:8 结果显示，第一次和第二次输出时间刚好为1000毫秒，也就是Delay属性在起作用。然后，从第2次开始，每两次之间的时间间隔大约为500毫秒，这是因为Interval属性被设置为500。相信通过这个例子，您已明白这个按钮的用法。 Label标签Label控件继承于ContentControl控件，它是一个文本标签，如果您想修改它的标签内容，请设置Content属性。我们曾提过ContentControl的Content属性是object类型，意味着Label的Content也是可以设置为任意的引用类型的。 我们来举个例子。 12345678&lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;Label Content=&quot;这是一个Label标签&quot;/&gt; &lt;Label&gt; &lt;Label.Content&gt; &lt;Button Content=&quot;确定&quot; Click=&quot;_Button1_Click&quot;/&gt; &lt;/Label.Content&gt; &lt;/Label&gt;&lt;/StackPanel&gt; 1234567891011public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _Button1_Click(object sender, RoutedEventArgs e)&#123; this.Close();&#125; 我们给第二个标签的Content属性设置了一个按钮，并对按钮的Click事件做了订阅回调，F5运行，事实证明，此时的Button是可以正常使用 。只不过，通常情况下，我们的Label只是用来显示一段文字，很少在Contnet里面编写其它控件代码。如果要编写其它控件代码以实现更复杂的自定义控件效果，我们建议使用UserControl用户控件。 对于文本的显示，除了可以在Label中显示，我们还有一个控件也可以实现，那就是TextBlock文字块。而且，TextBlock控件直接从FrameworkElement基类继承而来，效率比Label标签更高哦。 TextBlock文字块TextBlock是专业处理文本显示的控件，在功能上比Label更全面。先看结构定义，后举例说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class TextBlock : FrameworkElement, IContentHost, IAddChildInternal, IAddChild, IServiceProvider&#123; public static readonly DependencyProperty BaselineOffsetProperty; public static readonly DependencyProperty IsHyphenationEnabledProperty; public static readonly DependencyProperty TextWrappingProperty; public static readonly DependencyProperty TextAlignmentProperty; public static readonly DependencyProperty PaddingProperty; public static readonly DependencyProperty LineStackingStrategyProperty; public static readonly DependencyProperty LineHeightProperty; public static readonly DependencyProperty TextEffectsProperty; public static readonly DependencyProperty TextDecorationsProperty; public static readonly DependencyProperty TextTrimmingProperty; public static readonly DependencyProperty ForegroundProperty; public static readonly DependencyProperty FontSizeProperty; public static readonly DependencyProperty FontStretchProperty; public static readonly DependencyProperty FontWeightProperty; public static readonly DependencyProperty FontStyleProperty; public static readonly DependencyProperty FontFamilyProperty; public static readonly DependencyProperty TextProperty; public static readonly DependencyProperty BackgroundProperty; public TextBlock(); public TextBlock(Inline inline); public FontWeight FontWeight &#123; get; set; &#125; public FontStyle FontStyle &#123; get; set; &#125; public FontFamily FontFamily &#123; get; set; &#125; public string Text &#123; get; set; &#125; public TextPointer ContentEnd &#123; get; &#125; public Typography Typography &#123; get; &#125; public LineBreakCondition BreakAfter &#123; get; &#125; public LineBreakCondition BreakBefore &#123; get; &#125; public FontStretch FontStretch &#123; get; set; &#125; public double BaselineOffset &#123; get; set; &#125; public double FontSize &#123; get; set; &#125; public TextWrapping TextWrapping &#123; get; set; &#125; public Brush Background &#123; get; set; &#125; public TextDecorationCollection TextDecorations &#123; get; set; &#125; public TextEffectCollection TextEffects &#123; get; set; &#125; public double LineHeight &#123; get; set; &#125; public LineStackingStrategy LineStackingStrategy &#123; get; set; &#125; public Thickness Padding &#123; get; set; &#125; public TextAlignment TextAlignment &#123; get; set; &#125; public TextTrimming TextTrimming &#123; get; set; &#125; public TextPointer ContentStart &#123; get; &#125; public bool IsHyphenationEnabled &#123; get; set; &#125; public Brush Foreground &#123; get; set; &#125; public InlineCollection Inlines &#123; get; &#125; protected virtual IEnumerator&lt;IInputElement&gt; HostedElementsCore &#123; get; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public static double GetBaselineOffset(DependencyObject element); public static FontFamily GetFontFamily(DependencyObject element); public static double GetFontSize(DependencyObject element); public static FontStretch GetFontStretch(DependencyObject element); public static FontStyle GetFontStyle(DependencyObject element); public static FontWeight GetFontWeight(DependencyObject element); public static Brush GetForeground(DependencyObject element); public static double GetLineHeight(DependencyObject element); public static LineStackingStrategy GetLineStackingStrategy(DependencyObject element); public static TextAlignment GetTextAlignment(DependencyObject element); public static void SetBaselineOffset(DependencyObject element, double value); public static void SetFontFamily(DependencyObject element, FontFamily value); public static void SetFontSize(DependencyObject element, double value); public static void SetFontStretch(DependencyObject element, FontStretch value); public static void SetFontStyle(DependencyObject element, FontStyle value); public static void SetFontWeight(DependencyObject element, FontWeight value); public static void SetForeground(DependencyObject element, Brush value); public static void SetLineHeight(DependencyObject element, double value); public static void SetLineStackingStrategy(DependencyObject element, LineStackingStrategy value); public static void SetTextAlignment(DependencyObject element, TextAlignment value); public TextPointer GetPositionFromPoint(Point point, bool snapToText); public bool ShouldSerializeBaselineOffset(); public bool ShouldSerializeInlines(XamlDesignerSerializationManager manager); public bool ShouldSerializeText(); protected sealed override Size ArrangeOverride(Size arrangeSize); protected virtual ReadOnlyCollection&lt;Rect&gt; GetRectanglesCore(ContentElement child); protected override Visual GetVisualChild(int index); protected sealed override HitTestResult HitTestCore(PointHitTestParameters hitTestParameters); protected virtual IInputElement InputHitTestCore(Point point); protected sealed override Size MeasureOverride(Size constraint); protected virtual void OnChildDesiredSizeChangedCore(UIElement child); protected override AutomationPeer OnCreateAutomationPeer(); protected sealed override void OnPropertyChanged(DependencyPropertyChangedEventArgs e); protected sealed override void OnRender(DrawingContext ctx); &#125; TextBlock提供了非常丰富的文本相关的属性。 属性 说明 FontWeight 获取或设置TextBlock的字体粗细 FontStyle 获取或设置TextBlock的字体样式，如斜体字体 FontFamily 获取或设置TextBlock的字体系列，如微软雅黑 Text 获取或设置TextBlock的字体内容。 ContentEnd 表示获取TextBlock内容的最末尾的TextPointer对象 Typography 获取此元素的内容当前有效的版式变体。 FontStretch 获取或设置 TextBlock 的常用字体拉伸特征。 BaselineOffset 获取或设置文本的每个行相对于基线的偏移量。 FontSize 获取或设置TextBlock的字号 TextWrapping 获取或设置TextBlock的文字的换行方式 Background 获取或设置TextBlock控件的背景颜色（画刷） TextEffects 获取或设置要应用于此元素中的文本内容的效果。 LineHeight 获取或设置各行内容的高度。 Padding 指示内容区域的边界之间填充空间的宽度 TextAlignment 指示文本内容的水平对齐方式。 TextTrimming 获取或设置在内容超出内容区域时要采用的文本剪裁行为。 Foreground 获取或设置文本内容的字体颜色（画刷） Inlines 这个属性是一个集合，其中的元素表示内联流内容元素，简单点说，一行文本可以看成是一个Inline元素，而TextBlock可以接受多个Inline。Run继承于Inline，实际使用中，我们会创建多个Run实例，可以单独为每个Run对象设置字体字号颜色等等。 ContentStart 表示获取TextBlock内容的最开始的TextPointer对象 接下来， 我们将上面常用的属性在例子中得以体现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;WrapPanel&gt; &lt;TextBlock Text=&quot;这是一个TextBlock文字块&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;粗体文字&quot; FontWeight=&quot;Bold&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;粗体文字&quot; FontWeight=&quot;Light&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;斜体文字&quot; FontStyle=&quot;Italic&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;微软雅黑&quot; FontFamily=&quot;Microsoft YaHei UI&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;大号字体&quot; FontSize=&quot;30&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;红色文字&quot; Foreground=&quot;Red&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;底色文字&quot; Foreground=&quot;Yellow&quot; Background=&quot;Red&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Text=&quot;内间距文字&quot; Foreground=&quot;Yellow&quot; Background=&quot;Red&quot; Padding=&quot;10&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Background=&quot;LightGray&quot; Height=&quot;25&quot;&gt; &lt;Run Foreground=&quot;Red&quot;&gt;这行文字&lt;/Run&gt; &lt;Run Foreground=&quot;Green&quot;&gt;由三部分&lt;/Run&gt; &lt;Run Foreground=&quot;Blue&quot;&gt;组成&lt;/Run&gt; &lt;/TextBlock&gt; &lt;Grid Width=&quot;150&quot; Height=&quot;100&quot; Margin=&quot;5&quot; Background=&quot;LightGoldenrodYellow&quot;&gt; &lt;TextBlock Text=&quot;这段文字体现了文字的文本换行属性TextWrapping&quot; TextWrapping=&quot;Wrap&quot; Margin=&quot;10&quot;/&gt; &lt;/Grid&gt; &lt;!--使用Run--&gt; &lt;Grid&gt; &lt;TextBlock x:Name=&quot;textblock&quot; Width=&quot;320&quot; Height=&quot;100&quot; FontSize=&quot;15&quot; FontFamily=&quot;微软雅黑&quot; FontWeight=&quot;Black&quot; FontStretch=&quot;Condensed&quot; Foreground=&quot;#dddddd&quot; Background=&quot;Teal&quot; TextAlignment=&quot;Center&quot; TextWrapping=&quot;Wrap&quot; TextTrimming=&quot;CharacterEllipsis&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Center&quot; LineHeight=&quot;30&quot; ToolTip=&quot;《临江仙·滚滚长江东逝水》&quot;&gt; &lt;Run Foreground=&quot;#CDB632&quot; TextDecorations=&quot;Underline&quot;&gt; 滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。 &lt;/Run&gt; &lt;Run Text=&quot;白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。 &quot;&gt; &lt;/Run&gt; &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/WrapPanel&gt;&lt;/Window&gt; TextBlock大多数的属性应用都比较简单，容易理解。Inlines属性是一个比较强大的属性，深入理解后，可以实现意想不到的效果。另外，TextEffects也是一个非常强大的属性，这需要掌握WPF的动画、触发器、关键帧等知识，才能实现文本的动画特效。我们将在学完动画后，再回头探讨这些内容。 与文本相关的还有两个输入控件，即TextBox和PasswordBox。下一节，我们来探讨TextBox。 TextBox文本框一、概述 几乎所有的文本、数字、符号的输入都是用TextBox文本框来完成的。TextBox用来获取用户的键盘输入的信息，这也是一个常用的控件。它继承于TextBoxBase，而TextBoxBase又继承于Control，我们在前面已经介绍过Control基类，我们先看看它及TextBoxBase基类的结构定义： 二、TextBoxBase基类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public abstract class TextBoxBase : Control&#123; public static readonly DependencyProperty IsReadOnlyProperty; public static readonly RoutedEvent SelectionChangedEvent; public static readonly RoutedEvent TextChangedEvent; public static readonly DependencyProperty IsSelectionActiveProperty; public static readonly DependencyProperty CaretBrushProperty; public static readonly DependencyProperty SelectionOpacityProperty; public static readonly DependencyProperty SelectionBrushProperty; public static readonly DependencyProperty AutoWordSelectionProperty; public static readonly DependencyProperty IsInactiveSelectionHighlightEnabledProperty; public static readonly DependencyProperty IsUndoEnabledProperty; public static readonly DependencyProperty VerticalScrollBarVisibilityProperty; public static readonly DependencyProperty HorizontalScrollBarVisibilityProperty; public static readonly DependencyProperty AcceptsTabProperty; public static readonly DependencyProperty AcceptsReturnProperty; public static readonly DependencyProperty IsReadOnlyCaretVisibleProperty; public static readonly DependencyProperty UndoLimitProperty; public double ViewportWidth &#123; get; &#125; public double ExtentHeight &#123; get; &#125; public double ExtentWidth &#123; get; &#125; public ScrollBarVisibility VerticalScrollBarVisibility &#123; get; set; &#125; public bool AcceptsReturn &#123; get; set; &#125; public SpellCheck SpellCheck &#123; get; &#125; public bool AcceptsTab &#123; get; set; &#125; public bool IsReadOnlyCaretVisible &#123; get; set; &#125; public double ViewportHeight &#123; get; &#125; public ScrollBarVisibility HorizontalScrollBarVisibility &#123; get; set; &#125; public double HorizontalOffset &#123; get; &#125; public double SelectionOpacity &#123; get; set; &#125; public bool CanUndo &#123; get; &#125; public bool CanRedo &#123; get; &#125; public bool IsUndoEnabled &#123; get; set; &#125; public int UndoLimit &#123; get; set; &#125; public bool AutoWordSelection &#123; get; set; &#125; public Brush SelectionBrush &#123; get; set; &#125; public bool IsReadOnly &#123; get; set; &#125; public Brush CaretBrush &#123; get; set; &#125; public bool IsSelectionActive &#123; get; &#125; public bool IsInactiveSelectionHighlightEnabled &#123; get; set; &#125; public double VerticalOffset &#123; get; &#125; public event TextChangedEventHandler TextChanged; public event RoutedEventHandler SelectionChanged; public void AppendText(string textData); public void BeginChange(); public void Copy(); public void Cut(); public IDisposable DeclareChangeBlock(); public void EndChange(); public void LineDown(); public void LineLeft(); public void LineRight(); public void LineUp(); public void LockCurrentUndoUnit(); public override void OnApplyTemplate(); public void PageDown(); public void PageLeft(); public void PageRight(); public void PageUp(); public void Paste(); public bool Redo(); public void ScrollToEnd(); public void ScrollToHome(); public void ScrollToHorizontalOffset(double offset); public void ScrollToVerticalOffset(double offset); public void SelectAll(); public bool Undo(); protected override void OnContextMenuOpening(ContextMenuEventArgs e); protected override void OnDragEnter(DragEventArgs e); protected override void OnDragLeave(DragEventArgs e); protected override void OnDragOver(DragEventArgs e); protected override void OnDrop(DragEventArgs e); protected override void OnGiveFeedback(GiveFeedbackEventArgs e); protected override void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected override void OnLostFocus(RoutedEventArgs e); protected override void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e); protected override void OnMouseDown(MouseButtonEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected override void OnMouseUp(MouseButtonEventArgs e); protected override void OnMouseWheel(MouseWheelEventArgs e); protected override void OnPreviewKeyDown(KeyEventArgs e); protected override void OnQueryContinueDrag(QueryContinueDragEventArgs e); protected override void OnQueryCursor(QueryCursorEventArgs e); protected virtual void OnSelectionChanged(RoutedEventArgs e); protected override void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate); protected virtual void OnTextChanged(TextChangedEventArgs e); protected override void OnTextInput(TextCompositionEventArgs e); &#125; 我们看一看TextBoxBase基类都提供了哪些成员 属性成员 属性名称 说明 VerticalScrollBarVisibility 垂直滚动条是否显示 HorizontalScrollBarVisibility 水平滚动条是否显示 AcceptsReturn 表示用户按下回车键时是否插入新行。 AcceptsTab 用来设置用户按下tab键的响应，为true表示插入一个制表符，否则将焦点移动到标记为制表位的下一个控件且不插入制表符。 IsReadOnlyCaretVisible 表示只读文本框是否显示插入符号，用得较少。 SelectionOpacity 用来设置用户选中的文本的透明度。 IsUndoEnabled 表示文本编辑控件是否启用撤消支持。 UndoLimit 获取或设置存储在撤消队列中的操作数目。 AutoWordSelection 表示自动选择字词，默认为false。 SelectionBrush 表示用户选择的文本段落的画笔，比较常用。 IsReadOnly 表示文本框是否只读，这个属性经常使用。 CaretBrush 表示获取或设置用于绘制的文本框中插入符号的画笔。 IsInactiveSelectionHighlightEnabled 表示获取或设置一个值，该值指示当文本框没有焦点时，文本框中是否显示选定的文本。 事件成员 TextBoxBase基类提供了两个事件，分别是TextChanged和SelectionChanged。 TextChanged事件：只要文本框中的内容被修改，将会触发引事件，这通常用来做一些判断业务。比如某个文本框只能输入数字，那就可以去订阅TextChanged事件。 SelectionChanged事件：选中的文本框内容发生改变时引发的事件。 三、TextBox控件 在了解TextBoxBase基类之后，我们来看看这个控件本身提供了哪些属性、方法和事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TextBox : TextBoxBase, IAddChild, ITextBoxViewHost&#123; public static readonly DependencyProperty TextWrappingProperty; public static readonly DependencyProperty MinLinesProperty; public static readonly DependencyProperty MaxLinesProperty; public static readonly DependencyProperty TextProperty; public static readonly DependencyProperty CharacterCasingProperty; public static readonly DependencyProperty MaxLengthProperty; public static readonly DependencyProperty TextAlignmentProperty; public static readonly DependencyProperty TextDecorationsProperty; public TextBox(); public int MinLines &#123; get; set; &#125; public int MaxLines &#123; get; set; &#125; public string Text &#123; get; set; &#125; public CharacterCasing CharacterCasing &#123; get; set; &#125; public int MaxLength &#123; get; set; &#125; public TextAlignment TextAlignment &#123; get; set; &#125; public int CaretIndex &#123; get; set; &#125; public int SelectionLength &#123; get; set; &#125; public int SelectionStart &#123; get; set; &#125; public Typography Typography &#123; get; &#125; public int LineCount &#123; get; &#125; public TextDecorationCollection TextDecorations &#123; get; set; &#125; public string SelectedText &#123; get; set; &#125; public TextWrapping TextWrapping &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public void Clear(); public int GetCharacterIndexFromLineIndex(int lineIndex); public int GetCharacterIndexFromPoint(Point point, bool snapToText); public int GetFirstVisibleLineIndex(); public int GetLastVisibleLineIndex(); public int GetLineIndexFromCharacterIndex(int charIndex); public int GetLineLength(int lineIndex); public string GetLineText(int lineIndex); public int GetNextSpellingErrorCharacterIndex(int charIndex, LogicalDirection direction); public Rect GetRectFromCharacterIndex(int charIndex, bool trailingEdge); public Rect GetRectFromCharacterIndex(int charIndex); public SpellingError GetSpellingError(int charIndex); public int GetSpellingErrorLength(int charIndex); public int GetSpellingErrorStart(int charIndex); public void ScrollToLine(int lineIndex); public void Select(int start, int length); public bool ShouldSerializeText(XamlDesignerSerializationManager manager); protected override Size MeasureOverride(Size constraint); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e); &#125; 属性成员 属性名称 说明 MinLines 获取或设置最小可见的行数。 MaxLines 获取或设置可见行的最大数目。 Text 获取或设置文本框的文本内容。 CharacterCasing 获取或设置文本框字符的大小写形式，默认不转换。 它是一个枚举，Normal表示不转换大小写，Lower表示全部转换成小写，Upper表示全部转换成大写 MaxLength 获取或设置最大可以在文本框中手动输入的字符数。 TextAlignment 获取或设置文本框的内容的水平对齐方式。例如左对齐，右对齐，居在对齐和两端对齐。 CaretIndex 获取或设置插入点移动的插入位置索引。 SelectionLength 获取或设置一个值，该值在文本框中当前所选内容中的字符数。 SelectionStart 获取或设置当前所选内容的起始位置的字符索引。 Typography 获取文本框中的文本内容的当前有效的版式变体。 LineCount 获取文本框中的总行数。 TextDecorations 获取要应用于文本框中的文本修饰。 SelectedText 获取或设置文本框中当前选择的内容。 TextWrapping 获取或设置文本框中文本的换行方式。这个属性比较常用，在较长的文字段落显示时可以设置为Wrap，这样自动换行，界面呈现的效果比较令人满意。 TextBox文本框本身没有任务事件，都是继承父类的事件。我们先看一下它的简单使用示例。 前端代码 1234567891011121314&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock Text=&quot;用户名&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;_textbox&quot; Width=&quot;100&quot; Height=&quot;25&quot; MaxLength=&quot;10&quot; CharacterCasing=&quot;Upper&quot;/&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;确定&quot; Height=&quot;25&quot; Margin=&quot;5 0&quot; Click=&quot;_button_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; MessageBox.Show($&quot;您的用户名：&#123;_textbox.Text&#125;&quot;); &#125; &#125;&#125; 我们使用了CharacterCasing&#x3D;”Upper”这个设置，可以看到图片中的显示效果，虽然我在输入时是小写的china字符，但是，TextBox会转换成大写的CHINA，另外，总长度不能超过10个字符。 最后要获取TextBox文本框的内容，使用Text属性即可。当我们在学习了样式之后，我们还会回过头来，对TextBox控件进行深入学习。另外，TextBox还有一个大哥，也是继承于TextBoxBase基类，它叫RichTextBox 类。这个控件的功能更加强大，能够对FlowDocument流文档进行操作。如果您想开发类似Word的桌面软件，RichTextBox 和FlowDocument搭配组合是非常好的选择。 RichTextBox富文本框RichTextBox继承于TextBoxBase基类，所以很大程度上与TextBox控件类似，两者在某些情况下可以互相替换。但是，如果要为用户提供更强大的文档编辑功能，非RichTextBox莫属。在学习这个控件之前，请参阅FlowDocument（流文档）一节。 首先，我们来看看RichTextBox的结构定义： 1234567891011121314151617181920212223public class RichTextBox : TextBoxBase, IAddChild&#123; public static readonly DependencyProperty IsDocumentEnabledProperty; public RichTextBox(); public RichTextBox(FlowDocument document); public FlowDocument Document &#123; get; set; &#125; public bool IsDocumentEnabled &#123; get; set; &#125; public TextSelection Selection &#123; get; &#125; public TextPointer CaretPosition &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public TextPointer GetNextSpellingErrorPosition(TextPointer position, LogicalDirection direction); public TextPointer GetPositionFromPoint(Point point, bool snapToText); public SpellingError GetSpellingError(TextPointer position); public TextRange GetSpellingErrorRange(TextPointer position); public bool ShouldSerializeDocument(); protected override Size MeasureOverride(Size constraint); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo); &#125; RichTextBox控件有一个带参数的构造函数，参数的类型是FlowDocument类，另外，它还有一个Document属性，类型也是FlowDocument类，说明RichTextBox控件的元素必须且只能是FlowDocument类，如果您试图将RichTextBox.Document&#x3D;null，会发现它会报错。 我们假定您对FlowDocument类有一定的了解，所以，我们直接看一下示例。 前端代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;HelloWorld - www.wpfsoft.com&quot; Height=&quot;360&quot; Width=&quot;500&quot;&gt; &lt;StackPanel&gt; &lt;RichTextBox x:Name=&quot;_richTextBox&quot; Margin=&quot;10 5&quot; Height=&quot;270&quot;&gt; &lt;FlowDocument&gt; &lt;Paragraph&gt;RichTextBox富文本框控件到底有什么强大的功能? &lt;Bold Foreground=&quot;DarkRed&quot;&gt;请看下面.&lt;/Bold&gt; &lt;/Paragraph&gt; &lt;Paragraph Foreground=&quot;Blue&quot;&gt;RichTextBox唯一的子元素是FlowDocument&lt;/Paragraph&gt; &lt;Paragraph Foreground=&quot;DarkGreen&quot;&gt; FlowDocument是指流文档,一个流文档由一个或多个Block构成， 所以它有一个Blocks属性。Block只是一个抽象基类， 所以流文档的子元素其实是继承了Block的子类，例如： &lt;/Paragraph&gt; &lt;List MarkerOffset=&quot;25&quot; MarkerStyle=&quot;Decimal&quot; StartIndex=&quot;1&quot;&gt; &lt;ListItem&gt; &lt;Paragraph&gt;BlockUIContainer（UI元素容器）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;ListItem&gt; &lt;Paragraph&gt;List（有序列表）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;ListItem&gt; &lt;Paragraph&gt;Paragraph（段落）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;ListItem&gt; &lt;Paragraph&gt;Section（分组）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;ListItem&gt; &lt;Paragraph&gt;Table（网格）&lt;/Paragraph&gt; &lt;/ListItem&gt; &lt;/List&gt; &lt;/FlowDocument&gt; &lt;/RichTextBox&gt; &lt;Button x:Name=&quot;_button&quot; Content=&quot;确定&quot; Margin=&quot;10,5&quot; Click=&quot;_button_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 12345678910111213141516171819202122232425namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _button_Click(object sender, RoutedEventArgs e) &#123; TextRange textRange = new TextRange(_richTextBox.Document.ContentStart, _richTextBox.Document.ContentEnd); MessageBox.Show(textRange.Text); Paragraph paragraph = new Paragraph(); Run run = new Run($&quot;当前时间：&#123;DateTime.Now&#125;&quot;); //手动加换行 run.Foreground = Brushes.Black; paragraph.Inlines.Add(run); _richTextBox.Document.Blocks.Add(paragraph); &#125; &#125;&#125; 如上所示，我们在窗体中实例化了一个RichTextBox控件，并实例化了一个FlowDocument对象。RichTextBox唯一的子元素是FlowDocument， FlowDocument是指流文档,一个流文档由一个或多个Block构成，所以它有一个Blocks属性。Block只是一个抽象基类，FlowDocument流文档的子元素都继承了Block抽象基类，例如： BlockUIContainer（UI元素容器） List（有序列表） Paragraph（段落） Section（分组） Table（网格） BlockUIContainer是一个非常强大的段落元素，因为它可以直接包含WPF的控件。这样一来，我们就可以将设计的UI写入到流文档中显示或打印。 上面这五个元素继承了TextElement、FrameworkContentElement和ContentElement三个父素，所以实际上这五个子元素就拥有了许多字体属性的设置、资源、样式、数据绑定、以及各种事件的应用。 如果要获取RichTextBox的文本信息，可以使用TextRange类。FlowDocument类有两个属性，分别ContentStart和ContentEnd，表示文字内容的开始和结束。 所以通过TextRange类的Text，我们就能访问到RichTextBox控件的内容。 ToolTip控件（提示工具）ToolTip控件继承于ContentControl，它不能有逻辑或视觉父级，意思是说，它不能单独存在于WPF的视觉树上（不能以控件的形式实例化），它必须依附于某个控件。因为它的功能被设计成提示信息，当鼠标移动到某个控件上方时，悬停一会儿，就会显示这个ToolTip的内容。 通常ToolTip会显示一句话，用来阐述某个控件的说明。这个控件存在于FrameworkElement基类中，也就是ToolTip属性，这个属性在FrameworkElement虽然被声明成object，而不是ToolTip类型，但是，我们仍然可以自定义ToolTip的内容。重点：WPF几乎所有控件都可以拥有ToolTip小型提示弹窗！ 因为ToolTip继承于ContentControl控件，所以，ToolTip拥有的Content属性就可以显示任何类型，比如字符串、图像、其它控件组合布局。 123456789101112131415161718192021222324252627282930313233343536public class ToolTip : ContentControl&#123; public static readonly DependencyProperty HorizontalOffsetProperty; public static readonly RoutedEvent OpenedEvent; public static readonly DependencyProperty StaysOpenProperty; public static readonly DependencyProperty CustomPopupPlacementCallbackProperty; public static readonly DependencyProperty PlacementProperty; public static readonly RoutedEvent ClosedEvent; public static readonly DependencyProperty PlacementTargetProperty; public static readonly DependencyProperty HasDropShadowProperty; public static readonly DependencyProperty IsOpenProperty; public static readonly DependencyProperty VerticalOffsetProperty; public static readonly DependencyProperty PlacementRectangleProperty; public ToolTip(); public bool IsOpen &#123; get; set; &#125; public bool StaysOpen &#123; get; set; &#125; public CustomPopupPlacementCallback CustomPopupPlacementCallback &#123; get; set; &#125; public PlacementMode Placement &#123; get; set; &#125; public Rect PlacementRectangle &#123; get; set; &#125; public UIElement PlacementTarget &#123; get; set; &#125; public double HorizontalOffset &#123; get; set; &#125; public double VerticalOffset &#123; get; set; &#125; public bool HasDropShadow &#123; get; set; &#125; public event RoutedEventHandler Closed; public event RoutedEventHandler Opened; protected virtual void OnClosed(RoutedEventArgs e); protected override void OnContentChanged(object oldContent, object newContent); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnOpened(RoutedEventArgs e); protected internal override void OnVisualParentChanged(DependencyObject oldParent); &#125; 简单使用 1&lt;Button Content=&quot;确定&quot; ToolTip=&quot;WPF中文网之控件课程&quot;/&gt; 自定义ToolTip内容 1234567891011121314&lt;Button x:Name=&quot;button2&quot; Content=&quot;网站&quot; Width=&quot;100&quot; Height=&quot;30&quot; Margin=&quot;5&quot; Click=&quot;button2_Click&quot;&gt; &lt;Button.ToolTip&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;官方网站&quot; FontWeight=&quot;Bold&quot; /&gt; &lt;TextBlock Text=&quot;点击这个按钮，进入WPF中文网站&quot;/&gt; &lt;Border BorderBrush=&quot;Silver&quot; BorderThickness=&quot;0,1,0,0&quot; Margin=&quot;0,4&quot;/&gt; &lt;TextBlock Text=&quot;http://www.wpfsoft.com&quot; FontStyle=&quot;Italic&quot;/&gt; &lt;/StackPanel&gt; &lt;/Button.ToolTip&gt;&lt;/Button&gt;private void button2_Click(object sender, RoutedEventArgs e)&#123; Process.Start(&quot;http://www.wpfsoft.com&quot;);&#125; 虽然ToolTip可以自定义内容，但是，ToolTip的内容无法接收焦点。 与ToolTip有点类似的控件，还有一个叫Popup控件，也是一个弹出窗口，并可以在这个窗口内任意布局。我们在下一节来探讨它。 Popup弹出窗口Popup类似于ToolTip，在指定的元素或窗体中弹出一个具有任意内容的窗口。Popup继承于FrameworkElement，算得上是独门独户的控件，因为大多数控件都是从Shape、Control或Panel三个类继承而来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Popup : FrameworkElement, IAddChild&#123; public static readonly DependencyProperty ChildProperty; public static readonly DependencyProperty IsOpenProperty; public static readonly DependencyProperty PlacementProperty; public static readonly DependencyProperty CustomPopupPlacementCallbackProperty; public static readonly DependencyProperty StaysOpenProperty; public static readonly DependencyProperty HorizontalOffsetProperty; public static readonly DependencyProperty VerticalOffsetProperty; public static readonly DependencyProperty PlacementTargetProperty; public static readonly DependencyProperty PlacementRectangleProperty; public static readonly DependencyProperty PopupAnimationProperty; public static readonly DependencyProperty AllowsTransparencyProperty; public static readonly DependencyProperty HasDropShadowProperty; public Popup(); public bool HasDropShadow &#123; get; &#125; public bool AllowsTransparency &#123; get; set; &#125; public PopupAnimation PopupAnimation &#123; get; set; &#125; public Rect PlacementRectangle &#123; get; set; &#125; public UIElement PlacementTarget &#123; get; set; &#125; public double VerticalOffset &#123; get; set; &#125; public double HorizontalOffset &#123; get; set; &#125; public bool StaysOpen &#123; get; set; &#125; public UIElement Child &#123; get; set; &#125; public bool IsOpen &#123; get; set; &#125; public PlacementMode Placement &#123; get; set; &#125; public CustomPopupPlacementCallback CustomPopupPlacementCallback &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public event EventHandler Closed; public event EventHandler Opened; public static void CreateRootPopup(Popup popup, UIElement child); protected override Size MeasureOverride(Size availableSize); protected virtual void OnClosed(EventArgs e); protected virtual void OnOpened(EventArgs e); protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e); protected override void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e); protected override void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e); protected internal override DependencyObject GetUIParentCore(); &#125; 属性成员 属性名称 说明 HasDropShadow 只读属性，控件是否有投影效果。 AllowsTransparency 获取或设置控件是否包含透明内容。 PopupAnimation 获取或设置控件打开或关闭时的动画效果，None表示没有动画，Fade表示逐渐显示或淡出，Slide表示向上向下滑入，Scroll表示滚动效果。 PlacementRectangle 获取或设置控件打开时的矩形位置 。 PlacementTarget 获取或设置Popup控件在哪个控件身边打开（重点）。 VerticalOffset 获取或设置目标原点和 popup 对齐点之间的垂直距离。 HorizontalOffset 获取或设置目标原点和弹出项对齐之间的水平距离点。 StaysOpen 默认值为true，表示Popup打开后，如果失去焦点，Popup是否继续显示（重点）。 Child 获取或设置控件的内容，类似于ContentControl的Content属性，只能拥有一个元素（重点）。 IsOpen 获取或设置Popup控件是否可见。 Placement 枚举类，表示Popup 控件显示时的对齐方式。 事件成员 Opened事件：Popup控件打开时引发的事件。 Closed事件：Popup控件关闭时引发的事件 12345678910111213141516171819202122232425&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;CheckBox x:Name=&quot;checkbox&quot; Content=&quot;WPF中文网&quot; Height=&quot;30&quot; Margin=&quot;5&quot; ToolTip=&quot;WPF中文网之控件课程&quot;/&gt; &lt;Popup Name=&quot;myPopup&quot; IsOpen=&quot;&#123;Binding IsChecked, ElementName=checkbox&#125;&quot; PlacementTarget=&quot;&#123;Binding ElementName=checkbox&#125;&quot; StaysOpen=&quot;True&quot;&gt; &lt;Border BorderThickness=&quot;1&quot; Background=&quot;LightBlue&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;官方网站&quot; FontWeight=&quot;Bold&quot; /&gt; &lt;TextBlock Text=&quot;点击这个按钮，进入WPF中文网站&quot;/&gt; &lt;Border BorderBrush=&quot;Silver&quot; BorderThickness=&quot;0,1,0,0&quot; Margin=&quot;0,4&quot;/&gt; &lt;TextBlock Text=&quot;http://www.wpfsoft.com&quot; FontStyle=&quot;Italic&quot;/&gt; &lt;/StackPanel&gt; &lt;/Border&gt; &lt;/Popup&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 代码分析 我们分别实例化了名叫checkbox和myPopup控件，myPopup的IsOpen属性绑定了checkbox的IsChecked，意思是， 当用户点击checkbox时，checkbox的IsChecked属性为true，myPopup的IsOpen属性也为true，于是就可以显示myPopup的内容了。 同时，myPopup的PlacementTarget属性也绑定到了checkbox控件，意味着myPopup将显示在checkbox控件身边，至于具体位置，可以设置Placement属性，有兴趣的小伙伴可以去尝试一下。 这里我们用到了Binding这个类，可以把它看成是一座桥梁，我们会在后面专门详细讲解Binding的用法。 Image图像控件Image也算是独门独户的控件，因为它也是直接继承于FrameworkElement基类。Image控件，顾名思义，就是图像显示控件。Image类能够加载显示的图片格式有.bmp、.gif、.ico、.jpg、.png、.wdp 和 .tiff。要注意的是，加载.gif动画图片时，仅显示第一帧。如果要显示gif图片，可以在nuget服务器中下载WpfAnimatedGif组件。 一、Image类的定义 12345678910111213141516171819202122232425public class Image : FrameworkElement, IUriContext, IProvidePropertyFallback&#123; public static readonly DependencyProperty SourceProperty; public static readonly RoutedEvent DpiChangedEvent; public static readonly DependencyProperty StretchProperty; public static readonly DependencyProperty StretchDirectionProperty; public static readonly RoutedEvent ImageFailedEvent; public Image(); public StretchDirection StretchDirection &#123; get; set; &#125; public Stretch Stretch &#123; get; set; &#125; public ImageSource Source &#123; get; set; &#125; protected virtual Uri BaseUri &#123; get; set; &#125; public event DpiChangedEventHandler DpiChanged; public event EventHandler&lt;ExceptionRoutedEventArgs&gt; ImageFailed; protected override Size ArrangeOverride(Size arrangeSize); protected override Size MeasureOverride(Size constraint); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi); protected override void OnRender(DrawingContext dc); &#125; 二、属性成员 属性名称 说明 StretchDirection 枚举型，表示图像缩放的条件，UpOnly表示内容仅在小于父级时缩放；DownOnly表示内容仅大于父级时缩放；Both表示兼容前面两种缩放条件。 Stretch 枚举型，表示图像缩放的模式，None表示内容保持其原始大小；Fill表示调整内容大小以填充目标尺寸，且不保留纵横比；Uniform表示在保留纵横比基础上缩放；UniformToFill表示在保留纵横比基础上缩放，同时具有裁剪功能。 Source 图像源，其类型为ImageSource。 BaseUri 获取或设置基 统一资源标识符 (URI) 为 System.Windows.Controls.Image。 三、事件成员 事件名称 说明 DpiChanged 显示图像的屏幕的 DPI 发生更改后触发。 ImageFailed 在图像中失败时触发。 四、Image控件分析 Image控件最关键的就是Source属性——即ImageSource类型。ImageSource是一个抽象类，表示具有高度、宽度及ImageMetadata对象的图像数据源。ImageSource有多个子类，如BitmapFrame、BitmapSource和DrawingImage。所以，我们如果要显示一张图片，需要将图片转化成BitmapSource或DrawingImage实例，赋值给Image控件的Source属性就行了。 4.1常规图片加载 例如：http://www.wpfsoft.com/wp-content/uploads/2023/08/2023080309592548.png 我们将上面这张图片下载后，导到入HelloWorld项目的Images目录中，然后就可以在前端代码中显示。 1&lt;Image Source=&quot;/Images/logo.png&quot; Width=&quot;120&quot; Height=&quot;120&quot;/&gt; 或者 统一资源标识Uri WPF引入了统一资源标识Uri(Unified Resource Identifier)来标识和访问资源。其中较为常见的情况是用Uri加载图像。Uri表达式的一般形式为：协议+授权+路径，协议：pack:&#x2F;&#x2F;，授权：有两种。一种用于访问编译时已经知道的文件，用application:&#x2F;&#x2F;&#x2F;一种用于访问编译时不知道、运行时才知道的文件，用siteoforigin:&#x2F;&#x2F;&#x2F;一般用逗号代替斜杠，也就是改写作application:,和pack:,路径：分为绝对路径和相对路径。一般选用相对路径，普适性更强 1&lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;120&quot; Height=&quot;120&quot;/&gt; 明明Source是ImageSource类型，为什么可以接受一个代表图片路径的字符串呢？因为ImageSource类中有一个ToString()重载成员。 4.2本地图片加载 接下来，我们把这个张图片放到Debug目录中，试试用另一种方式加载本地图片。 此时，这张图片并没有导入到项目中，我们来看一下如何加载本地图片。 前端代码 1234&lt;WrapPanel&gt; &lt;Image Source=&quot;/Images/logo.png&quot; Width=&quot;120&quot; Height=&quot;120&quot;/&gt; &lt;Image x:Name=&quot;image2&quot; Width=&quot;120&quot; Height=&quot;120&quot;/&gt;&lt;/WrapPanel&gt; 后端代码 12345678910public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); var path = Environment.CurrentDirectory + &quot;\\\\&quot; + &quot;logo.png&quot;; var imageSource = BitmapFrame.Create(new Uri(path), BitmapCreateOptions.None, BitmapCacheOption.OnLoad); image2.Source = imageSource; &#125;&#125; 在主窗体的构造函数中，我们获取了图片的完整地址，然后利用BitmapFrame类Create方法成员将本地图片加载进来并返回一个BitmapFrame对象，BitmapFrame对象继承于BitmapSource，所以我们可以将这个实例通过C#代码的方式赋值给image2的Source属性。 GroupBox标题容器控件GroupBox控件的功能是提供一个带标题的内容容器，它继承于HeaderedContentControl类，HeaderedContentControl继承于ContentControl类。通常它用来做一些局部的布局。由于GroupBox本身并没有什么成员，所以我们直接观察它的基类。 一、HeaderedContentControl基类 123456789101112131415161718192021222324public class HeaderedContentControl : ContentControl&#123; public static readonly DependencyProperty HeaderProperty; public static readonly DependencyProperty HasHeaderProperty; public static readonly DependencyProperty HeaderTemplateProperty; public static readonly DependencyProperty HeaderTemplateSelectorProperty; public static readonly DependencyProperty HeaderStringFormatProperty; public HeaderedContentControl(); public DataTemplateSelector HeaderTemplateSelector &#123; get; set; &#125; public DataTemplate HeaderTemplate &#123; get; set; &#125; public string HeaderStringFormat &#123; get; set; &#125; public bool HasHeader &#123; get; &#125; public object Header &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public override string ToString(); protected virtual void OnHeaderChanged(object oldHeader, object newHeader); protected virtual void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat); protected virtual void OnHeaderTemplateChanged(DataTemplate oldHeaderTemplate, DataTemplate newHeaderTemplate); protected virtual void OnHeaderTemplateSelectorChanged(DataTemplateSelector oldHeaderTemplateSelector, DataTemplateSelector newHeaderTemplateSelector); &#125; 在这个基类中，我们可以看到他继承于ContentControl基类，所以GroupBox要显示的内容都会放到Content属性中，而GroupBox的标题则放在Header属性中，注意，Header属性也是object。这足以说明GroupBox在私人定制方面的强大扩展性。 再加上HeaderTemplate属性，可以定制标题的外观。待我们在后面学了模板和样式，再回头来探讨这一类的属性的应用。 GroupBox的简单用法如下： 12345678910111213141516171819202122232425262728293031323334&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;GroupBox Header=&quot;缩略图&quot; Margin=&quot;5&quot;&gt; &lt;WrapPanel&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;/WrapPanel&gt; &lt;/GroupBox&gt;&lt;/Window&gt; 因为GroupBox的Content属性只能显示一个内容对象，如果要显示多个对象，那把给Content一个集合控件，比如上面的WrapPanel控件，这样就可以在WrapPanel控件中放多个子元素了。 在使用上，有一个集合控件与GroupBox类似，因为GroupBox只能显示一个区域，如果区域过大，在有限的窗体无法全部显示出来，该怎么办呢？ScrollViewer可以做到这一点。 下一节，我们来探讨一下ScrollViewer控件的用法。 ScrollViewer控件如果某个控件的尺寸太大，当前界面无法全部显示，则可以将这个控件包含在ScrollViewer中，因为ScrollViewer控件封装了一个水平滚动条ScrollBar和一个垂直滚动条ScrollBar，所以，ScrollViewer就是一个包含其它可视元素的可滚动区域控件。 ScrollViewer继承于ContentControl，所以它也是一个内容控件，只能在Content属性中设置一个子元素，如果要在ScrollViewer中显示多个子元素，请设置一个集合控件。 ScrollViewer 控件既响应鼠标命令，也响应键盘命令，并定义许多可用于按预设的增量滚动内容的方法。 可以使用 ScrollChanged 事件来检测 ScrollViewer 状态的变化。 一、ScrollViewer类的定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class ScrollViewer : ContentControl&#123; public static readonly DependencyProperty CanContentScrollProperty; public static readonly DependencyProperty PanningRatioProperty; public static readonly DependencyProperty PanningDecelerationProperty; public static readonly DependencyProperty PanningModeProperty; public static readonly RoutedEvent ScrollChangedEvent; public static readonly DependencyProperty IsDeferredScrollingEnabledProperty; public static readonly DependencyProperty ViewportWidthProperty; public static readonly DependencyProperty ScrollableHeightProperty; public static readonly DependencyProperty ScrollableWidthProperty; public static readonly DependencyProperty ExtentHeightProperty; public static readonly DependencyProperty ViewportHeightProperty; public static readonly DependencyProperty ContentHorizontalOffsetProperty; public static readonly DependencyProperty ContentVerticalOffsetProperty; public static readonly DependencyProperty HorizontalOffsetProperty; public static readonly DependencyProperty ExtentWidthProperty; public static readonly DependencyProperty VerticalOffsetProperty; public static readonly DependencyProperty ComputedVerticalScrollBarVisibilityProperty; public static readonly DependencyProperty ComputedHorizontalScrollBarVisibilityProperty; public static readonly DependencyProperty VerticalScrollBarVisibilityProperty; public static readonly DependencyProperty HorizontalScrollBarVisibilityProperty; public ScrollViewer(); public bool CanContentScroll &#123; get; set; &#125; public ScrollBarVisibility HorizontalScrollBarVisibility &#123; get; set; &#125; public ScrollBarVisibility VerticalScrollBarVisibility &#123; get; set; &#125; public Visibility ComputedHorizontalScrollBarVisibility &#123; get; &#125; public Visibility ComputedVerticalScrollBarVisibility &#123; get; &#125; public double HorizontalOffset &#123; get; &#125; public double VerticalOffset &#123; get; &#125; public double ExtentWidth &#123; get; &#125; public double ExtentHeight &#123; get; &#125; public double PanningDeceleration &#123; get; set; &#125; public double ScrollableHeight &#123; get; &#125; public double ViewportWidth &#123; get; &#125; public double ViewportHeight &#123; get; &#125; public double ContentVerticalOffset &#123; get; &#125; public double ContentHorizontalOffset &#123; get; &#125; public bool IsDeferredScrollingEnabled &#123; get; set; &#125; public PanningMode PanningMode &#123; get; set; &#125; public double ScrollableWidth &#123; get; &#125; public double PanningRatio &#123; get; set; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; protected internal IScrollInfo ScrollInfo &#123; get; set; &#125; public event ScrollChangedEventHandler ScrollChanged; public static bool GetCanContentScroll(DependencyObject element); public static ScrollBarVisibility GetHorizontalScrollBarVisibility(DependencyObject element); public static bool GetIsDeferredScrollingEnabled(DependencyObject element); public static double GetPanningDeceleration(DependencyObject element); public static PanningMode GetPanningMode(DependencyObject element); public static double GetPanningRatio(DependencyObject element); public static ScrollBarVisibility GetVerticalScrollBarVisibility(DependencyObject element); public static void SetCanContentScroll(DependencyObject element, bool canContentScroll); public static void SetHorizontalScrollBarVisibility(DependencyObject element, ScrollBarVisibility horizontalScrollBarVisibility); public static void SetIsDeferredScrollingEnabled(DependencyObject element, bool value); public static void SetPanningDeceleration(DependencyObject element, double value); public static void SetPanningMode(DependencyObject element, PanningMode panningMode); public static void SetPanningRatio(DependencyObject element, double value); public static void SetVerticalScrollBarVisibility(DependencyObject element, ScrollBarVisibility verticalScrollBarVisibility); public void InvalidateScrollInfo(); public void LineDown(); public void LineLeft(); public void LineRight(); public void LineUp(); public override void OnApplyTemplate(); public void PageDown(); public void PageLeft(); public void PageRight(); public void PageUp(); public void ScrollToBottom(); public void ScrollToEnd(); public void ScrollToHome(); public void ScrollToHorizontalOffset(double offset); public void ScrollToLeftEnd(); public void ScrollToRightEnd(); public void ScrollToTop(); public void ScrollToVerticalOffset(double offset); protected override Size ArrangeOverride(Size arrangeSize); protected override HitTestResult HitTestCore(PointHitTestParameters hitTestParameters); protected override Size MeasureOverride(Size constraint); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnKeyDown(KeyEventArgs e); protected override void OnManipulationCompleted(ManipulationCompletedEventArgs e); protected override void OnManipulationDelta(ManipulationDeltaEventArgs e); protected override void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e); protected override void OnManipulationStarting(ManipulationStartingEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseWheel(MouseWheelEventArgs e); protected virtual void OnScrollChanged(ScrollChangedEventArgs e); protected override void OnStylusSystemGesture(StylusSystemGestureEventArgs e); &#125; 二、属性成员 HorizontalScrollBarVisibility：是否隐藏水平滚动条，为true表示隐藏，此时水平方向不可滚动。 VerticalScrollBarVisibility：是否隐藏垂直滚动条，为true表示隐藏，此时垂直方向不可滚动。 三、事件成员 ScrollChanged：当控件的滚动位置发生变化时将触发此事件。 四、示例 前端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;ScrollViewer&gt; &lt;WrapPanel&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;/WrapPanel&gt; &lt;/ScrollViewer&gt;&lt;/Window&gt; 如上所示，我们在WrapPanel中增加了许多子元素，然后在外面套了一层ScrollViewer，由于WrapPanel是自动换行显示所有子元素（图片），所以，ScrollViewer会做出相应适配，只显示垂直滚动条。 既然ScrollViewer类封装了两个滚动条（ScrollBar），那我们就必须要了解一下ScrollBar的特性与用法，以加强我们对WPF控件的运用能力。下一节，我们将介绍ScrollBar。 ScrollBar滚动条ScrollBar表示一个滚动条，该滚动条具有一个滑动 Thumb，其位置对应于一个值。它继承于RangeBase抽象基类，RangeBase基类继承于Control基类。带滚动特质的还有两个控件，也继承于RangeBase抽象基类，它们分别是ProgressBar（进度条）和Slider（滑动条）。待我们探讨完ScrollBar，再来探讨ProgressBar和Slider。 一、RangeBase抽象基类定义 12345678910111213141516171819202122232425public abstract class RangeBase : Control&#123; public static readonly RoutedEvent ValueChangedEvent; public static readonly DependencyProperty MinimumProperty; public static readonly DependencyProperty MaximumProperty; public static readonly DependencyProperty ValueProperty; public static readonly DependencyProperty LargeChangeProperty; public static readonly DependencyProperty SmallChangeProperty; protected RangeBase(); public double LargeChange &#123; get; set; &#125; public double SmallChange &#123; get; set; &#125; public double Value &#123; get; set; &#125; public double Maximum &#123; get; set; &#125; public double Minimum &#123; get; set; &#125; public event RoutedPropertyChangedEventHandler&lt;double&gt; ValueChanged; public override string ToString(); protected virtual void OnMaximumChanged(double oldMaximum, double newMaximum); protected virtual void OnMinimumChanged(double oldMinimum, double newMinimum); protected virtual void OnValueChanged(double oldValue, double newValue); &#125; RangeBase 只有5个属性 属性名称 说明 LargeChange 表示给Value属性加减的最大值。默认为1 SmallChange 表示给Value属性加减的最小值。默认为0.1 Value 获取或设置范围控件的当前数量。默认为0 Maximum 获取或设置Value属性的最大值 Minimum 获取或设置Value属性的最小值 RangeBase事件成员 ValueChanged：当前Value属性发生改变时触发的事件。 总结，ScrollBar、ProgressBar和Slider都将继承上面的属性、方面与事件成员。 二、ScrollBar类定义 123456789101112131415161718192021222324252627282930313233343536373839404142public class ScrollBar : RangeBase&#123; public static readonly RoutedEvent ScrollEvent; public static readonly RoutedCommand ScrollHereCommand; public static readonly RoutedCommand DeferScrollToVerticalOffsetCommand; public static readonly RoutedCommand DeferScrollToHorizontalOffsetCommand; public static readonly RoutedCommand ScrollToVerticalOffsetCommand; public static readonly RoutedCommand ScrollToHorizontalOffsetCommand; public static readonly RoutedCommand ScrollToTopCommand; public static readonly RoutedCommand ScrollToLeftEndCommand; public static readonly RoutedCommand ScrollToRightEndCommand; public static readonly RoutedCommand ScrollToHomeCommand; public static readonly RoutedCommand ScrollToEndCommand; public static readonly RoutedCommand ScrollToBottomCommand; public static readonly RoutedCommand PageLeftCommand; public static readonly RoutedCommand PageDownCommand; public static readonly RoutedCommand PageUpCommand; public static readonly RoutedCommand LineRightCommand; public static readonly RoutedCommand PageRightCommand; public static readonly RoutedCommand LineLeftCommand; public static readonly RoutedCommand LineDownCommand; public static readonly RoutedCommand LineUpCommand; public static readonly DependencyProperty ViewportSizeProperty; public static readonly DependencyProperty OrientationProperty; public ScrollBar(); public Orientation Orientation &#123; get; set; &#125; public double ViewportSize &#123; get; set; &#125; public Track Track &#123; get; &#125; protected override bool IsEnabledCore &#123; get; &#125; public event ScrollEventHandler Scroll; public override void OnApplyTemplate(); protected override void OnContextMenuClosing(ContextMenuEventArgs e); protected override void OnContextMenuOpening(ContextMenuEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e); &#125; ScrollBar自身有两个属性是我们必须要掌握的，那就是Orientation 和ViewportSize 。 Orientation ：表示当前滚动条是水平的还是垂直的。 ViewportSize：获取或设置当前可见的可滚动内容的数量。默认值为0。 另外，它还有一个滚动事件Scroll可以使用。我们还是以实际的例子来说明它的用法吧。 前端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid x:Name=&quot;viewport&quot; &gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;115&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Canvas&gt; &lt;StackPanel x:Name=&quot;element&quot; Orientation=&quot;Horizontal&quot; Canvas.Left=&quot;&#123;Binding CanvasLeft&#125;&quot;&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;/Canvas&gt; &lt;ScrollBar Grid.Row=&quot;1&quot; Orientation=&quot;Horizontal&quot; Maximum=&quot;&#123;Binding Maximum&#125;&quot; Value=&quot;&#123;Binding X&#125;&quot; ViewportSize=&quot;&#123;Binding ElementName=viewport,Path=ActualWidth&#125;&quot;/&gt; &lt;TextBlock Grid.Row=&quot;2&quot; Text=&quot;ScrollBar&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; FontSize=&quot;24&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 观察这个UI设计，我们故意在StackPanel控件中增加了多张图片，使其不能完全在Canvas中显示出来，然后在下面实例化了一根水平滚动条。注意滚动条的其中三个参数使用了绑定，不熟悉的小伙伴可参阅数据绑定那一章节。 Maximum：表示这根滚动条的最大值。 Value：表示滚动条的当前值。 ViewportSize：表示滚动条要作用于某个控件的宽度（这里实际上指Grid的宽度）。 最后，我们将StackPanel控件的Canvas.Left依赖属性绑定到一个CanvasLeft属性。只要CanvasLeft属性的值发生改变，那么StackPanel相对于Canvas水平位置就发生改变。 那么CanvasLeft属性是怎样发生改变的呢？这一切将在后台代码中实现。 后端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System.ComponentModel;using System.Windows; namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window,INotifyPropertyChanged &#123; public MainWindow() &#123; InitializeComponent(); DataContext = this;//将当前窗体作为ViewModel赋值给当前窗体的DataContext Loaded += (s, e) =&gt; &#123; //计算滚动条的最大值 Maximum = element.ActualWidth - viewport.ActualWidth; &#125;; &#125; private double maximum = 0; /// &lt;summary&gt; /// 滚动条的最大值 /// &lt;/summary&gt; public double Maximum &#123; get &#123; return maximum; &#125; set &#123; maximum = value; NotifyPropertyChanged(&quot;Maximum&quot;); &#125; &#125; private double x = 0; /// &lt;summary&gt; /// 滚动条的当前值 /// &lt;/summary&gt; public double X &#123; get &#123; return x; &#125; set &#123; x = value; CanvasLeft = -x; NotifyPropertyChanged(&quot;X&quot;); &#125; &#125; private double canvasLeft = 0; /// &lt;summary&gt; /// 相对于Canvas控件Left边距 /// &lt;/summary&gt; public double CanvasLeft &#123; get &#123; return canvasLeft; &#125; set &#123; canvasLeft = value; NotifyPropertyChanged(&quot;CanvasLeft&quot;); &#125; &#125; public event PropertyChangedEventHandler PropertyChanged; /// &lt;summary&gt; /// 属性通知方法 /// &lt;/summary&gt; /// &lt;param name=&quot;propertyName&quot;&gt;&lt;/param&gt; protected virtual void NotifyPropertyChanged(string propertyName) &#123; if (this.PropertyChanged != null) &#123; this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); &#125; &#125; &#125;&#125; 如上所示，我们获取到滚动条的值X，然后取反后赋值给CanvasLeft属性，而CanvasLeft属性拥有“属性通知”功能，故而前端StackPanel的相对位置会随着用户拖动滚动条而变化。 关于属性通知及INotifyPropertyChanged接口，我们将在数据绑定一章讲解。 掌握了ScrollBar的用法后，Slider控件也基本就掌握了，下一节，我们来探讨Slider。对了，如果把下面这段代码换成Slider控件，也是可以用的哦。 更换前 1234&lt;ScrollBar Grid.Row=&quot;1&quot; Orientation=&quot;Horizontal&quot; Maximum=&quot;&#123;Binding Maximum&#125;&quot; Value=&quot;&#123;Binding X&#125;&quot; ViewportSize=&quot;&#123;Binding ElementName=viewport,Path=ActualWidth&#125;&quot;/&gt; 更换后 1&lt;Slider Grid.Row=&quot;1&quot; Maximum=&quot;&#123;Binding Maximum&#125;&quot; Value=&quot;&#123;Binding X&#125;&quot;/&gt; Slider滑动条Slider滑动条与ScrollBar滚动条有点相似，甚至某些情况下，两者还可以互换使用。Slider也继承于RangeBase基类，其功能是提供一个可以滑动取值的控件。 一、Slider类定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Slider : RangeBase&#123; public static readonly DependencyProperty OrientationProperty; public static readonly DependencyProperty IsMoveToPointEnabledProperty; public static readonly DependencyProperty SelectionEndProperty; public static readonly DependencyProperty SelectionStartProperty; public static readonly DependencyProperty IsSelectionRangeEnabledProperty; public static readonly DependencyProperty TickFrequencyProperty; public static readonly DependencyProperty TickPlacementProperty; public static readonly DependencyProperty TicksProperty; public static readonly DependencyProperty AutoToolTipPrecisionProperty; public static readonly DependencyProperty AutoToolTipPlacementProperty; public static readonly DependencyProperty IntervalProperty; public static readonly DependencyProperty DelayProperty; public static readonly DependencyProperty IsDirectionReversedProperty; public static readonly DependencyProperty IsSnapToTickEnabledProperty; public Slider(); public static RoutedCommand MinimizeValue &#123; get; &#125; public static RoutedCommand IncreaseSmall &#123; get; &#125; public static RoutedCommand DecreaseSmall &#123; get; &#125; public static RoutedCommand MaximizeValue &#123; get; &#125; public static RoutedCommand DecreaseLarge &#123; get; &#125; public static RoutedCommand IncreaseLarge &#123; get; &#125; public bool IsSnapToTickEnabled &#123; get; set; &#125; public int AutoToolTipPrecision &#123; get; set; &#125; public AutoToolTipPlacement AutoToolTipPlacement &#123; get; set; &#125; public int Interval &#123; get; set; &#125; public int Delay &#123; get; set; &#125; public bool IsDirectionReversed &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; public double TickFrequency &#123; get; set; &#125; public DoubleCollection Ticks &#123; get; set; &#125; public double SelectionStart &#123; get; set; &#125; public TickPlacement TickPlacement &#123; get; set; &#125; public bool IsSelectionRangeEnabled &#123; get; set; &#125; public bool IsMoveToPointEnabled &#123; get; set; &#125; public double SelectionEnd &#123; get; set; &#125; public override void OnApplyTemplate(); protected override Size ArrangeOverride(Size finalSize); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnDecreaseLarge(); protected virtual void OnDecreaseSmall(); protected virtual void OnIncreaseLarge(); protected virtual void OnIncreaseSmall(); protected virtual void OnMaximizeValue(); protected override void OnMaximumChanged(double oldMaximum, double newMaximum); protected virtual void OnMinimizeValue(); protected override void OnMinimumChanged(double oldMinimum, double newMinimum); protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e); protected virtual void OnThumbDragCompleted(DragCompletedEventArgs e); protected virtual void OnThumbDragDelta(DragDeltaEventArgs e); protected virtual void OnThumbDragStarted(DragStartedEventArgs e); protected override void OnValueChanged(double oldValue, double newValue); &#125; 二、属性成员 属性名称 说明 IsSnapToTickEnabled Slider会有一些刻度线，如果要求Thumb移动到最近的刻度线，则可将该值设置为true。 AutoToolTipPrecision 获取或设置Slider的值的小数点位数。 AutoToolTipPlacement 获取或设置按下Thumb时是否显示提示工具。 Interval 获取或设置用户按下RepeatButton时执行增加减少命令的时间间隔（毫秒）。 Delay 获取或设置用户按下RepeatButton时延时多少毫秒后执行命令 IsDirectionReversed 获取或设置增加值的方向。 Orientation 获取或设置Slider的方向。水平或垂直。 TickFrequency 获取或设置刻度线之间的间隔。默认为1.0 Ticks 获取或设置为 System.Windows.Controls.Slider 显示的刻度线的位置。 SelectionStart 获取或设置 System.Windows.Controls.Slider 的指定选择内容的最大值。 TickPlacement 获取或设置刻度线的位置 IsSelectionRangeEnabled 获取或设置显示选择范围 IsMoveToPointEnabled 如果Thumb 立即移动到鼠标单击的位置，则为true。 SelectionEnd 获取或设置 System.Windows.Controls.Slider 的指定选择内容的最大值。 三、Slider示例 观察下面的例子，看看Slider如何通过拖动去改变元素的尺寸。 123456789101112131415161718192021222324252627&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid x:Name=&quot;viewport&quot; &gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Canvas&gt; &lt;Border BorderBrush=&quot;LightGray&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;5&quot; Padding=&quot;3&quot; Margin=&quot;3&quot;&gt; &lt;Image Source=&quot;pack://application:,,,/Images/logo.png&quot; Width=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Height=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot;/&gt; &lt;/Border&gt; &lt;/Canvas&gt; &lt;DockPanel Grid.Row=&quot;1&quot;&gt; &lt;TextBlock Text=&quot;滑动改变图片大小&quot; Margin=&quot;3&quot; FontSize=&quot;14&quot;/&gt; &lt;Slider x:Name=&quot;slider&quot; Minimum=&quot;50&quot; Maximum=&quot;500&quot; Value=&quot;50&quot; Margin=&quot;3&quot;/&gt; &lt;/DockPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; ProgressBar进度条ProgressBar进度条通常在我们执行某个任务需要花费大量时间时使用，这时可以采用进度条显示任务或线程的执行进度，以便给用户良好的使用体验。 一、ProgressBar类定义 1234567891011121314151617public class ProgressBar : RangeBase&#123; public static readonly DependencyProperty IsIndeterminateProperty; public static readonly DependencyProperty OrientationProperty; public ProgressBar(); public bool IsIndeterminate &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; public override void OnApplyTemplate(); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnMaximumChanged(double oldMaximum, double newMaximum); protected override void OnMinimumChanged(double oldMinimum, double newMinimum); protected override void OnValueChanged(double oldValue, double newValue); &#125; ProgressBar自身只有两个属性，分别是IsIndeterminate和Orientation 。 IsIndeterminate属性：如果为true，表示以动画从左到右滑动的方式展示进度效果。 Orientation属性：表示进度条的方式，水平时从左至右增长，垂直时从下到上增长。 二、ProgressBar例子 前端代码 12345678910111213141516171819202122&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;16&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel VerticalAlignment=&quot;Center&quot;&gt; &lt;ProgressBar x:Name=&quot;_ProgressBar&quot; IsIndeterminate=&quot;False&quot; Value=&quot;50&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; Orientation=&quot;Horizontal&quot; Height=&quot;10&quot; Margin=&quot;15&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlock&quot; Text=&quot;50%&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718192021222324public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); Loaded += (s, e) =&gt; &#123; Task.Factory.StartNew(() =&gt; &#123; for (int i = 0; i &lt;= 100; i++) &#123; Dispatcher.Invoke(() =&gt; &#123; _TextBlock.Text = $&quot;&#123;i&#125;%&quot;; _ProgressBar.Value = i; &#125;); Task.Delay(25).Wait(); &#125; &#125;); &#125;; &#125; &#125; 三、代码分析 我们在主窗体的Loaded事件中增加了一个子线程，需要注意的是，在子线程中不可以直接更新UI线程的控件，所以我们利用Dispatcher类，将访问UI线程的代码成成一个匿名函数，交给Dispatcher去执行。F5运行后，您将看到一个进度条从0增长到100。 Calendar日历控件Calendar提供一个日历界面，供用户选择日期，它继承于Control基类。 一、Calendar类的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Calendar : Control&#123; public static readonly RoutedEvent SelectedDatesChangedEvent; public static readonly DependencyProperty SelectionModeProperty; public static readonly DependencyProperty SelectedDateProperty; public static readonly DependencyProperty FirstDayOfWeekProperty; public static readonly DependencyProperty DisplayModeProperty; public static readonly DependencyProperty DisplayDateStartProperty; public static readonly DependencyProperty IsTodayHighlightedProperty; public static readonly DependencyProperty DisplayDateProperty; public static readonly DependencyProperty CalendarItemStyleProperty; public static readonly DependencyProperty CalendarDayButtonStyleProperty; public static readonly DependencyProperty CalendarButtonStyleProperty; public static readonly DependencyProperty DisplayDateEndProperty; public Calendar(); public DateTime? DisplayDateStart &#123; get; set; &#125; public Style CalendarItemStyle &#123; get; set; &#125; public Style CalendarDayButtonStyle &#123; get; set; &#125; public Style CalendarButtonStyle &#123; get; set; &#125; public CalendarBlackoutDatesCollection BlackoutDates &#123; get; &#125; public CalendarMode DisplayMode &#123; get; set; &#125; public DateTime? DisplayDateEnd &#123; get; set; &#125; public bool IsTodayHighlighted &#123; get; set; &#125; public DateTime? SelectedDate &#123; get; set; &#125; public SelectedDatesCollection SelectedDates &#123; get; &#125; public CalendarSelectionMode SelectionMode &#123; get; set; &#125; public DateTime DisplayDate &#123; get; set; &#125; public DayOfWeek FirstDayOfWeek &#123; get; set; &#125; public event EventHandler&lt;SelectionChangedEventArgs&gt; SelectedDatesChanged; public event EventHandler&lt;CalendarDateChangedEventArgs&gt; DisplayDateChanged; public event EventHandler&lt;EventArgs&gt; SelectionModeChanged; public event EventHandler&lt;CalendarModeChangedEventArgs&gt; DisplayModeChanged; public override void OnApplyTemplate(); public override string ToString(); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnDisplayDateChanged(CalendarDateChangedEventArgs e); protected virtual void OnDisplayModeChanged(CalendarModeChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected virtual void OnSelectedDatesChanged(SelectionChangedEventArgs e); protected virtual void OnSelectionModeChanged(EventArgs e); &#125; 二、属性成员 属性名称 说明 DisplayDateStart 获取或设置可在日历中的第一个日期。 CalendarItemStyle 获取或设置CalendarItem的样式 CalendarDayButtonStyle 获取或设置CalendarDayButton的样式 CalendarButtonStyle 获取或设置CalendarButton的样式 BlackoutDates 获取标记为不可选择的日期的集合。 DisplayMode 获取或设置一个值，该值指示是否日历显示月、 年或十年。 DisplayDateEnd 获取或设置可在日历中的日期范围内的最后日期。 IsTodayHighlighted 获取或设置一个值，该值指示是否突出显示当前日期。默认true。 SelectedDate 获取或设置当前选定的日期。[重要] SelectedDates 获取选定日期的集合。 SelectionMode 获取或设置一个值，指示允许包含什么样的选择。如果是多选的号，就可以从SelectedDates属性获取所有已选的日期。 DisplayDate 获取或设置要显示的日期。 FirstDayOfWeek 获取或设置在一天中被视为周的开始。 三、事件成员 事件名称 说明 SelectedDatesChanged 开启多选后，当所选集合的元素数量发生变化时引发 DisplayDateChanged DisplayDate属性被修改后引发 SelectionModeChanged SelectionMode属性（选择模式）发生改变后引发 DisplayModeChanged DisplayMode属性（显示模式）发生改变后引发 四、Calendar示例 前端代码 12345678910111213141516171819&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel HorizontalAlignment=&quot;Center&quot; Margin=&quot;30&quot;&gt; &lt;Calendar x:Name=&quot;_Calendar&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot; Margin=&quot;0,15&quot; DisplayDateStart=&quot;2020/1/1 00:00:00&quot; DisplayDateEnd=&quot;2030/1/1 00:00:00&quot; SelectionMode=&quot;MultipleRange&quot;/&gt; &lt;Button Content=&quot;选择&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 1234567891011121314public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; var list = _Calendar.SelectedDates; var current = _Calendar.SelectedDate; MessageBox.Show($&quot;当前日期数量:&#123;list.Count&#125;,当前日期：&#123;current&#125;&quot;); &#125; &#125; 我们设置了Calendar的DisplayDateStart和DisplayDateEnd属性，这样将日期的可选范围限制在2020年-2030年之间，同时开启了Calendar多项选择，最后在后端去获取所选的日期集合与当前日期。 当前日期是多选时的第一个日期。 在WPF中还有一个选择日期控件——DatePicker，它对当前这个Calendar控件进行了封装，通常DatePicker会更常用一些。下一节，我们来看看DatePicker控件的用法。 DatePicker日期控件DatePicker与Calender在某些属性上很相似，只是为了方便显示和操作，DatePicker将Calender进行了封装。 一、DatePicker定义 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DatePicker : Control&#123; public static readonly RoutedEvent SelectedDateChangedEvent; public static readonly DependencyProperty TextProperty; public static readonly DependencyProperty SelectedDateFormatProperty; public static readonly DependencyProperty IsTodayHighlightedProperty; public static readonly DependencyProperty IsDropDownOpenProperty; public static readonly DependencyProperty SelectedDateProperty; public static readonly DependencyProperty DisplayDateStartProperty; public static readonly DependencyProperty DisplayDateEndProperty; public static readonly DependencyProperty DisplayDateProperty; public static readonly DependencyProperty CalendarStyleProperty; public static readonly DependencyProperty FirstDayOfWeekProperty; public DatePicker(); public CalendarBlackoutDatesCollection BlackoutDates &#123; get; &#125; public DateTime? DisplayDateStart &#123; get; set; &#125; public DateTime? DisplayDateEnd &#123; get; set; &#125; public DateTime DisplayDate &#123; get; set; &#125; public Style CalendarStyle &#123; get; set; &#125; public bool IsTodayHighlighted &#123; get; set; &#125; public bool IsDropDownOpen &#123; get; set; &#125; public DatePickerFormat SelectedDateFormat &#123; get; set; &#125; public string Text &#123; get; set; &#125; public DayOfWeek FirstDayOfWeek &#123; get; set; &#125; public DateTime? SelectedDate &#123; get; set; &#125; protected internal override bool HasEffectiveKeyboardFocus &#123; get; &#125; public event RoutedEventHandler CalendarClosed; public event RoutedEventHandler CalendarOpened; public event EventHandler&lt;SelectionChangedEventArgs&gt; SelectedDateChanged; public event EventHandler&lt;DatePickerDateValidationErrorEventArgs&gt; DateValidationError; public override void OnApplyTemplate(); public override string ToString(); protected virtual void OnCalendarClosed(RoutedEventArgs e); protected virtual void OnCalendarOpened(RoutedEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnDateValidationError(DatePickerDateValidationErrorEventArgs e); protected virtual void OnSelectedDateChanged(SelectionChangedEventArgs e); &#125; 二、属性成员 属性成员 说明 BlackoutDates 获取或设置为不可选择的日期的标记集合。不常用。 DisplayDateStart 获取或设置要显示的第一个日期。 DisplayDateEnd 获取或设置要显示的最后日期。 DisplayDate 获取或设置要显示的日期。 CalendarStyle 获取或设置呈现日历时所使用的样式。 IsTodayHighlighted 获取或设置一个值，该值指示是否将突出显示当前日期。 IsDropDownOpen 获取或设置一个值，该值指示Calendar 下拉列表是打开还是关闭。 SelectedDateFormat 获取或设置用于显示所选的日期的格式。 Text 获取DatePicker显示文本，或设置选定的日期 FirstDayOfWeek 获取或设置在一天中被视为周的开始。 SelectedDate 获取或设置当前选定的日期。 HasEffectiveKeyboardFocus 获取一个值，该值指示DatePicker 是否 具有焦点。 三、事件成员 事件名称 说明 CalendarClosed DatePicker下拉列表关闭时引发此事件 CalendarOpened DatePicker下拉列表打开时引发此事件 SelectedDateChanged SelectedDate属性发生改变时引发此事件 DateValidationError 当Text属性不是日期形式的字符串时引发此事件 接下来，我们以一个例子来说明它的用法 四、DatePicker示例 前端代码 123456789101112131415161718192021&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel HorizontalAlignment=&quot;Center&quot; Margin=&quot;30&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;开始日期&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;10,0&quot;/&gt; &lt;DatePicker x:Name=&quot;_DatePickerStart&quot; VerticalAlignment=&quot;Center&quot; Width=&quot;120&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;结束日期&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;10,0&quot;/&gt; &lt;DatePicker x:Name=&quot;_DatePickerEnd&quot; VerticalAlignment=&quot;Center&quot; Width=&quot;120&quot;/&gt; &lt;/StackPanel&gt; &lt;Button Content=&quot;查询&quot; Click=&quot;Button_Click&quot; Margin=&quot;10,0&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 1234567891011121314public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; var selectedDate = $&quot;查询日期:&#123;_DatePickerStart.SelectedDate&#125; &#123;_DatePickerEnd.SelectedDate&#125;\\r\\n&quot;; var text = $&quot;文本值:&#123;_DatePickerStart.Text&#125; &#123;_DatePickerEnd.Text&#125;&quot;; MessageBox.Show($&quot;&#123;selectedDate&#125; &#123;text&#125;&quot;); &#125; &#125; 需要注意一点的是，DatePicker的SelectedDate属性是一个DateTime?日期型，而Text属性是一个string类型，所以两者的内容是不相等的。看一下运行结果： SelectedDate属性后面会带上时分秒信息。 Expander折叠控件Expander也是一个内容控件，它有一个标题属性和内容属性。我们曾在前面讲解GroupBox时提到过父类HeaderedContentControl（标题内容控件）。所以，感兴趣的小伙伴可以单击其链接前往复习。在这里，我们只关注Expander的基本功能，也就是可折叠。 一、Expander类的定义 123456789101112131415161718192021public class Expander : HeaderedContentControl&#123; public static readonly DependencyProperty ExpandDirectionProperty; public static readonly DependencyProperty IsExpandedProperty; public static readonly RoutedEvent ExpandedEvent; public static readonly RoutedEvent CollapsedEvent; public Expander(); public ExpandDirection ExpandDirection &#123; get; set; &#125; public bool IsExpanded &#123; get; set; &#125; public event RoutedEventHandler Expanded; public event RoutedEventHandler Collapsed; public override void OnApplyTemplate(); protected virtual void OnCollapsed(); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnExpanded(); &#125; Expander自身只提供了两个属性，分别是ExpandDirection和IsExpanded。 ExpandDirection属性定义了Expander的内容在打开时的方向。它是一个枚举值，分别有Down、Up、Left和Right四个方向，默认方向为Down。 IsExpanded属性用来获取或设置内容窗口是否可见。比如在后端代码中，将这个属性赋值true，意味着展开Expander。 它还有两个事件成员，分别是Expanded和Collapsed，也就是其内容在展开和隐藏时触发。 二、Expander示例 前端代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel Margin=&quot;15&quot;&gt; &lt;TextBlock Text=&quot;控件课程&quot;/&gt; &lt;Expander Header=&quot;Button控件&quot; ExpandDirection=&quot;Down&quot; Expanded=&quot;Expander_Expanded&quot; Collapsed=&quot;Expander_Collapsed&quot;&gt; &lt;Grid Background=&quot;#FFE5E5E5&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot;&gt; 表示 Windows 按钮控件，该按钮对 Click 事件做出反应。 Button类 直接从 System.Windows.Controls.Primitives.ButtonBase 类继承。 Button是内容模型ContentControl的子类。ContentControl内容属性为 Content。 在用户单击 Button时做出响应的事件叫ButtonBase.Click 。 &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/Expander&gt; &lt;Expander Header=&quot;TextBox控件&quot; ExpandDirection=&quot;Left&quot;&gt; &lt;Grid Background=&quot;#FFE5E5E5&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot;&gt; TextBox控件是WPF的文本输入控件，使用户输入录入系统数据的入口之一。 有了此控件，用户可以将数据按照软件的流程录入进去。它允许用户输入一行或多行数据。 &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/Expander&gt; &lt;Expander Header=&quot;ListBox控件&quot; ExpandDirection=&quot;Right&quot;&gt; &lt;Grid Background=&quot;#FFE5E5E5&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot;&gt; ListBox控件继承自ContentControl类，是一个容器类的控件， 向ListBox控件中包含ListBoxItem元素向容器中添加成分， 也可以添加其他任意的控件。 &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/Expander&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Expander_Expanded(object sender, RoutedEventArgs e) &#123; MessageBox.Show(&quot;Expander展开&quot;); &#125; private void Expander_Collapsed(object sender, RoutedEventArgs e) &#123; MessageBox.Show(&quot;Expander隐藏&quot;); &#125; &#125; MediaElement媒体播放器MediaElement，一个可以播放音频或视频的控件，继承于FrameworkElement基类。MediaElement包含了常见的音频或视频格式，如果您需要更强大的功能，可以考虑使用VLC库。 官方说明 MediaElement 可以在两种不同的模式下使用，具体取决于驱动控件的内容：独立模式或时钟模式。 在独立模式下使用 时， MediaElement 类似于图像， Source 可以直接指定 URI。 在时钟模式下， MediaElement 可以将 视为动画的目标，因此它将在计时树中具有相应的 Timeline 和 Clock 条目。 一、MediaElement的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MediaElement : FrameworkElement, IUriContext&#123; public static readonly DependencyProperty SourceProperty; public static readonly RoutedEvent ScriptCommandEvent; public static readonly RoutedEvent BufferingEndedEvent; public static readonly RoutedEvent BufferingStartedEvent; public static readonly RoutedEvent MediaOpenedEvent; public static readonly RoutedEvent MediaFailedEvent; public static readonly DependencyProperty StretchDirectionProperty; public static readonly RoutedEvent MediaEndedEvent; public static readonly DependencyProperty LoadedBehaviorProperty; public static readonly DependencyProperty UnloadedBehaviorProperty; public static readonly DependencyProperty ScrubbingEnabledProperty; public static readonly DependencyProperty IsMutedProperty; public static readonly DependencyProperty BalanceProperty; public static readonly DependencyProperty VolumeProperty; public static readonly DependencyProperty StretchProperty; public MediaElement(); public MediaState LoadedBehavior &#123; get; set; &#125; public bool CanPause &#123; get; &#125; public bool IsBuffering &#123; get; &#125; public double DownloadProgress &#123; get; &#125; public double BufferingProgress &#123; get; &#125; public int NaturalVideoHeight &#123; get; &#125; public Duration NaturalDuration &#123; get; &#125; public bool HasAudio &#123; get; &#125; public bool HasVideo &#123; get; &#125; public TimeSpan Position &#123; get; set; &#125; public double SpeedRatio &#123; get; set; &#125; public MediaState UnloadedBehavior &#123; get; set; &#125; public int NaturalVideoWidth &#123; get; &#125; public bool ScrubbingEnabled &#123; get; set; &#125; public MediaClock Clock &#123; get; set; &#125; public double Balance &#123; get; set; &#125; public double Volume &#123; get; set; &#125; public StretchDirection StretchDirection &#123; get; set; &#125; public Stretch Stretch &#123; get; set; &#125; public Uri Source &#123; get; set; &#125; public bool IsMuted &#123; get; set; &#125; public event RoutedEventHandler BufferingEnded; public event RoutedEventHandler BufferingStarted; public event RoutedEventHandler MediaOpened; public event EventHandler&lt;ExceptionRoutedEventArgs&gt; MediaFailed; public event RoutedEventHandler MediaEnded; public event EventHandler&lt;MediaScriptCommandRoutedEventArgs&gt; ScriptCommand; public void Close(); public void Pause(); public void Play(); public void Stop(); protected override Size ArrangeOverride(Size finalSize); protected override Size MeasureOverride(Size availableSize); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnRender(DrawingContext drawingContext); &#125; 二、属性成员 属性名称 说明 LoadedBehavior 获取或设置加载媒体的行为，如果加载希望手动控制播放，请设置为Manual。 CanPause 获取一个值，该值指示是否可以暂停媒体。 IsBuffering 获取一个值，该值指示是否缓冲媒体。 DownloadProgress 获取一个百分比值，该值为位于远程服务器上的内容完成的下载量。 BufferingProgress 获取一个值，该值指示缓冲进度的百分比。0-1之间 NaturalVideoHeight 获取与媒体关联的视频的高度。 NaturalDuration 获取介质的自然持续时间。也就是视频播放总时长。 HasAudio 获取一个值，该值指示媒体是否具有音频。 HasVideo 获取一个值，该值指示媒体是否具有视频。 Position 通过媒体的播放时间获取或设置进度的当前位置。 SpeedRatio 获取或设置媒体的速率。也就是按几倍播放视频。 UnloadedBehavior 获取或设置卸载媒体的行为。 NaturalVideoWidth 获取与媒体关联的视频的宽度。 ScrubbingEnabled 获取或设置一个值，该值指示MediaElement 是否将更新帧的查找操作在暂停状态。 Clock 获取或设置MediaElement 媒体播放相关联的时钟。 Balance 获取或设置扬声器的音量比。 Volume 获取或设置媒体的音量。0-1之间，默认0.5 StretchDirection 获取或设置一个值，确定扩展的限制应用于映像。 Stretch 获取或设置MediaElement媒体的拉伸方式。 Source 获取或设置MediaElement媒体源[重点] IsMuted 是否静音 三、事件成员 事件名称 说明 BufferingEnded 媒体缓冲结束时发生。 BufferingStarted 媒体缓冲开始时发生。 MediaOpened 媒体加载已完成时发生。 MediaFailed 遇到错误时发生。 MediaEnded 媒体结束时发生。 ScriptCommand 在媒体中遇到的脚本命令时发生。 四、MediaElement示例 我们以MediaElement的独立模式为例，开发一个基础版本的视频播放器，该项目将会用到MediaElement、Gird、Border、TextBlock、Button、Slider、ProgressBar等控件，也算是对之前学过的控件章节一次总结和回顾。 前端代码 12345678910111213141516171819202122232425262728293031323334353637&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;400&quot; Width=&quot;550&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid&gt; &lt;MediaElement x:Name=&quot;_MediaElement&quot; LoadedBehavior=&quot;Manual&quot; /&gt; &lt;Border x:Name=&quot;_Border&quot; Background=&quot;Black&quot;&gt; &lt;TextBlock x:Name=&quot;_TextBlock&quot; Text=&quot;MediaElement | 媒体播放器&quot; Foreground=&quot;LightCoral&quot; FontSize=&quot;20&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/Grid&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Grid.Row=&quot;1&quot;&gt; &lt;Button Content=&quot;打开&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;OpenMedia&quot;/&gt; &lt;Button Content=&quot;播放&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;PlayMedia&quot;/&gt; &lt;Button Content=&quot;停止&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;StopMedia&quot;/&gt; &lt;Button Content=&quot;后退&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;BackMedia&quot;/&gt; &lt;Button Content=&quot;前进&quot; Width=&quot;60&quot; Height=&quot;25&quot; Margin=&quot;5&quot; Click=&quot;ForwardMedia&quot;/&gt; &lt;TextBlock Text=&quot;音量&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;5&quot;/&gt; &lt;Slider x:Name=&quot;_Slider&quot; Width=&quot;120&quot; VerticalAlignment=&quot;Center&quot; Maximum=&quot;100&quot; Value=&quot;50&quot; ValueChanged=&quot;_Slider_ValueChanged&quot;/&gt; &lt;/StackPanel&gt; &lt;Grid Grid.Row=&quot;2&quot;&gt; &lt;ProgressBar x:Name=&quot;_ProgressBar&quot; Height=&quot;10&quot; Margin=&quot;5&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283using System;using System.Windows;using System.Windows.Threading; namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; private string file = string.Empty; public MainWindow() &#123; InitializeComponent(); DispatcherTimer timer = new DispatcherTimer(); timer.Interval = TimeSpan.FromMilliseconds(1000); timer.Tick += (s, e) =&gt; &#123; var ts = _MediaElement.Position; _ProgressBar.Value = ts.TotalMilliseconds;//更新当前播放进度 &#125;; timer.Start(); &#125; private void OpenMedia(object sender, RoutedEventArgs e) &#123; var openFileDialog = new Microsoft.Win32.OpenFileDialog() &#123; Filter = &quot;视频文件 (.mp4)|*.mp4&quot;, Multiselect = true &#125;; var result = openFileDialog.ShowDialog(); if (result == true) &#123; file = openFileDialog.FileName; _MediaElement.MediaOpened += _MediaElement_MediaOpened; _MediaElement.Source = new System.Uri(file); this.Title = file; _TextBlock.Text = file; &#125; &#125; private void _MediaElement_MediaOpened(object sender, RoutedEventArgs e) &#123; if (_MediaElement.NaturalDuration.HasTimeSpan) &#123; var ts = _MediaElement.NaturalDuration.TimeSpan; _ProgressBar.Maximum = ts.TotalMilliseconds;//设置播放进度条总长 &#125; &#125; private void PlayMedia(object sender, RoutedEventArgs e) &#123; _MediaElement.Play();//播放 _Border.Visibility = Visibility.Collapsed; &#125; private void StopMedia(object sender, RoutedEventArgs e) &#123; _MediaElement.Pause();//暂停 &#125; private void BackMedia(object sender, RoutedEventArgs e) &#123; _MediaElement.Position = _MediaElement.Position - TimeSpan.FromSeconds(10);//快退10秒 &#125; private void ForwardMedia(object sender, RoutedEventArgs e) &#123; _MediaElement.Position = _MediaElement.Position + TimeSpan.FromSeconds(10);//快进10秒 &#125; private void _Slider_ValueChanged(object sender, RoutedPropertyChangedEventArgs&lt;double&gt; e) &#123; _MediaElement.Volume = _Slider.Value;//设置音量 &#125; &#125;&#125; 如图所示，我们将前面所学的控件知识综合利用起来，设计出一款播放界面。MediaElement控件没有Background属性，所以我们放了一个Border控件（黑色背景）在MediaElement控件的上方，待加载视频并播放时，将Border隐藏起来。 在后端C#语言中，我们在构造函数里通过DispatcherTimer 开启了一个子线程，用以更新当前播放进度。DispatcherTimer是运行在UI线程上的定时器,可以直接更新UI元素，不会引发跨线程调用的异常。 在打开视频业务中，我们采用Microsoft.Win32.OpenFileDialog去获取视频文件地址，然后创建一个Uri实例，最后把这个实例赋值给MediaElement的Source属性。 最后，我们只需要调用MediaElement提供的一系列方法成员，比如Play()、Pause()、或设置播放位置的Position属性。好，关于MediaElement控件就先介绍到这里啦。 集合控件ItemsControl基类一、集合控件概述 很多时候，我们需要显示大量的数据，这些数据虽然众多，但是数据类型结构相同的，由于内容控件只能显示单个元素，要显示或操作多个元素组成的集合，那么，集合控件就派上用场了。WPF中的集合控件种类丰富，有类似表格的DataGrid，有单列表的ListBox，也有介于两者之前的ListView，还有，软件的菜单通常也是一个集合控件，以及软件下方的状态栏，同样也是一个集合控件。 这些集合控件都有一个共同的基类控件，那就是ItemsControl类，下面我们以表格的形式展示一下即将要学习的集合控件。 控件名 说明 ItemsControl 集合控件的基类，本身也是一个可以实例化的控件 ListBox 一个列表集合控件 ListView 表示用于显示数据项列表的控件，它可以有列头标题 DataGrid 表示可自定义的网格中显示数据的控件。 ComboBox 表示带有下拉列表的选择控件，通过单击控件上的箭头可显示或隐藏下拉列表。 TabControl 表示包含多个共享相同的空间在屏幕上的项的控件。 TreeView 用树结构(其中的项可以展开和折叠)中显示分层数据的控件 Menu 表示一个 Windows 菜单控件，该控件可用于按层次组织与命令和事件处理程序关联的元素。 ContextMenu 表示使控件能够公开特定于控件的上下文的功能的弹出菜单。 StatusBar 表示应用程序窗口中的水平栏中显示项和信息的控件。 二、ItemsControl类定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ItemsControl : Control, IAddChild, IGeneratorHost, IContainItemStorage&#123; public static readonly DependencyProperty ItemsSourceProperty; public static readonly DependencyProperty HasItemsProperty; public static readonly DependencyProperty DisplayMemberPathProperty; public static readonly DependencyProperty ItemTemplateProperty; public static readonly DependencyProperty ItemTemplateSelectorProperty; public static readonly DependencyProperty ItemStringFormatProperty; public static readonly DependencyProperty ItemBindingGroupProperty; public static readonly DependencyProperty ItemContainerStyleProperty; public static readonly DependencyProperty ItemContainerStyleSelectorProperty; public static readonly DependencyProperty ItemsPanelProperty; public static readonly DependencyProperty IsGroupingProperty; public static readonly DependencyProperty GroupStyleSelectorProperty; public static readonly DependencyProperty AlternationCountProperty; public static readonly DependencyProperty AlternationIndexProperty; public static readonly DependencyProperty IsTextSearchEnabledProperty; public static readonly DependencyProperty IsTextSearchCaseSensitiveProperty; public ItemsControl(); public int AlternationCount &#123; get; set; &#125; public GroupStyleSelector GroupStyleSelector &#123; get; set; &#125; public ObservableCollection&lt;GroupStyle&gt; GroupStyle &#123; get; &#125; public bool IsGrouping &#123; get; &#125; public ItemsPanelTemplate ItemsPanel &#123; get; set; &#125; public StyleSelector ItemContainerStyleSelector &#123; get; set; &#125; public Style ItemContainerStyle &#123; get; set; &#125; public BindingGroup ItemBindingGroup &#123; get; set; &#125; public string ItemStringFormat &#123; get; set; &#125; public DataTemplateSelector ItemTemplateSelector &#123; get; set; &#125; public DataTemplate ItemTemplate &#123; get; set; &#125; public string DisplayMemberPath &#123; get; set; &#125; public bool HasItems &#123; get; &#125; public ItemContainerGenerator ItemContainerGenerator &#123; get; &#125; public IEnumerable ItemsSource &#123; get; set; &#125; public ItemCollection Items &#123; get; &#125; public bool IsTextSearchCaseSensitive &#123; get; set; &#125; public bool IsTextSearchEnabled &#123; get; set; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public static DependencyObject ContainerFromElement(ItemsControl itemsControl, DependencyObject element); public static int GetAlternationIndex(DependencyObject element); public static ItemsControl GetItemsOwner(DependencyObject element); public static ItemsControl ItemsControlFromItemContainer(DependencyObject container); public override void BeginInit(); public DependencyObject ContainerFromElement(DependencyObject element); public override void EndInit(); public bool IsItemItsOwnContainer(object item); public bool ShouldSerializeGroupStyle(); public bool ShouldSerializeItems(); public override string ToString(); protected virtual void AddChild(object value); protected virtual void AddText(string text); protected virtual void ClearContainerForItemOverride(DependencyObject element, object item); protected virtual DependencyObject GetContainerForItemOverride(); protected virtual bool IsItemItsOwnContainerOverride(object item); protected virtual void OnAlternationCountChanged(int oldAlternationCount, int newAlternationCount); protected virtual void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath); protected virtual void OnGroupStyleSelectorChanged(GroupStyleSelector oldGroupStyleSelector, GroupStyleSelector newGroupStyleSelector); protected virtual void OnItemBindingGroupChanged(BindingGroup oldItemBindingGroup, BindingGroup newItemBindingGroup); protected virtual void OnItemContainerStyleChanged(Style oldItemContainerStyle, Style newItemContainerStyle); protected virtual void OnItemContainerStyleSelectorChanged(StyleSelector oldItemContainerStyleSelector, StyleSelector newItemContainerStyleSelector); protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected virtual void OnItemsPanelChanged(ItemsPanelTemplate oldItemsPanel, ItemsPanelTemplate newItemsPanel); protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue); protected virtual void OnItemStringFormatChanged(string oldItemStringFormat, string newItemStringFormat); protected virtual void OnItemTemplateChanged(DataTemplate oldItemTemplate, DataTemplate newItemTemplate); protected virtual void OnItemTemplateSelectorChanged(DataTemplateSelector oldItemTemplateSelector, DataTemplateSelector newItemTemplateSelector); protected override void OnKeyDown(KeyEventArgs e); protected override void OnTextInput(TextCompositionEventArgs e); protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item); protected virtual bool ShouldApplyItemContainerStyle(DependencyObject container, object item); &#125; 二、ItemsControl类分析 由于我们还没有讲模板、样式、数据绑定等内容，所以关于ItemsControl类的分析，我们先关注一些与模板样式和数据绑定无关的内容，先讲讲ItemsControl最基础的内容。 2.Items属性 ItemsControl类作为集合控件的基类，它提供了一个非常重要的属性，那就是Items属性。这个属性的类型是ItemCollection，也就是一个集合列表，那么这个列表的元素内容是什么呢？ 答案是object。 说明我们可以在集合控件中放任意引用类型的元素。 2.2DisplayMemberPath属性 这个属性用来获取或设置要显示的内容，它通常指某个数据源的某个属性名称，所以它是string类型。 2.3HasItems属性 这个属性用来判断当前集合控件是否有元素。 24.IsTextSearchCaseSensitive属性 这个属性如果为true，则搜索元素时区分大小写。 2.5 IsTextSearchEnabled属性 表示是否启用文字搜索。 好，接下来的几个属性将在后续进行学习，不过，我们先在这里了解一下它们的用途。 2.6 ItemsPanel属性[重要] 由于一个集合控件里面会显示多个数据项（一个数据代表一个家），那么这些数据项怎么排版？是像StackPanel一样水平或垂直排列，还是像WrapPanel瀑布流一样排例？这个ItemsPanel属性来决定。 2.7 ItemTemplate属性[重要] 在集合控件里，数据项有可能是一个复杂的实体，那么这些数据以什么样的UI布局界面呈现？也就是说，数据本身穿什么衣服？ItemTemplate属性就是来决定数据的外观的。如果把每个Item元素看成一个家，那么前面的ItemsPanel属性就是来决定邻里之间的实际距离以及房子和房子的排例走势。 2.8 ItemContainerStyle属性[重要] ItemTemplate属性只能决定数据的外观，相当于这个家的内部装修以及家电家具的样式，而这个家外墙的装饰，则必须由ItemContainerStyle属性来承包。 2.9 ItemContainerStyleSelector属性[重要] 当我们选中这个集合控件中的某一项，并希望突出这一项，那就可以在ItemTemplateSelector属性中进行定义，也就是说，选择了某一项，某一项的外墙装饰发生改变。那同时要改变内部的样式呢？ 2.10 ItemTemplateSelector属性[重要] 如果选中了某一项，并希望它的数据模块被重新定义，以突出这一项被选中，可以设置ItemTemplateSelector属性 2.11 Template属性[重要] 还记得吗？ItemsControl类继承于Control类，而Control类中有一个叫Template的属性，所以ItemsControl类自然也就拥有了这个属性，这是一个什么属性？它是ControlTemplate类，也就是控件模板，所以，如果我们希望把ItemsControl类本身的外观进行重定义，那就需要去设置Template属性 重庆教主友情提示 上面我们一口气讲了这么多的模板概念，虽然看起来是在学习ItemsControl类的属性，但是别忘记了，将来要学习的那些集合子控件全都继承于ItemsControl类，意味着它们也都有这些模板属性可以使用呢，是不是有一种事半功倍的感觉呢！ 接下来，我们来举个例子 三、ItemsControl示例 前端代码 12345678910111213141516171819202122232425262728&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;ItemsControl&gt; &lt;Button Content=&quot;content&quot; Margin=&quot;0,5&quot;/&gt; &lt;Border Height=&quot;30&quot; Background=&quot;LightPink&quot; Margin=&quot;0,5&quot;/&gt; &lt;TextBlock Text=&quot;WPF中文网 www.wpfsoft.com&quot; Background=&quot;LightGray&quot; Margin=&quot;0,5&quot;/&gt; &lt;ItemsControl Height=&quot;35&quot; Background=&quot;AliceBlue&quot;/&gt; &lt;CheckBox Content=&quot;CheckBox元素&quot;/&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;0,5&quot;&gt; &lt;RadioButton Content=&quot;初级&quot;/&gt; &lt;RadioButton Content=&quot;中级&quot;/&gt; &lt;RadioButton Content=&quot;高级&quot;/&gt; &lt;/StackPanel&gt; 这是一串字符串 &lt;Label Content=&quot;这是Label控件&quot; Margin=&quot;0,5&quot;/&gt; &lt;Control Background=&quot;Red&quot; Height=&quot;30&quot;/&gt; &lt;ProgressBar Value=&quot;50&quot; Height=&quot;20&quot; Maximum=&quot;100&quot; /&gt; &lt;/ItemsControl&gt; &lt;/Grid&gt;&lt;/Window&gt; 首先，我们在XMAL中实例化了一个ItemsControl控件，然后在ItemsControl里面实例化了一系列子控件，它们分别是Button、Border、TextBlock、ItemsControl、CheckBox、StackPanel、RadioButton、字符串、Label、Control和ProgressBar。 除了Control没有显示出来，其它全部都呈现在ItemsControl控件之中，因为这些子控件全部都在ItemsControl类的Items集合里面，那么，Control虽然能实例化，为什么没有显示出来呢？就连没有控件的字符串都能显示出来，这里面肯定有原因。 是的，这里我们引出一个知识点，那就是控件模板，因为Control基类虽然有Background属性，但是我们并没有给Control基类的Template属性设置一个控件模板，所以Control能实例化，但是不能显示。只能看到一个高度为30的空白区域。 而Border在设置Background属性后，为什么能显示？因为Border是一个装饰器，它继承于Decorator基类。 为什么单纯的字符串也能显示呢？因为实际上这个字符串外面被包裹了一层ContentPresenter实例，这个字符串是被赋值到了ContentPresenter的Content属性上，而ContentPresenter的ContentTemplate有一个默认模板。 四、总结 ItemsControl集合基类可以显示绝大多数控件，也就意味着，ListBox，ListView，DataGrid，ComboBox，TabControl，TreeView，Menu，ContextMenu，StatusBar这些子控件在显示集合元素时，每一个元素的外观可以呈现出更复杂、更漂亮的UI效果，从而可以设计出更友好的交互界面。 有了这样一个基调，那接下来我们来一一细说各个子控件的基础功能，待学习模板和样式章节后，进一步探索这些子控件的强大功能。另外，ListBox，ListView，DataGrid，ComboBox，TabControl这5个控件又都有一个共同的基类——Selector类，Selector继承于ItemsControl基类。Selector基类又是一个怎样的类？它会给我们提供哪些功能呢？ 下一节，我们先从Selector基类说起。 Selector基类Selector继承于ItemsControl，但它是一个抽象类，所以不能被实例化。从命名上看，它是一个选择器。 一、Selector类定义 123456789101112131415161718192021222324252627282930313233343536373839public abstract class Selector : ItemsControl&#123; public static readonly RoutedEvent SelectionChangedEvent; public static readonly RoutedEvent SelectedEvent; public static readonly RoutedEvent UnselectedEvent; public static readonly DependencyProperty IsSelectionActiveProperty; public static readonly DependencyProperty IsSelectedProperty; public static readonly DependencyProperty IsSynchronizedWithCurrentItemProperty; public static readonly DependencyProperty SelectedIndexProperty; public static readonly DependencyProperty SelectedItemProperty; public static readonly DependencyProperty SelectedValueProperty; public static readonly DependencyProperty SelectedValuePathProperty; protected Selector(); public object SelectedValue &#123; get; set; &#125; public object SelectedItem &#123; get; set; &#125; public int SelectedIndex &#123; get; set; &#125; public bool? IsSynchronizedWithCurrentItem &#123; get; set; &#125; public string SelectedValuePath &#123; get; set; &#125; public event SelectionChangedEventHandler SelectionChanged; public static void AddSelectedHandler(DependencyObject element, RoutedEventHandler handler); public static void AddUnselectedHandler(DependencyObject element, RoutedEventHandler handler); public static bool GetIsSelected(DependencyObject element); public static bool GetIsSelectionActive(DependencyObject element); public static void RemoveSelectedHandler(DependencyObject element, RoutedEventHandler handler); public static void RemoveUnselectedHandler(DependencyObject element, RoutedEventHandler handler); public static void SetIsSelected(DependencyObject element, bool isSelected); protected override void ClearContainerForItemOverride(DependencyObject element, object item); protected override void OnInitialized(EventArgs e); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue); protected virtual void OnSelectionChanged(SelectionChangedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); &#125; 接下来，我们来看看它提供了哪些可用的属性。 二、Selector类的属性 属性名称 说明 SelectedValue 获取或设置SelectedValuePath属性指定的元素的属性值 SelectedItem 获取或设置当前所选内容中的第一项或如果所选内容为空则返回 null SelectedIndex 获取或设置当前所选内容或返回的第一项的索引为负一 (-1) 如果所选内容为空。 SelectedValuePath 获取或设置SelectedItem当前元素的某个属性名，这个元素属性名将决定SelectedValue的值 IsSynchronizedWithCurrentItem 是否同步当前项。 SelectedItem和SelectedValue有点类似，都是object类型。但是，他们俩不一定指同一个内容。比如，我们将有这样一个数据实体类。 123456public class Person&#123; public string Name &#123; get; set; &#125; public string Address &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125; 然后我们实例化多个Person组成一个集合绑定到Items属性中，这个时候选中某一个元素，SelectedItem便等于这个Person元素，但是SelectedValue是什么，要看SelectedValuePath的值，如果SelectedValuePath的值指向的是Person.Name，那么SelectedValue就是一个字符串，如果SelectedValuePath指向的是Person的Age ，那么SelectedValue就是一个int整数，**只有*不设置*SelectedValuePath时，SelectedValue和SelectedItem两者才相等，即Person实例。 具体关于这一个重点，我们在下一节讨论ListBox控件时进行演示和讲解。 ListBox列表控件ListBox是一个列表控件，用于显示条目类的数据，默认每行只能显示一个内容项，当然，我们可以通过修改它的数据模板，来自定义每一行（元素）的数据外观，达到显示更多数据的目的。 一、ListBox的定义 1234567891011121314151617181920212223242526public class ListBox : Selector&#123; public static readonly DependencyProperty SelectionModeProperty; public static readonly DependencyProperty SelectedItemsProperty; public ListBox(); public IList SelectedItems &#123; get; &#125; public SelectionMode SelectionMode &#123; get; set; &#125; protected object AnchorItem &#123; get; set; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public void ScrollIntoView(object item); public void SelectAll(); public void UnselectAll(); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected override void OnSelectionChanged(SelectionChangedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); protected bool SetSelectedItems(IEnumerable selectedItems); &#125; 二、属性分析 ListBox自身的属性比较少，SelectionMode 属性比较重要，它可以决定当前的ListBox控件是单选还是多选，它的值为Extended时，表示用户需要按下shift键才能多选。如果SelectionMode为多选状态，那么多选的结果保存在哪去了？ 答案是SelectedItems 属性。 另外，ListBox还自带了滚动条，如果内容超出显示区域，这时滚动条便起作用。 我们在上一章节提过DisplayMemberPath、SelectedValuePath、SelectedItem和SelectedValue，那么，我们以一个实际的例子来说明这几个属性的用途。 三、ListBox示例 前端代码 1234567891011121314151617&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel&gt; &lt;ListBox x:Name=&quot;listbox&quot; MinHeight=&quot;100&quot; DisplayMemberPath=&quot;Name&quot; SelectedValuePath=&quot;Age&quot;/&gt; &lt;Button Content=&quot;查看结果&quot; Click=&quot;Button_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlock&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后端代码 12345678910111213141516171819202122232425262728293031323334353637using System;using System.Windows;using System.Windows.Controls;using System.Windows.Threading; namespace HelloWorld&#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Address &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); listbox.Items.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;); listbox.Items.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;); listbox.Items.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; var selectedItem = listbox.SelectedItem; var selectedValue = listbox.SelectedValue; _TextBlock.Text = $&quot;&#123;selectedItem&#125;,&#123;selectedValue&#125;&quot;; &#125; &#125;&#125; 代码分析 在前端代码中，我们设置了DisplayMemberPath属性值为“Name”，而SelectedValuePath属性值为“Age”，这两个值实际上是Person类的两个属性，F5启动调试后，我们可以在界面上看到张三、李四和王五的名字，但是看不到他们的年龄和地址，这是因为ListBox默认每行只能显示一个内容项，而且这里我们设置了DisplayMemberPath属性，只能显示名字。 我们选中ListBox中的李四，然后单点查看结果按钮，SelectedItem属性得到了一个Person类，所以输出的值为HelloWorld.Person，而SelectedValue属性得到了李四的年龄，所以输出的结果是23。 重庆教主说 如果把SelectionMode属性设为多选Multiple或Extended，试试看，会发生什么效果呢？ Items属性是一个只读属性，所以我们只能能过Items的Add方法向集合增加元素。 四、ListBoxItem子项 其实，ListBox还有它专门配合业务开发的子项控件——ListBoxItem。ListBoxItem继承于ContentControl内容控件，仔细想，这意味着什么？还记得我们在分享ContentControl提过”它有一个叫Content属性“一嘴吗？Content属性可以容纳任意引用类型，也就是说，ListBoxItem也可以容纳任意引用类型，也就是说，ListBox的子项也可以容纳任意的引用类型。 这么一说，感觉ListBoxr还蛮强大的呢！ 所以，ListBoxItem可以这样使用 123456789101112131415161718192021222324252627282930313233&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;StackPanel&gt; &lt;ListBox x:Name=&quot;listbox&quot;&gt; &lt;ListBoxItem&gt; &lt;Button Content=&quot;这是一个按钮&quot;/&gt; &lt;/ListBoxItem&gt; &lt;ListBoxItem&gt; &lt;Border Height=&quot;30&quot; Background=&quot;Red&quot;/&gt; &lt;/ListBoxItem&gt; &lt;ListBoxItem Content=&quot;这是一个字符串&quot;/&gt; &lt;ListBoxItem&gt; &lt;ProgressBar Maximum=&quot;100&quot; Value=&quot;50&quot; Height=&quot;25&quot; Width=&quot;450&quot;/&gt; &lt;/ListBoxItem&gt; 这里直接写字符串 &lt;ListBoxItem&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;CheckBox Content=&quot;复选框&quot;/&gt; &lt;RadioButton Content=&quot;单选框 &quot;/&gt; &lt;/StackPanel&gt; &lt;/ListBoxItem&gt; &lt;/ListBox&gt; &lt;Button Content=&quot;查看结果&quot; Click=&quot;Button_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;textblock&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 后台代码 123456789101112131415161718192021public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; try &#123; var selectedItem = listbox.SelectedItem; var content = ((ContentControl)selectedItem).Content; textblock.Text = $&quot;selectedItem=&#123;selectedItem&#125;\\r\\ncontent=&#123;content&#125;&quot;; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; &#125; &#125; 如上所示，我们在ListBoxj控件里面实例化了好几个ListBoxItem，但是每个ListBoxItem的Content属性都不一样，有Button，Border ，ProgressBar ，字符串，最后，我们来获取这些选中项的内容。 除了直接写的字符串不能转换之外，其它项的结果，SelectedItem属性总是ListBoxItem，而Content可以是我们设置的其它控制。 要全面了解ListBoxItem，不能不看看它的定义。 1234567891011121314151617181920212223public class ListBoxItem : ContentControl&#123; public static readonly DependencyProperty IsSelectedProperty; public static readonly RoutedEvent SelectedEvent; public static readonly RoutedEvent UnselectedEvent; public ListBoxItem(); public bool IsSelected &#123; get; set; &#125; public event RoutedEventHandler Selected; public event RoutedEventHandler Unselected; protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnMouseEnter(MouseEventArgs e); protected override void OnMouseLeave(MouseEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseRightButtonDown(MouseButtonEventArgs e); protected virtual void OnSelected(RoutedEventArgs e); protected virtual void OnUnselected(RoutedEventArgs e); protected internal override void OnVisualParentChanged(DependencyObject oldParent); &#125; 如上所示，可以看到ListBoxItem有一个叫IsSelected属性，表示该项是否被选中，同时，它还有两个事件，分别是Selected选中和Unselected未选中，我们可以去订阅这两个事件，以此来做一些业务。 关于ListBox以及ListBoxItem，我们就先介绍这么多，实际上它的用法远不止这些，如果加上模板、样式、数据绑定、触发器，它还可以实现许多意想不到的效果。关于这部分的内容，请参阅模板样式章节关于ListBox控件的用法。 所以，ListBox列表控件默认情况下，只能显示一个数据项，那如果我想把Person类的Name、Age、Address三个属性值都显示出来呢？有办法——ListView控件可以做到。 ListView数据列表控件ListView继承于ListBox，在ListBox控件的基础上增加了数据视图。从而让我们可以很轻松的设置每一列的标题，以显示某个数据表结构及内容。 一、ListView定义 12345678910111213141516public class ListView : ListBox&#123; public static readonly DependencyProperty ViewProperty; public ListView(); public ViewBase View &#123; get; set; &#125; protected override void ClearContainerForItemOverride(DependencyObject element, object item); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); &#125; ListView类增加了一个叫View的属性，这个属性用来定义控件的数据样式，决定数据怎样显示。View属性的类型是ViewBase，但是，我们真正在使用View属性时，实际上实例化的是GridView类，因为GridView类是ViewBase的子类。所以，我们要看了解一下GridView的定义。 1234567891011121314151617181920212223242526272829303132333435363738public class GridView : ViewBase, IAddChild&#123; public static readonly DependencyProperty ColumnCollectionProperty; public static readonly DependencyProperty ColumnHeaderContainerStyleProperty; public static readonly DependencyProperty ColumnHeaderTemplateProperty; public static readonly DependencyProperty ColumnHeaderTemplateSelectorProperty; public static readonly DependencyProperty ColumnHeaderStringFormatProperty; public static readonly DependencyProperty AllowsColumnReorderProperty; public static readonly DependencyProperty ColumnHeaderContextMenuProperty; public static readonly DependencyProperty ColumnHeaderToolTipProperty; public GridView(); public static ResourceKey GridViewItemContainerStyleKey &#123; get; &#125; public static ResourceKey GridViewStyleKey &#123; get; &#125; public static ResourceKey GridViewScrollViewerStyleKey &#123; get; &#125; public string ColumnHeaderStringFormat &#123; get; set; &#125; public DataTemplateSelector ColumnHeaderTemplateSelector &#123; get; set; &#125; public DataTemplate ColumnHeaderTemplate &#123; get; set; &#125; public Style ColumnHeaderContainerStyle &#123; get; set; &#125; public GridViewColumnCollection Columns &#123; get; &#125; public object ColumnHeaderToolTip &#123; get; set; &#125; public bool AllowsColumnReorder &#123; get; set; &#125; public ContextMenu ColumnHeaderContextMenu &#123; get; set; &#125; protected internal override object ItemContainerDefaultStyleKey &#123; get; &#125; protected internal override object DefaultStyleKey &#123; get; &#125; public static GridViewColumnCollection GetColumnCollection(DependencyObject element); public static void SetColumnCollection(DependencyObject element, GridViewColumnCollection collection); public static bool ShouldSerializeColumnCollection(DependencyObject obj); public override string ToString(); protected virtual void AddChild(object column); protected virtual void AddText(string text); protected internal override void ClearItem(ListViewItem item); protected internal override IViewAutomationPeer GetAutomationPeer(ListView parent); protected internal override void PrepareItem(ListViewItem item); &#125; GridView提供了一些可供设置的模板和样式属性，这些我们先放一边，在WPF基础章节的内容学习中，我们先学习它的Columns 属性，它是一个集合属性，而集合中元素的类型是GridViewColumn。 GridViewColumn最关键的只有两个属性，分别是标题和要显示的成员（指向了Person实体的某个属性名）。 好了，我们以上一节中的Person实体为例。 二、ListView示例 前端代码 123456789101112131415161718192021222324252627282930313233343536373839&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition Width=&quot;200&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;ListView Grid.Column=&quot;0&quot; x:Name=&quot;listview&quot; SelectionChanged=&quot;listview_SelectionChanged&quot;&gt; &lt;ListView.View&gt; &lt;GridView&gt; &lt;GridViewColumn Header=&quot;姓名&quot; DisplayMemberBinding=&quot;&#123;Binding Name&#125;&quot;/&gt; &lt;GridViewColumn Header=&quot;年龄&quot; DisplayMemberBinding=&quot;&#123;Binding Age&#125;&quot;/&gt; &lt;GridViewColumn Header=&quot;地址&quot; DisplayMemberBinding=&quot;&#123;Binding Address&#125;&quot;/&gt; &lt;/GridView&gt; &lt;/ListView.View&gt; &lt;/ListView&gt; &lt;StackPanel Grid.Column=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;姓名:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockName&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;年龄:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAge&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;地址:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAddress&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 12345678910111213141516171819202122232425262728293031323334353637namespace HelloWorld&#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Address &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); listview.Items.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;); listview.Items.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;); listview.Items.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); &#125; private void listview_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; ListView listView = sender as ListView; if (listView == null) return; var person = listView.SelectedItem as Person; if (person == null) return; _TextBlockName.Text = person.Name; _TextBlockAge.Text = person.Age + &quot;岁&quot;; _TextBlockAddress.Text = person.Address; &#125; &#125;&#125; 三、代码分析 首先，我们在前端实例化了一个ListView控件，并为View属性实例化了一个GridView对象（注意xaml语法的写法）,最后为GridView对象实例化了3列GridViewColumn ，分别设置为姓名年龄和地址，特别需要注意的是DisplayMemberBinding属性的写法，这里采用了数据绑定的写法，意思是将ListView控件的数据源的Name属性显示在姓名那一列，Age属性显示在年龄那一列，Address属性显示在地址那一列（我们明确知道ListView数据源的类型就是Person的实例集合）。 事件处理 在ListView控件的SelectionChanged事件中，我们先将sender转成ListView ，再从中获取当前选中项（即person），最后显示详细信息在界面上即可。这样就演示了数据怎么加载显示到ListView，又怎么样从ListView上获取的过程。 而类似于ListView的效果效果，还有一个专门用来显示数据的控件，它叫DataGrid，从某种意义上来说，它甚至可以开发类似Excel表格的效果。不过，我们在下一节，还是以学习它的基础功能先。 DataGrid数据表格控件DataGrid是一个可以多选的数据表格控件。所以，它继承一个支持多选的父类——MultiSelector。 1234567891011121314public abstract class MultiSelector : Selector&#123; protected MultiSelector(); public IList SelectedItems &#123; get; &#125; protected bool CanSelectMultipleItems &#123; get; set; &#125; protected bool IsUpdatingSelectedItems &#123; get; &#125; public void SelectAll(); public void UnselectAll(); protected void BeginUpdateSelectedItems(); protected void EndUpdateSelectedItems(); &#125; 从上面的定义来看，DataGrid多选的结果会保存在SelectedItems 只读属性中，CanSelectMultipleItems 属性用来设置是否开启多选。好，然后我们来看看DataGrid控件的定义，虽然它的属性众多，在学习模板样式之后，我们还会进一步学习这个控件的用法。 一、DataGrid定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208public class DataGrid : MultiSelector&#123; public static readonly DependencyProperty CanUserResizeColumnsProperty; public static readonly DependencyProperty CurrentItemProperty; public static readonly DependencyProperty CurrentColumnProperty; public static readonly DependencyProperty CurrentCellProperty; public static readonly DependencyProperty CanUserAddRowsProperty; public static readonly DependencyProperty CanUserDeleteRowsProperty; public static readonly DependencyProperty RowDetailsVisibilityModeProperty; public static readonly DependencyProperty AreRowDetailsFrozenProperty; public static readonly DependencyProperty RowDetailsTemplateProperty; public static readonly DependencyProperty RowDetailsTemplateSelectorProperty; public static readonly DependencyProperty CanUserResizeRowsProperty; public static readonly DependencyProperty NewItemMarginProperty; public static readonly DependencyProperty SelectionModeProperty; public static readonly DependencyProperty SelectionUnitProperty; public static readonly DependencyProperty CanUserSortColumnsProperty; public static readonly DependencyProperty AutoGenerateColumnsProperty; public static readonly DependencyProperty FrozenColumnCountProperty; public static readonly DependencyProperty NonFrozenColumnsViewportHorizontalOffsetProperty; public static readonly DependencyProperty EnableColumnVirtualizationProperty; public static readonly DependencyProperty CanUserReorderColumnsProperty; public static readonly DependencyProperty DragIndicatorStyleProperty; public static readonly DependencyProperty DropLocationIndicatorStyleProperty; public static readonly DependencyProperty ClipboardCopyModeProperty; public static readonly DependencyProperty CellsPanelHorizontalOffsetProperty; public static readonly DependencyProperty IsReadOnlyProperty; public static readonly RoutedCommand CancelEditCommand; public static readonly DependencyProperty EnableRowVirtualizationProperty; public static readonly RoutedCommand BeginEditCommand; public static readonly RoutedCommand CommitEditCommand; public static readonly DependencyProperty ColumnWidthProperty; public static readonly DependencyProperty MinColumnWidthProperty; public static readonly DependencyProperty MaxColumnWidthProperty; public static readonly DependencyProperty HorizontalGridLinesBrushProperty; public static readonly DependencyProperty VerticalGridLinesBrushProperty; public static readonly DependencyProperty RowStyleProperty; public static readonly DependencyProperty RowValidationErrorTemplateProperty; public static readonly DependencyProperty RowStyleSelectorProperty; public static readonly DependencyProperty RowBackgroundProperty; public static readonly DependencyProperty AlternatingRowBackgroundProperty; public static readonly DependencyProperty RowHeightProperty; public static readonly DependencyProperty GridLinesVisibilityProperty; public static readonly DependencyProperty RowHeaderWidthProperty; public static readonly DependencyProperty VerticalScrollBarVisibilityProperty; public static readonly DependencyProperty MinRowHeightProperty; public static readonly DependencyProperty HorizontalScrollBarVisibilityProperty; public static readonly DependencyProperty RowHeaderTemplateProperty; public static readonly DependencyProperty RowHeaderStyleProperty; public static readonly DependencyProperty RowHeaderTemplateSelectorProperty; public static readonly DependencyProperty CellStyleProperty; public static readonly DependencyProperty HeadersVisibilityProperty; public static readonly DependencyProperty ColumnHeaderHeightProperty; public static readonly DependencyProperty RowHeaderActualWidthProperty; public static readonly DependencyProperty ColumnHeaderStyleProperty; public DataGrid(); public static ComponentResourceKey FocusBorderBrushKey &#123; get; &#125; public static RoutedUICommand SelectAllCommand &#123; get; &#125; public static IValueConverter HeadersVisibilityConverter &#123; get; &#125; public static IValueConverter RowDetailsScrollingConverter &#123; get; &#125; public static RoutedUICommand DeleteCommand &#123; get; &#125; public DataTemplate RowHeaderTemplate &#123; get; set; &#125; public DataTemplateSelector RowHeaderTemplateSelector &#123; get; set; &#125; public ScrollBarVisibility VerticalScrollBarVisibility &#123; get; set; &#125; public ScrollBarVisibility HorizontalScrollBarVisibility &#123; get; set; &#125; public bool CanUserAddRows &#123; get; set; &#125; public object CurrentItem &#123; get; set; &#125; public DataGridColumn CurrentColumn &#123; get; set; &#125; public DataGridCellInfo CurrentCell &#123; get; set; &#125; public bool CanUserDeleteRows &#123; get; set; &#125; public Style RowHeaderStyle &#123; get; set; &#125; public DataGridRowDetailsVisibilityMode RowDetailsVisibilityMode &#123; get; set; &#125; public bool IsReadOnly &#123; get; set; &#125; public Style ColumnHeaderStyle &#123; get; set; &#125; public Style RowStyle &#123; get; set; &#125; public DataGridHeadersVisibility HeadersVisibility &#123; get; set; &#125; public bool AreRowDetailsFrozen &#123; get; set; &#125; public Brush AlternatingRowBackground &#123; get; set; &#125; public Brush RowBackground &#123; get; set; &#125; public StyleSelector RowStyleSelector &#123; get; set; &#125; public ObservableCollection&lt;ValidationRule&gt; RowValidationRules &#123; get; &#125; public ControlTemplate RowValidationErrorTemplate &#123; get; set; &#125; public Brush VerticalGridLinesBrush &#123; get; set; &#125; public Brush HorizontalGridLinesBrush &#123; get; set; &#125; public DataGridGridLinesVisibility GridLinesVisibility &#123; get; set; &#125; public double MaxColumnWidth &#123; get; set; &#125; public double MinColumnWidth &#123; get; set; &#125; public DataGridLength ColumnWidth &#123; get; set; &#125; public bool CanUserResizeColumns &#123; get; set; &#125; public ObservableCollection&lt;DataGridColumn&gt; Columns &#123; get; &#125; public double RowHeaderWidth &#123; get; set; &#125; public double RowHeaderActualWidth &#123; get; &#125; public double ColumnHeaderHeight &#123; get; set; &#125; public Style CellStyle &#123; get; set; &#125; public DataTemplate RowDetailsTemplate &#123; get; set; &#125; public double MinRowHeight &#123; get; set; &#125; public bool CanUserResizeRows &#123; get; set; &#125; public double RowHeight &#123; get; set; &#125; public DataTemplateSelector RowDetailsTemplateSelector &#123; get; set; &#125; public double CellsPanelHorizontalOffset &#123; get; &#125; public DataGridClipboardCopyMode ClipboardCopyMode &#123; get; set; &#125; public Style DropLocationIndicatorStyle &#123; get; set; &#125; public bool CanUserReorderColumns &#123; get; set; &#125; public bool EnableColumnVirtualization &#123; get; set; &#125; public bool EnableRowVirtualization &#123; get; set; &#125; public Style DragIndicatorStyle &#123; get; set; &#125; public double NonFrozenColumnsViewportHorizontalOffset &#123; get; &#125; public int FrozenColumnCount &#123; get; set; &#125; public bool AutoGenerateColumns &#123; get; set; &#125; public Thickness NewItemMargin &#123; get; &#125; public bool CanUserSortColumns &#123; get; set; &#125; public DataGridSelectionUnit SelectionUnit &#123; get; set; &#125; public DataGridSelectionMode SelectionMode &#123; get; set; &#125; public IList&lt;DataGridCellInfo&gt; SelectedCells &#123; get; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public event DataGridSortingEventHandler Sorting; public event EventHandler AutoGeneratedColumns; public event EventHandler&lt;DataGridAutoGeneratingColumnEventArgs&gt; AutoGeneratingColumn; public event EventHandler&lt;DragDeltaEventArgs&gt; ColumnHeaderDragDelta; public event EventHandler&lt;DragStartedEventArgs&gt; ColumnHeaderDragStarted; public event EventHandler&lt;DragCompletedEventArgs&gt; ColumnHeaderDragCompleted; public event SelectedCellsChangedEventHandler SelectedCellsChanged; public event EventHandler&lt;DataGridColumnReorderingEventArgs&gt; ColumnReordering; public event EventHandler&lt;DataGridRowDetailsEventArgs&gt; RowDetailsVisibilityChanged; public event EventHandler&lt;DataGridRowEventArgs&gt; UnloadingRow; public event EventHandler&lt;DataGridRowDetailsEventArgs&gt; LoadingRowDetails; public event InitializingNewItemEventHandler InitializingNewItem; public event EventHandler&lt;DataGridPreparingCellForEditEventArgs&gt; PreparingCellForEdit; public event EventHandler&lt;DataGridBeginningEditEventArgs&gt; BeginningEdit; public event EventHandler&lt;EventArgs&gt; CurrentCellChanged; public event EventHandler&lt;DataGridCellEditEndingEventArgs&gt; CellEditEnding; public event EventHandler&lt;DataGridRowEditEndingEventArgs&gt; RowEditEnding; public event EventHandler&lt;DataGridRowEventArgs&gt; LoadingRow; public event EventHandler&lt;DataGridColumnEventArgs&gt; ColumnDisplayIndexChanged; public event EventHandler&lt;DataGridRowDetailsEventArgs&gt; UnloadingRowDetails; public event EventHandler&lt;AddingNewItemEventArgs&gt; AddingNewItem; public event EventHandler&lt;DataGridRowClipboardEventArgs&gt; CopyingRowClipboardContent; public event EventHandler&lt;DataGridColumnEventArgs&gt; ColumnReordered; public static Collection&lt;DataGridColumn&gt; GenerateColumns(IItemProperties itemProperties); public bool BeginEdit(); public bool BeginEdit(RoutedEventArgs editingEventArgs); public bool CancelEdit(); public bool CancelEdit(DataGridEditingUnit editingUnit); public void ClearDetailsVisibilityForItem(object item); public DataGridColumn ColumnFromDisplayIndex(int displayIndex); public bool CommitEdit(); public bool CommitEdit(DataGridEditingUnit editingUnit, bool exitEditingMode); public Visibility GetDetailsVisibilityForItem(object item); public override void OnApplyTemplate(); public void ScrollIntoView(object item); public void ScrollIntoView(object item, DataGridColumn column); public void SelectAllCells(); public void SetDetailsVisibilityForItem(object item, Visibility detailsVisibility); public void UnselectAllCells(); protected override void ClearContainerForItemOverride(DependencyObject element, object item); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override Size MeasureOverride(Size availableSize); protected virtual void OnAddingNewItem(AddingNewItemEventArgs e); protected virtual void OnAutoGeneratedColumns(EventArgs e); protected virtual void OnAutoGeneratingColumn(DataGridAutoGeneratingColumnEventArgs e); protected virtual void OnBeginningEdit(DataGridBeginningEditEventArgs e); protected virtual void OnCanExecuteBeginEdit(CanExecuteRoutedEventArgs e); protected virtual void OnCanExecuteCancelEdit(CanExecuteRoutedEventArgs e); protected virtual void OnCanExecuteCommitEdit(CanExecuteRoutedEventArgs e); protected virtual void OnCanExecuteCopy(CanExecuteRoutedEventArgs args); protected virtual void OnCanExecuteDelete(CanExecuteRoutedEventArgs e); protected virtual void OnCellEditEnding(DataGridCellEditEndingEventArgs e); protected override void OnContextMenuOpening(ContextMenuEventArgs e); protected virtual void OnCopyingRowClipboardContent(DataGridRowClipboardEventArgs args); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnCurrentCellChanged(EventArgs e); protected virtual void OnExecutedBeginEdit(ExecutedRoutedEventArgs e); protected virtual void OnExecutedCancelEdit(ExecutedRoutedEventArgs e); protected virtual void OnExecutedCommitEdit(ExecutedRoutedEventArgs e); protected virtual void OnExecutedCopy(ExecutedRoutedEventArgs args); protected virtual void OnExecutedDelete(ExecutedRoutedEventArgs e); protected virtual void OnInitializingNewItem(InitializingNewItemEventArgs e); protected override void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue); protected override void OnKeyDown(KeyEventArgs e); protected virtual void OnLoadingRow(DataGridRowEventArgs e); protected virtual void OnLoadingRowDetails(DataGridRowDetailsEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected virtual void OnRowEditEnding(DataGridRowEditEndingEventArgs e); protected virtual void OnSelectedCellsChanged(SelectedCellsChangedEventArgs e); protected override void OnSelectionChanged(SelectionChangedEventArgs e); protected virtual void OnSorting(DataGridSortingEventArgs eventArgs); protected override void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate); protected override void OnTextInput(TextCompositionEventArgs e); protected virtual void OnUnloadingRow(DataGridRowEventArgs e); protected virtual void OnUnloadingRowDetails(DataGridRowDetailsEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); protected internal virtual void OnColumnDisplayIndexChanged(DataGridColumnEventArgs e); protected internal virtual void OnColumnHeaderDragCompleted(DragCompletedEventArgs e); protected internal virtual void OnColumnHeaderDragDelta(DragDeltaEventArgs e); protected internal virtual void OnColumnHeaderDragStarted(DragStartedEventArgs e); protected internal virtual void OnColumnReordered(DataGridColumnEventArgs e); protected internal virtual void OnColumnReordering(DataGridColumnReorderingEventArgs e); protected internal virtual void OnPreparingCellForEdit(DataGridPreparingCellForEditEventArgs e); protected internal virtual void OnRowDetailsVisibilityChanged(DataGridRowDetailsEventArgs e); &#125; 二、属性分析 DataGrid提供了大量的依赖属性，合理充分利用这些属性，在开发ERP、CMS、报表等软件时可达到事半功倍的效果。下面我们以表格的形式，先了解一下各属性的功能，然后在本节中学习一些基础属性，以掌握该控件的基本用法，剩下的属性放到模板样式的章节中学习。 属性名称 说明 备注 FocusBorderBrushKey 获取引用焦点的单元格的默认边框画笔的键。 SelectAllCommand 表示指示想要选择的所有单元格的命令 HeadersVisibilityConverter 获取标题显示隐藏的转换器，即HeadersVisibility属性的转换器 RowDetailsScrollingConverter 获取将转换为一个布尔值转换器 DeleteCommand 表示指示想要删除当前行的命令。 RowHeaderTemplate 获取或设置行标题的模板。 重要 RowHeaderTemplateSelector 获取或设置行标题的模板选择器。 VerticalScrollBarVisibility 是否显示垂直滚动条 HorizontalScrollBarVisibility 是否显示水平滚动条 CanUserAddRows 是否可以添加新行 重要 CurrentItem 当前选中行（一般指绑定的数据源的某一个元素） 常用 CurrentColumn 获取或设置包含当前单元格的列。 CurrentCell 获取或设置具有焦点的单元格。 CanUserDeleteRows 是否可以删除行 重要 RowHeaderStyle 获取或设置应用于所有行标题的样式。 重要 RowDetailsVisibilityMode 获取或设置一个值，该值指示何时显示某行的详细信息部分。 IsReadOnly 当前控件是否只读 常用 ColumnHeaderStyle 获取或设置所有列标题的样式 重要 RowStyle 获取或设置应用到的所有行的样式。 重要 HeadersVisibility 获取或设置用于指定行和列标题的可见性的值。 AreRowDetailsFrozen 获取或设置一个值，该值指示是否可水平滚动行详细信息。 AlternatingRowBackground 获取或设置交替行上使用的背景画笔。 重要 RowBackground 获取或设置用于行背景的默认画笔。 RowStyleSelector 获取或设置行的样式选择器。 RowValidationRules 获取用于验证每个行中的数据的规则。 RowValidationErrorTemplate 获取或设置用于以可视方式指示行验证中的错误的模板。 VerticalGridLinesBrush 获取或设置用于绘制垂直网格线的画笔。 常用 HorizontalGridLinesBrush 获取或设置用于绘制水平网格线的画笔。 GridLinesVisibility 获取或设置一个值，该值指示显示哪些网格线。 MaxColumnWidth 获取或设置列和标头中的最大宽度约束 MinColumnWidth 获取或设置列和标头中的最小宽度约束 ColumnWidth 获取或设置标准宽度和列和中的标头的大小调整模式 CanUserResizeColumns 获取或设置用户是否可以通过使用鼠标调整列的宽度。 Columns 获取一个集合中的所有列 常用 RowHeaderWidth 获取或设置行标题列的宽度。 RowHeaderActualWidth 获取呈现的行标题列的宽度。 ColumnHeaderHeight 获取或设置列标题行的高度。 CellStyle 获取或设置所有单元格的样式 常用 RowDetailsTemplate 获取或设置用于显示行详细信息的模板。 MinRowHeight 获取或设置行和中的标头的最小高度约束 CanUserResizeRows 获取或设置用户是否可以通过使用鼠标调整行的高度。 RowHeight 获取或设置的所有行的建议的高度。 RowDetailsTemplateSelector 获取或设置用于行详细信息的模板选择器。 CellsPanelHorizontalOffset 获取DataGridCellsPanel的水平偏移量 ClipboardCopyMode 获取或设置一个值，指示如何将内容复制到剪贴板。 NonFrozenColumns ViewportHorizontalOffset 获取在视区的可滚动列的水平偏移量。 FrozenColumnCount 获取或设置非滚动列的数量。 常用 AutoGenerateColumns 获取或设置一个值，该值指示是否自动创建列。 常用 NewItemMargin 获取或设置新的项目行的边距。 CanUserSortColumns 是否可以单击列标题来对列排序。 常用 SelectionUnit 选择行的模式 SelectionMode 是否支持多选 重要 SelectedCells 获取当前选定的单元格的列表。 HandlesScrolling 是否支持自定义键盘滚动。 在上述表格中，Columns属性是DataGrid最基本的一个属性。它是一个ObservableCollection类型的集合，表示DataGrid的列的集合。其实DataGridColumn只是一个抽象基类，我们真正在实例化时，是实例化DataGridColumn的子类，然后放到Columns属性中。 那么DataGridColumn有哪些子类呢？ DataGridTextColumn 表示文本内容的列 DataGridCheckBoxColumn 表示复选框的列 DataGridComboBoxColumn 表示下拉框的列 DataGridTemplateColumn 表示模板的列（万金油） 在本列中，我们将以最简单的DataGridTextColumn 为例。 三、事件成员 DataGrid一共有23个事件成员，它们分别如下所示 事件名称 说明 Sorting 对列进行排序时发生。 AutoGeneratedColumns 所有列的自动生成完成后发生。 AutoGeneratingColumn 自动生成单独的列时出现。 ColumnHeaderDragDelta 每次鼠标位置发生更改时在用户拖动列标题时发生。 ColumnHeaderDragStarted 当用户开始使用鼠标拖动列标题时发生。 ColumnHeaderDragCompleted 当用户使用鼠标拖动后释放列标题时发生。 SelectedCellsChanged 发生时 DataGrid.SelectedCells 集合更改。 ColumnReordering 在列移至的显示顺序中的新位置之前发生。 RowDetailsVisibilityChanged 当某一行的可见性详细信息元素更改时发生。 UnloadingRow 发生时 DataGridRow 对象将成为可供重用。 LoadingRowDetails 新的行的详细信息模板应用于行时发生。 InitializingNewItem 创建一个新项时出现。 PreparingCellForEdit 在单元格进入编辑模式时发生。 BeginningEdit 发生行或单元格进入编辑模式之前。 CurrentCellChanged 在 DataGrid.CurrentCell 属性的值更改后发生。 CellEditEnding 在单元格的编辑将在提交或取消前发生。 RowEditEnding 在提交或取消行编辑之前发生。 LoadingRow 加载row时 ColumnDisplayIndexChanged 其中一个列更改属性时 UnloadingRowDetails 行详细信息元素成为可供重用时发生。 AddingNewItem 新项添加到DataGrid之前发生 CopyingRowClipboardContent 默认行内容准备好之后发生。 ColumnReordered 在列移至的显示顺序中的新位置时发生。 四、基本示例 前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition Width=&quot;200&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;DataGrid x:Name=&quot;datagrid&quot; SelectionMode=&quot;Extended&quot; IsReadOnly=&quot;True&quot; SelectionChanged=&quot;datagrid_Selected&quot;&gt; &lt;DataGrid.Columns&gt; &lt;DataGridTextColumn Header=&quot;姓名&quot; Binding=&quot;&#123;Binding Name&#125;&quot; /&gt; &lt;DataGridTextColumn Header=&quot;年龄&quot; Binding=&quot;&#123;Binding Age&#125;&quot; /&gt; &lt;DataGridTextColumn Header=&quot;地址&quot; Binding=&quot;&#123;Binding Address&#125;&quot; /&gt; &lt;/DataGrid.Columns&gt; &lt;/DataGrid&gt; &lt;StackPanel Grid.Column=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;姓名:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockName&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;年龄:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAge&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;地址:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAddress&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526272829303132333435363738namespace HelloWorld&#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Address &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); datagrid.Items.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;); datagrid.Items.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;); datagrid.Items.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); &#125; private void datagrid_Selected(object sender, RoutedEventArgs e) &#123; DataGrid datagrid = sender as DataGrid; if (datagrid == null) return; var person = datagrid.SelectedItem as Person; if (person == null) return; _TextBlockName.Text = person.Name; _TextBlockAge.Text = person.Age + &quot;岁&quot;; _TextBlockAddress.Text = person.Address; &#125; &#125;&#125; 在这个例子中，我们尽量还原了与ListView控件一致的功能， 需要注意的细节是：我们将DataGrid的IsReadOnly&#x3D;”True”，这是因为我们直接将数据元素一条一条的加入到DataGrid的Items属性中，而Items属性本身是一个只读属性，不支持写入。这样的话，当鼠标双击时会报错。错误提示为： 如何解决这个问题呢？这就要用到ItemsControl基类中的ItemsSource数据源属性。 我们需要采用DataGrid另外一种赋值方式——数据源赋值。即把一个集合绑定到该属性上，这样在前端就可以编辑数据源，从而不会引发报错。 只需要改动一点点代码。 1234567List&lt;Person&gt; list = new List&lt;Person&gt;(); list.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;);list.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;);list.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); datagrid.ItemsSource = list; 前端代码也可以修改如下，AutoGenerateColumns属性设为不可自动创建列。 1234567891011&lt;DataGrid x:Name=&quot;datagrid&quot; SelectionMode=&quot;Extended&quot; IsReadOnly=&quot;False&quot; AutoGenerateColumns=&quot;False&quot; SelectionChanged=&quot;datagrid_Selected&quot;&gt; &lt;DataGrid.Columns&gt; &lt;DataGridTextColumn Header=&quot;姓名&quot; Binding=&quot;&#123;Binding Name&#125;&quot; /&gt; &lt;DataGridTextColumn Header=&quot;年龄&quot; Binding=&quot;&#123;Binding Age&#125;&quot; /&gt; &lt;DataGridTextColumn Header=&quot;地址&quot; Binding=&quot;&#123;Binding Address&#125;&quot; /&gt; &lt;/DataGrid.Columns&gt;&lt;/DataGrid&gt; 如此，我们便可以在DataGrid中新增一行，并输入新的数据。 ComboBox下拉框控件ComboBox表示带有下拉列表的控件，实际上您可以把它看成两个部分组成，一个类似TextBox文本输入框，所以它有一个Text文本属性，用于获取ComboBox框的文本值，另一个是类似ListBox的列表框，用于显示ComboBox绑定的所有数据源。 ComboBox继承于Selector，所以，它只能是单选操作。由于这个控件由两个部分构成，所以在用法上，我们也可以有两种主要用法——类似TextBox用法和类似ListBox用法。 我们在使用这个控件之前，先熟悉一下它的定义 一、ComboBox定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[Localizability(LocalizationCategory.ComboBox)] [StyleTypedProperty(Property = &quot;ItemContainerStyle&quot;, StyleTargetType = typeof(ComboBoxItem))] [TemplatePart(Name = &quot;PART_EditableTextBox&quot;, Type = typeof(TextBox))] [TemplatePart(Name = &quot;PART_Popup&quot;, Type = typeof(Popup))]public class ComboBox : Selector&#123; public static readonly DependencyProperty MaxDropDownHeightProperty; public static readonly DependencyProperty IsDropDownOpenProperty; public static readonly DependencyProperty ShouldPreserveUserEnteredPrefixProperty; public static readonly DependencyProperty IsEditableProperty; public static readonly DependencyProperty TextProperty; public static readonly DependencyProperty IsReadOnlyProperty; public static readonly DependencyProperty SelectionBoxItemProperty; public static readonly DependencyProperty SelectionBoxItemTemplateProperty; public static readonly DependencyProperty SelectionBoxItemStringFormatProperty; public static readonly DependencyProperty StaysOpenOnEditProperty; public ComboBox(); public bool ShouldPreserveUserEnteredPrefix &#123; get; set; &#125; public bool IsEditable &#123; get; set; &#125; public string Text &#123; get; set; &#125; public bool IsReadOnly &#123; get; set; &#125; public object SelectionBoxItem &#123; get; &#125; public double MaxDropDownHeight &#123; get; set; &#125; public string SelectionBoxItemStringFormat &#123; get; &#125; public bool StaysOpenOnEdit &#123; get; set; &#125; public bool IsSelectionBoxHighlighted &#123; get; &#125; public bool IsDropDownOpen &#123; get; set; &#125; public DataTemplate SelectionBoxItemTemplate &#123; get; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; protected internal override bool HasEffectiveKeyboardFocus &#123; get; &#125; public event EventHandler DropDownClosed; public event EventHandler DropDownOpened; public override void OnApplyTemplate(); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected virtual void OnDropDownClosed(EventArgs e); protected virtual void OnDropDownOpened(EventArgs e); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e); protected override void OnPreviewKeyDown(KeyEventArgs e); protected override void OnSelectionChanged(SelectionChangedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); &#125; 二、属性成员 属性名称 说明 ShouldPreserveUserEnteredPrefix 是否保留用户的输入，或者输入替换匹配项。 IsEditable 是否启用或禁用编辑文本框中文本 Text 获取或设置当前选定项的文本。 IsReadOnly 文本内容是否只读 SelectionBoxItem 获取在选择框中显示的项。 MaxDropDownHeight 获取或设置一个组合框下拉列表的最大高度。 SelectionBoxItemStringFormat 指定选择框中文本的显示格式 StaysOpenOnEdit 在编辑输入框文本时，希望下拉框保持打开，则为true IsSelectionBoxHighlighted 是否突出显示SelectionBoxItem IsDropDownOpen 是否打开组合框下拉列表。 SelectionBoxItemTemplate 获取选择框内容的项模板。 接下来，我们还是一个实际的例子来说明combobox控件的用法。 三、ComboBox示例 前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition Width=&quot;200&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;StackPanel&gt; &lt;ComboBox x:Name=&quot;combobox1&quot; IsEditable=&quot;True&quot; Height=&quot;30&quot; Margin=&quot;20,10&quot; TextBoxBase.TextChanged=&quot;combobox1_TextChanged&quot;/&gt; &lt;ComboBox x:Name=&quot;combobox2&quot; StaysOpenOnEdit=&quot;True&quot; VerticalAlignment=&quot;Top&quot; SelectionChanged=&quot;combobox2_SelectionChanged&quot; Height=&quot;30&quot; Margin=&quot;20,10&quot; DisplayMemberPath=&quot;Name&quot;&gt; &lt;/ComboBox&gt; &lt;/StackPanel&gt; &lt;StackPanel Grid.Column=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;电话:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockTel&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;姓名:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockName&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;年龄:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAge&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;5&quot;&gt; &lt;TextBlock Text=&quot;地址:&quot;/&gt; &lt;TextBlock x:Name=&quot;_TextBlockAddress&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647namespace HelloWorld&#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public string Address &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); List&lt;Person&gt; list = new List&lt;Person&gt;(); list.Add(new Person &#123; Name = &quot;张三&quot;, Age = 22, Address = &quot;广东省廉江市车板镇大坝村&quot; &#125;); list.Add(new Person &#123; Name = &quot;李四&quot;, Age = 23, Address = &quot;江西省景德镇市市辖区&quot; &#125;); list.Add(new Person &#123; Name = &quot;王五&quot;, Age = 24, Address = &quot;上海市虹口区&quot; &#125;); combobox2.ItemsSource = list; &#125; private void combobox1_TextChanged(object sender, TextChangedEventArgs e) &#123; _TextBlockTel.Text = combobox1.Text; &#125; private void combobox2_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; ComboBox combobox = sender as ComboBox; if (combobox == null) return; var person = combobox.SelectedItem as Person; if (person == null) return; _TextBlockName.Text = person.Name; _TextBlockAge.Text = person.Age + &quot;岁&quot;; _TextBlockAddress.Text = person.Address; &#125; &#125;&#125; 我们在xaml中实例化了两个ComboBox，第一个直接当成了TextBox来使用；第二个则绑定了一个数据源，并在Xaml中指定了DisplayMemberPath属性显示Person的Name，最后在后端代码中，依然使用SelectedItem 属性获取当前选中项，转化成Person，以获取实际的选中数据。 这些就是该控件的基本用法。 TabControl控件TabControl表示包含多个共享相同的空间在屏幕上的项的控件。它也是继承于Selector基类，所以TabControl也只支持单选操作。另外，TabControl的元素只能是TabItem，这个TabItem继承于HeaderedContentControl类，所以TabControl的元素实际上是一个带标题的ContentControl内容控件。 我们曾经在聊GroupBox控件和Expander折叠控件时都曾提到过这个HeaderedContentControl类，原来大家都用了这个带标题的内容控件。所以TabControl控件看起来就像是多个GroupBox组合而来。 一、TabControl的定义 1234567891011121314151617181920212223242526272829303132public class TabControl : Selector&#123; public static readonly DependencyProperty TabStripPlacementProperty; public static readonly DependencyProperty SelectedContentProperty; public static readonly DependencyProperty SelectedContentTemplateProperty; public static readonly DependencyProperty SelectedContentTemplateSelectorProperty; public static readonly DependencyProperty SelectedContentStringFormatProperty; public static readonly DependencyProperty ContentTemplateProperty; public static readonly DependencyProperty ContentTemplateSelectorProperty; public static readonly DependencyProperty ContentStringFormatProperty; public TabControl(); public DataTemplate ContentTemplate &#123; get; set; &#125; public string SelectedContentStringFormat &#123; get; &#125; public DataTemplateSelector SelectedContentTemplateSelector &#123; get; &#125; public DataTemplate SelectedContentTemplate &#123; get; &#125; public object SelectedContent &#123; get; &#125; public Dock TabStripPlacement &#123; get; set; &#125; public string ContentStringFormat &#123; get; set; &#125; public DataTemplateSelector ContentTemplateSelector &#123; get; set; &#125; public override void OnApplyTemplate(); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnInitialized(EventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnSelectionChanged(SelectionChangedEventArgs e); &#125; 二、属性成员 属性名称 说明 ContentTemplate 表示TabItem元素的内容模板 SelectedContentStringFormat 当前所选内容的格式 SelectedContentTemplateSelector 获取当前选定的TabItem项的模板选择器 SelectedContentTemplate 当前选定的TabItem项的模板 SelectedContent 当前选定的TabItem项里面的内容（也是一些控件） TabStripPlacement 获取或设置选项卡标题相对于选项卡上内容的对齐方式。 ContentStringFormat 指定如何设置内容的格式 ContentTemplateSelector 获取或设置内容模板选择器 TabControl的SelectedContent可能是我们比较常用的一个属性，事实上，TabControl通常被当成布局控件来使用。 三、TabControl示例 前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;50&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;TabControl x:Name=&quot;_tabControl&quot; Grid.Row=&quot;0&quot; SelectionChanged=&quot;_tabControl_SelectionChanged&quot;&gt; &lt;TabItem Header=&quot;首页&quot;&gt; &lt;Border Background=&quot;LightBlue&quot;&gt; &lt;TextBlock Text=&quot;首页的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;TabItem Header=&quot;WPF目录&quot;&gt; &lt;Border Background=&quot;LightCoral&quot;&gt; &lt;TextBlock Text=&quot;WPF目录的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;TabItem Header=&quot;官方文档&quot;&gt; &lt;Border Background=&quot;LightCyan&quot;&gt; &lt;TextBlock Text=&quot;官方文档的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;TabItem Header=&quot;付费课程&quot;&gt; &lt;Border Background=&quot;LightGoldenrodYellow&quot;&gt; &lt;TextBlock Text=&quot;付费课程的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;TabItem Header=&quot;统计&quot;&gt; &lt;Border Background=&quot;LightGreen&quot;&gt; &lt;TextBlock Text=&quot;统计的界面&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;/TabItem&gt; &lt;/TabControl&gt; &lt;TextBlock x:Name=&quot;_textBlock&quot; TextWrapping=&quot;Wrap&quot; Grid.Row=&quot;1&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 123456789101112131415public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void _tabControl_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; var tab = sender as TabControl; var item = tab.SelectedItem as TabItem; var content = tab.SelectedContent; _textBlock.Text = &quot;标题:&quot; + item.Header.ToString() + &quot; 内容:&quot; + content; &#125;&#125; 我们订阅了TabControl控件的SelectionChanged事件，并在回调函数中获取了当前选中的TabItem对象以及它里面的内容。 TreeView树控件TreeView其实是一个比较复杂的控件，像操作系统的资源管理器就是一个TreeView。所以它常用于显示文件夹、目录等具有层级结构的数据。TreeView由节点和分支构成，每个节点可以包含零个或多个子节点，分支表示父子关系。在TreeView中，每个节点表示为TreeViewItem对象，可以通过TreeView的Items属性来获取或设置TreeViewItem对象集合。 在使用TreeView加载节点时，需要掌握一些递归思想。 一、TreeViewItem元素简介 TreeViewItem作为TreeView唯一的元素类型，它继承于HeaderedItemsControl（带标题），而HeaderedItemsControl又继承于ItemsControl，由此可见，TreeViewItem元素本身也是一个集合控件。 TreeViewItem有两个常用的属性，分别是IsSelected属性和IsExpanded属性，IsSelected表示当前元素是否选中，IsExpanded表示当前元素是否展开。 二、TreeView类的定义 123456789101112131415161718192021222324252627public class TreeView : ItemsControl&#123; public static readonly DependencyProperty SelectedItemProperty; public static readonly DependencyProperty SelectedValueProperty; public static readonly DependencyProperty SelectedValuePathProperty; public static readonly RoutedEvent SelectedItemChangedEvent; public TreeView(); public string SelectedValuePath &#123; get; set; &#125; public object SelectedValue &#123; get; &#125; public object SelectedItem &#123; get; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public event RoutedPropertyChangedEventHandler&lt;object&gt; SelectedItemChanged; protected virtual bool ExpandSubtree(TreeViewItem container); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnGotFocus(RoutedEventArgs e); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected virtual void OnSelectedItemChanged(RoutedPropertyChangedEventArgs&lt;object&gt; e); &#125; SelectedValuePath属性：获取或设置SelectedItem或SelectedValue的路径。 SelectedValue属性：获取SelectedItem的值 SelectedItem属性：获取当前选中的项 三、TreeView示例 接下来，我们以一个简单的示例，模仿操作系统的资源管理器的目录加载。 前端代码 12345678910111213141516171819202122&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;根目录&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;3&quot;/&gt; &lt;TextBox x:Name=&quot;_TextBox&quot; Width=&quot;380&quot; Height=&quot;25&quot; Margin=&quot;3&quot;/&gt; &lt;Button Content=&quot;选择...&quot; MinWidth=&quot;45&quot; Margin=&quot;3&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;TreeView x:Name=&quot;_TreeView&quot; Grid.Row=&quot;1&quot; SelectedItemChanged=&quot;_TreeView_SelectedItemChanged&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; System.Windows.Forms.FolderBrowserDialog dialog = new System.Windows.Forms.FolderBrowserDialog(); if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK) &#123; _TextBox.Text = dialog.SelectedPath; LoadTreeView(dialog.SelectedPath); &#125; &#125; private void LoadTreeView(string rootPath) &#123; // 设置根节点 TreeViewItem rootNode = new TreeViewItem(); rootNode.Header = &quot;根目录&quot;; // 加载子文件夹和文件 LoadSubDirectory(rootNode, rootPath); // 将根节点添加到TreeView中 _TreeView.Items.Add(rootNode); &#125; private void LoadSubDirectory(TreeViewItem node, string path) &#123; try &#123; DirectoryInfo dirInfo = new DirectoryInfo(path); // 加载子文件夹 foreach (DirectoryInfo subDirInfo in dirInfo.GetDirectories()) &#123; TreeViewItem subNode = new TreeViewItem(); subNode.Header = subDirInfo.Name; LoadSubDirectory(subNode, subDirInfo.FullName); node.Items.Add(subNode); &#125; // 加载文件 foreach (FileInfo fileInfo in dirInfo.GetFiles()) &#123; TreeViewItem subNode = new TreeViewItem(); subNode.Header = fileInfo.Name; node.Items.Add(subNode); &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; &#125; private void _TreeView_SelectedItemChanged(object sender, RoutedPropertyChangedEventArgs&lt;object&gt; e) &#123; // 获取选中的节点 TreeViewItem selectedNode = _TreeView.SelectedItem as TreeViewItem; // 显示选中节点的Header if (selectedNode != null) &#123; MessageBox.Show(selectedNode.Header.ToString()); &#125; &#125;&#125; 首先，通过鼠标操作，选择TreeView的根目录，然后，利用DirectoryInfo获取当前所有目录，再利用递归调用，一层一层的获取所有子目录，最后以TreeViewItem元素一层层加载到控件中。 Menu菜单Menu控件继承于MenuBase，而MenuBase继承于ItemsControl。所以学习Menu之前，要先了解一下MenuBase基类。它是一个抽象类，拥有一个ItemContainerTemplateSelector模板选择器，并重写了一些关于键盘和鼠标的方法。 Menu的子项必须为MenuItem。这个MenuItem和前面的TreeViewItem类似，拥有共同的HeaderedItemsControl父类，也就是说，MenuItem本身也是一个集合控件，若要以代码形式加载Menu的内容，也必须要掌握递归的加载思路。 在本节中，我们将以两种方式加载Menu的数据。但是在学习之前，先熟悉一下MenuItem元素，因为，实际上，我们主要是操作MenuItem元素。 一、MenuItem元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class MenuItem : HeaderedItemsControl, ICommandSource&#123; public static readonly RoutedEvent ClickEvent; public static readonly DependencyProperty UsesItemContainerTemplateProperty; public static readonly DependencyProperty ItemContainerTemplateSelectorProperty; public static readonly DependencyProperty IsSuspendingPopupAnimationProperty; public static readonly DependencyProperty IconProperty; public static readonly DependencyProperty InputGestureTextProperty; public static readonly DependencyProperty StaysOpenOnClickProperty; public static readonly DependencyProperty IsCheckedProperty; public static readonly DependencyProperty IsHighlightedProperty; public static readonly DependencyProperty IsCheckableProperty; public static readonly DependencyProperty IsPressedProperty; public static readonly DependencyProperty IsSubmenuOpenProperty; public static readonly DependencyProperty CommandTargetProperty; public static readonly DependencyProperty CommandParameterProperty; public static readonly DependencyProperty CommandProperty; public static readonly RoutedEvent SubmenuClosedEvent; public static readonly RoutedEvent SubmenuOpenedEvent; public static readonly RoutedEvent UncheckedEvent; public static readonly RoutedEvent CheckedEvent; public static readonly DependencyProperty RoleProperty; public MenuItem(); public static ResourceKey SubmenuHeaderTemplateKey &#123; get; &#125; public static ResourceKey SubmenuItemTemplateKey &#123; get; &#125; public static ResourceKey SeparatorStyleKey &#123; get; &#125; public static ResourceKey TopLevelItemTemplateKey &#123; get; &#125; public static ResourceKey TopLevelHeaderTemplateKey &#123; get; &#125; public bool IsCheckable &#123; get; set; &#125; public object CommandParameter &#123; get; set; &#125; public IInputElement CommandTarget &#123; get; set; &#125; public bool IsSubmenuOpen &#123; get; set; &#125; public MenuItemRole Role &#123; get; &#125; public bool IsPressed &#123; get; protected set; &#125; public bool IsHighlighted &#123; get; protected set; &#125; public bool StaysOpenOnClick &#123; get; set; &#125; public string InputGestureText &#123; get; set; &#125; public object Icon &#123; get; set; &#125; public bool IsSuspendingPopupAnimation &#123; get; &#125; public ItemContainerTemplateSelector ItemContainerTemplateSelector &#123; get; set; &#125; public bool UsesItemContainerTemplate &#123; get; set; &#125; public bool IsChecked &#123; get; set; &#125; public ICommand Command &#123; get; set; &#125; protected override bool IsEnabledCore &#123; get; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public event RoutedEventHandler Unchecked; public event RoutedEventHandler Click; public event RoutedEventHandler Checked; public event RoutedEventHandler SubmenuClosed; public event RoutedEventHandler SubmenuOpened; public override void OnApplyTemplate(); protected override DependencyObject GetContainerForItemOverride(); protected override bool IsItemItsOwnContainerOverride(object item); protected override void OnAccessKey(AccessKeyEventArgs e); protected virtual void OnChecked(RoutedEventArgs e); protected virtual void OnClick(); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e); protected override void OnInitialized(EventArgs e); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnMouseEnter(MouseEventArgs e); protected override void OnMouseLeave(MouseEventArgs e); protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e); protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e); protected override void OnMouseMove(MouseEventArgs e); protected override void OnMouseRightButtonDown(MouseButtonEventArgs e); protected override void OnMouseRightButtonUp(MouseButtonEventArgs e); protected virtual void OnSubmenuClosed(RoutedEventArgs e); protected virtual void OnSubmenuOpened(RoutedEventArgs e); protected virtual void OnUnchecked(RoutedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); protected override bool ShouldApplyItemContainerStyle(DependencyObject container, object item); protected internal override void OnVisualParentChanged(DependencyObject oldParent); &#125; MenuItem从鼠标的交互上，提供了两种方式。第一种是提供了Click事件，开发者可以订阅该事件以编写相应的业务逻辑。第二种是提供了ICommand接口属性和CommandParameter命令参数，以WPF命令的形式开发业务逻辑。 下面，我们以一种交互方式为例。 二、Menu示例 前端代码 1234567891011121314151617181920212223242526272829303132333435&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Menu x:Name=&quot;_Menu&quot;&gt; &lt;MenuItem Header=&quot;文件&quot;&gt; &lt;MenuItem Header=&quot;新建&quot; Click=&quot;MenuItem_Click&quot;/&gt; &lt;MenuItem Header=&quot;打开&quot; Click=&quot;MenuItem_Click&quot;&gt; &lt;MenuItem.Icon&gt; &lt;Image Source=&quot;/Images/logo.png&quot;/&gt; &lt;/MenuItem.Icon&gt; &lt;/MenuItem&gt; &lt;/MenuItem&gt; &lt;MenuItem Header=&quot;编辑&quot;/&gt; &lt;MenuItem Header=&quot;视图&quot;/&gt; &lt;MenuItem Header=&quot;项目&quot;/&gt; &lt;MenuItem Header=&quot;调试&quot;/&gt; &lt;MenuItem Header=&quot;测试&quot;/&gt; &lt;MenuItem Header=&quot;分析&quot;/&gt; &lt;MenuItem Header=&quot;工具&quot;/&gt; &lt;MenuItem Header=&quot;帮助&quot;/&gt; &lt;/Menu&gt; &lt;TextBlock x:Name=&quot;_TextBlock&quot; Grid.Row=&quot;1&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt;&lt;/TextBlock&gt; &lt;/Grid&gt;&lt;/Window&gt; 后端代码 12345678910111213public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private void MenuItem_Click(object sender, RoutedEventArgs e) &#123; var item = sender as MenuItem; _TextBlock.Text = $&quot;你单击了 &#123;item.Header&#125;&quot;; &#125;&#125; 上面演示了Menu最基本的用法，如果希望采用数据绑定的方式加载菜单，则可以参考下面的作法。 三、Menu数据绑定 我们需要创建一个实体类，来代表Menu的每一个子项。 123456789/// &lt;summary&gt;/// 主菜单的实体/// &lt;/summary&gt;public class MenuModel&#123; public string Name &#123; get; set; &#125; public List&lt;MenuModel&gt; Children &#123; get; set; &#125; = new List&lt;MenuModel&gt;(); public string View &#123; get; set; &#125;&#125; 在前端代码中，需要设置Menu的ItemTemplate元素模板。 1234567891011121314151617181920212223&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; xmlns:forms=&quot;clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Menu x:Name=&quot;_Menu&quot;&gt; &lt;Menu.ItemTemplate&gt; &lt;HierarchicalDataTemplate ItemsSource=&quot;&#123;Binding Children&#125;&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot;/&gt; &lt;/HierarchicalDataTemplate&gt; &lt;/Menu.ItemTemplate&gt; &lt;/Menu&gt; &lt;/Grid&gt;&lt;/Window&gt; 因为MenuModel实体中有Children集合，所以在前端将Children作为HierarchicalDataTemplate的ItemsSource。并将Name显示出来。 最后，实例化一些子项数据，形成一个数据源，将这个数据源绑定到Menu的ItemsSource即可 来看看后端代码 12345678910111213141516171819202122232425public partial class MainWindow : Window&#123; public List&lt;MenuModel&gt; Menus &#123; get; set; &#125; = new List&lt;MenuModel&gt;(); public MainWindow() &#123; InitializeComponent(); for (int i = 0; i &lt; 5; i++) &#123; MenuModel parent = new MenuModel(); parent.Name = $&quot;一级菜单 &quot;; for (int j = 0; j &lt; 5; j++) &#123; MenuModel child = new MenuModel(); child.Name = $&quot;二级菜单 &quot;; parent.Children.Add(child); &#125; Menus.Add(parent); &#125; _Menu.ItemsSource = Menus; &#125; &#125; ContextMenu上下文菜单ContextMenu上下文菜单必须要依附于一个“宿主控件”。由于FrameworkElement基类有一个叫ContextMenu的属性，代表了鼠标右键时弹出一个菜单，所以大多数控件都可以设置“上下文菜单”。 ContextMenu继承于MenuBase，而MenuBase继承于ItemsControl。所以，ContextMenu本质上也是一个集合控件。而它的元素则是MenuItem。在用法上，与Menu控件差不多。 一、ContextMenu的定义 12345678910111213141516171819202122232425262728293031323334353637383940public class ContextMenu : MenuBase&#123; public static readonly DependencyProperty HorizontalOffsetProperty; public static readonly RoutedEvent OpenedEvent; public static readonly DependencyProperty StaysOpenProperty; public static readonly DependencyProperty CustomPopupPlacementCallbackProperty; public static readonly DependencyProperty HasDropShadowProperty; public static readonly RoutedEvent ClosedEvent; public static readonly DependencyProperty PlacementRectangleProperty; public static readonly DependencyProperty PlacementTargetProperty; public static readonly DependencyProperty IsOpenProperty; public static readonly DependencyProperty VerticalOffsetProperty; public static readonly DependencyProperty PlacementProperty; public ContextMenu(); public double HorizontalOffset &#123; get; set; &#125; public bool StaysOpen &#123; get; set; &#125; public CustomPopupPlacementCallback CustomPopupPlacementCallback &#123; get; set; &#125; public bool HasDropShadow &#123; get; set; &#125; public PlacementMode Placement &#123; get; set; &#125; public Rect PlacementRectangle &#123; get; set; &#125; public UIElement PlacementTarget &#123; get; set; &#125; public bool IsOpen &#123; get; set; &#125; public double VerticalOffset &#123; get; set; &#125; protected internal override bool HandlesScrolling &#123; get; &#125; public event RoutedEventHandler Closed; public event RoutedEventHandler Opened; protected virtual void OnClosed(RoutedEventArgs e); protected override AutomationPeer OnCreateAutomationPeer(); protected override void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e); protected override void OnKeyDown(KeyEventArgs e); protected override void OnKeyUp(KeyEventArgs e); protected virtual void OnOpened(RoutedEventArgs e); protected override void PrepareContainerForItemOverride(DependencyObject element, object item); protected internal override void OnVisualParentChanged(DependencyObject oldParent); &#125; 二、属性成员 属性名称 说明 HorizontalOffset 获取或设置目标原点和弹出项对齐之间的水平距离点。 StaysOpen 是否保持打开状态 CustomPopupPlacementCallback 获取或设置ContextMenu指示在屏幕位置的回调 HasDropShadow 是否有投影出现的上下文菜单。 Placement 获取或设置ContextMenu显示的相对位置 PlacementRectangle 获取或设置相对于其上下文菜单位于在打开时的区域。 PlacementTarget 获取或设置ContextMenu打开时的相对控件 IsOpen 是否打开 VerticalOffset 获取或设置目标原点和弹出项对齐之间的垂直距离点。 三、ContextMenu示例 123456789101112&lt;Grid&gt; &lt;Border Background=&quot;LightBlue&quot; Width=&quot;200&quot; Height=&quot;100&quot; CornerRadius=&quot;15&quot;&gt; &lt;Border.ContextMenu&gt; &lt;ContextMenu&gt; &lt;MenuItem Header=&quot;复制&quot;/&gt; &lt;MenuItem Header=&quot;粘贴&quot;/&gt; &lt;MenuItem Header=&quot;删除&quot;/&gt; &lt;MenuItem Header=&quot;关于&quot;/&gt; &lt;/ContextMenu&gt; &lt;/Border.ContextMenu&gt; &lt;/Border&gt; &lt;/Grid&gt; StatusBar状态栏StatusBar是一个“包容性”极强的控件，通常的作用是作为程序的状态内容显示。它同样继承于ItemsControl基类，所以，它也是一个集合控件。 它的元素是StatusBarItem类型，而StatusBarItem继承于ContentControl内容控件，所以，本质上讲，StatusBar的元素可以是任意类型的控件。因为StatusBarItem元素有一个叫Content的属性。 这个控件其实并不常用，通常情况下被当成一个布局控件来使用。如下所示 12345678910111213141516171819&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StatusBar Grid.Row=&quot;1&quot;&gt; &lt;StatusBarItem Content=&quot;版权所有 @WPF中文网&quot;/&gt; &lt;StatusBarItem&gt; &lt;CheckBox Content=&quot;CheckBox&quot;/&gt; &lt;/StatusBarItem&gt; &lt;StatusBarItem&gt; &lt;RadioButton Content=&quot;RadioButton&quot;/&gt; &lt;/StatusBarItem&gt; &lt;StatusBarItem&gt; &lt;Button Content=&quot;Button&quot;/&gt; &lt;/StatusBarItem&gt; &lt;TextBlock Text=&quot;文字块&quot;/&gt; &lt;/StatusBar&gt;&lt;/Grid&gt; 如上所示，StatusBar的元素除了StatusBarItem，甚至可以直接实例化其它控件，比如最后一个TextBlock就是这样的用法。 图形控件Shape概述形状是WPF另一大系列控件。WPF所有的形状都继承于Shape基类。那么，WPF提供了哪些可用的形状呢？我们用一张图来说明它的子类。 形状名称 说明 Ellipse 椭圆形 Line 在两个点之间绘制直线。 Rectangle 绘制矩形。 Polyline 绘制一系列相互连接的直线。 Polygon 绘制多边形，它是由一系列相互连接的线条构成的闭合形状。 Path 绘制一系列相互连接的直线和曲线。 Shape是一个抽象基类，它不能被实例化，所以我们在使用时只能实例化它的子类。而Shape的父类是FrameworkElement，所以，所有的Shape子类都是一个UIElement 类，因此形状对象可以用在面板和大多数控件中。 由于 Canvas 面板支持其子对象的绝对位置，因此特别适合创建复杂的图形。 我们来看看Shape的定义 一、Shape的定义 123456789101112131415161718192021222324252627282930313233343536public abstract class Shape : FrameworkElement&#123; public static readonly DependencyProperty StretchProperty; public static readonly DependencyProperty StrokeDashArrayProperty; public static readonly DependencyProperty StrokeDashOffsetProperty; public static readonly DependencyProperty StrokeLineJoinProperty; public static readonly DependencyProperty StrokeDashCapProperty; public static readonly DependencyProperty StrokeMiterLimitProperty; public static readonly DependencyProperty StrokeStartLineCapProperty; public static readonly DependencyProperty StrokeThicknessProperty; public static readonly DependencyProperty StrokeProperty; public static readonly DependencyProperty FillProperty; public static readonly DependencyProperty StrokeEndLineCapProperty; protected Shape(); public Brush Stroke &#123; get; set; &#125; public PenLineCap StrokeEndLineCap &#123; get; set; &#125; public PenLineCap StrokeStartLineCap &#123; get; set; &#125; public double StrokeThickness &#123; get; set; &#125; public Brush Fill &#123; get; set; &#125; public double StrokeDashOffset &#123; get; set; &#125; public virtual Geometry RenderedGeometry &#123; get; &#125; public Stretch Stretch &#123; get; set; &#125; public DoubleCollection StrokeDashArray &#123; get; set; &#125; public double StrokeMiterLimit &#123; get; set; &#125; public PenLineCap StrokeDashCap &#123; get; set; &#125; public virtual Transform GeometryTransform &#123; get; &#125; public PenLineJoin StrokeLineJoin &#123; get; set; &#125; protected abstract Geometry DefiningGeometry &#123; get; &#125; protected override Size ArrangeOverride(Size finalSize); protected override Size MeasureOverride(Size constraint); protected override void OnRender(DrawingContext drawingContext); &#125; Shape基类提供了许多公共属性，如下表所示。 二、属性成员 属性名称 说明 Stroke 获取或设置Shape的边框颜色画刷 StrokeEndLineCap 获取或设置Shape描述线的末端的样式 StrokeStartLineCap 获取或设置Shape描述线的开头的样式 StrokeThickness 获取或设置Shape边框的厚度 Fill 获取或设置Shape的内部填充颜色 StrokeDashOffset 获取或设置短划线模式内短划线开始处的距离 RenderedGeometry 获取或设置Shape的几何 Stretch 获取或设置Shape的填充模式 StrokeDashArray 获取或设置勾勒形状轮廓的短划线和间隙的模式的值 StrokeMiterLimit 获取或设置一个限制到一半的斜接长度比 StrokeDashCap 获取或设置 System.Windows.Media.PenLineCap 枚举值，该值指定如何绘制虚线的末端。 GeometryTransform 获取或设置Shape的转换 StrokeLineJoin 获取或设置Shape的顶点处使用的联接类型。 DefiningGeometry 获取Shape的Geometry Ellipse椭圆Ellipse继承于Shape，Shape继承于FrameworkElement，所以，它可以设置其 Width 和 Height。 使用其 Fill 属性指定用于绘制椭圆形内部的 Brush。 使用其 Stroke 属性指定用于绘制椭圆形轮廓的 Brush。 StrokeThickness 属性指定椭圆形轮廓的粗细。 下面的示例演示了椭圆和正圆。 前端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;WPF中文网 - wpfsoft.com - 椭圆课程&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Ellipse Width=&quot;100&quot; Height=&quot;50&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;2&quot; Fill=&quot;Red&quot;&gt; &lt;Ellipse.Triggers&gt; &lt;EventTrigger RoutedEvent=&quot;Loaded&quot;&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation From=&quot;100&quot; To=&quot;200&quot; Duration=&quot;0:0:2&quot; AutoReverse=&quot;True&quot; RepeatBehavior=&quot;Forever&quot; Storyboard.TargetProperty=&quot;(Ellipse.Width)&quot; /&gt; &lt;DoubleAnimation From=&quot;50&quot; To=&quot;100&quot; Duration=&quot;0:0:2&quot; AutoReverse=&quot;True&quot; RepeatBehavior=&quot;Forever&quot; Storyboard.TargetProperty=&quot;(Ellipse.Height)&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt; &lt;/Ellipse.Triggers&gt; &lt;/Ellipse&gt; &lt;Grid Grid.Column=&quot;1&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Ellipse Width=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Height=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Fill=&quot;Green&quot;/&gt; &lt;Slider x:Name=&quot;slider&quot; Grid.Row=&quot;1&quot; Value=&quot;50&quot; Maximum=&quot;200&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt;&lt;/Window&gt; 在上面的例子中，我们实例化了两个椭圆，第一个椭圆用了一个事件Triggers和Storyboard故事板，演示了椭圆大小的动画改变，在第二个椭圆中，宽度和高度相等，便出现了一个正圆，利用Binding对象将Slider的Value和椭圆的尺寸绑定起来，以此滑动改变椭圆大小。 注：关于动画部分，我们将在后面专门讲解。 Line线段Line(线段)继承于Shape，它自身只有4个属性，分别用于定义线段两端的端点坐标。 123456789101112131415public sealed class Line : Shape&#123; public static readonly DependencyProperty X1Property; public static readonly DependencyProperty Y1Property; public static readonly DependencyProperty X2Property; public static readonly DependencyProperty Y2Property; public Line(); public double X1 &#123; get; set; &#125; public double Y1 &#123; get; set; &#125; public double X2 &#123; get; set; &#125; public double Y2 &#123; get; set; &#125; protected override Geometry DefiningGeometry &#123; get; &#125;&#125; 其中X1,Y1表示第一个点坐标，X2,Y2表示第二个点坐标。 下面的属性位于Shape基类，在Line线段中设置后，会有意想不到的效果。 StrokeStartLineCap属性：表示线段前头的开关。 Stroke：线条颜色。 StrokeThickness：线条宽度。 StrokeDashArray：设置虚线。 StrokeDashOffset：虚线位置偏移量。 接下来，我们以一个示例来说明Line的用法。 前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;WPF中文网 - wpfsoft.com - Line课程&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Canvas x:Name=&quot;canvas&quot;&gt; &lt;Line x:Name=&quot;flowLine&quot; X1=&quot;20&quot; Y1=&quot;40&quot; X2=&quot;400&quot; Y2=&quot;100&quot; StrokeDashArray=&quot;2,1&quot; Stroke=&quot;Green&quot; StrokeThickness=&quot;8&quot;/&gt; &lt;Line X1=&quot;&#123;Binding ElementName=x1,Path=Value&#125;&quot; Y1=&quot;&#123;Binding ElementName=y1,Path=Value&#125;&quot; X2=&quot;&#123;Binding ElementName=x2,Path=Value&#125;&quot; Y2=&quot;&#123;Binding ElementName=y2,Path=Value&#125;&quot; StrokeStartLineCap=&quot;Round&quot; Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;/&gt; &lt;Slider x:Name=&quot;x1&quot; Value=&quot;10&quot; Maximum=&quot;450&quot; Width=&quot;450&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;237&quot;/&gt; &lt;Slider x:Name=&quot;y1&quot; Value=&quot;10&quot; Maximum=&quot;450&quot; Width=&quot;450&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;256&quot;/&gt; &lt;Slider x:Name=&quot;x2&quot; Value=&quot;300&quot; Maximum=&quot;450&quot; Width=&quot;450&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;276&quot;/&gt; &lt;Slider x:Name=&quot;y2&quot; Value=&quot;300&quot; Maximum=&quot;450&quot; Width=&quot;450&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;295&quot;/&gt; &lt;/Canvas&gt;&lt;/Window&gt; 后端代码 1234567891011121314151617181920212223242526public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); Loaded += (s, e) =&gt; &#123; int number = 10; Task.Run(() =&gt; &#123; while (true) &#123; if (number == 1) number = 10; Application.Current.Dispatcher.BeginInvoke(new Action(() =&gt; &#123; flowLine.StrokeDashOffset = number; &#125;)); number--; Thread.Sleep(250); &#125; &#125;); &#125;; &#125;&#125; 在XAML代码中，我们实例化了两个Line，其中一个Line的端点坐标绑定了4个Slider的Value属性，可以通过滑动改变线条的位置，第二Line设置为虚线，并通过C#代码开辟子线程，在子线程中通过动态设置StrokeDashOffset属性，来模拟流动的线段效果。 Rectangle矩形Rectangle是一个比较简单而实用的图形控件，继承于Shape，有两个属性比较常用，即RadiusX和RadiusY，表示设置矩形的圆角。所以，通过这两个属性的设置，矩形也可以画出一个圆。 观察下面的例子。 12345678910111213141516171819202122232425262728293031&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; Title=&quot;WPF中文网 - wpfsoft.com -课程&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Canvas x:Name=&quot;canvas&quot;&gt; &lt;Rectangle RadiusX=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; RadiusY=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Width=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Height=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Fill=&quot;Red&quot; Canvas.Left=&quot;50&quot; Canvas.Top=&quot;36&quot;/&gt; &lt;Rectangle Width=&quot;100&quot; Height=&quot;100&quot; Fill=&quot;Green&quot; Canvas.Left=&quot;313&quot; Canvas.Top=&quot;36&quot;/&gt; &lt;Slider x:Name=&quot;slider&quot; Width=&quot;450&quot; Value=&quot;100&quot; Maximum=&quot;450&quot; Canvas.Left=&quot;32&quot; Canvas.Top=&quot;291&quot;/&gt; &lt;/Canvas&gt;&lt;/Window&gt; 在本例中，我们实例化了两个Rectangle对象，如果RadiusX和RadiusY与Width、Height相等，则会显示一个正圆。 Polyline折线Polyline表示由一系列线段组合绘制而成的折线，因为它有一个Points属性，用来保存这些点的坐标。这些坐标点用于绘制Polyline图形中各线段相接处的顶点。集合中第一个元素表示起点，最后一元素表示终点。 在XAML前端代码中定义Points的内容书写格式如下：假如我们有4个点，分别是起点(30,30)，中继点(200,30)，中继点(50,250)，终点(220,250)，那么，Points的内容书写为：Points&#x3D;”30,30 200,30 50,250 220,250” 完整代码如下所示 12345678910111213&lt;Canvas x:Name=&quot;canvas&quot;&gt; &lt;Polyline StrokeThickness=&quot;20&quot; Points=&quot;30,30 200,30 50,250 220,250&quot;&gt; &lt;Polyline.Stroke&gt; &lt;LinearGradientBrush StartPoint=&quot;30,30&quot; EndPoint=&quot;220,250&quot; MappingMode=&quot;Absolute&quot;&gt; &lt;GradientStop Color=&quot;Red&quot; Offset=&quot;1&quot; /&gt; &lt;GradientStop Color=&quot;Yellow&quot; Offset=&quot;0.66&quot; /&gt; &lt;GradientStop Color=&quot;Green&quot; Offset=&quot;0&quot; /&gt; &lt;/LinearGradientBrush&gt; &lt;/Polyline.Stroke&gt; &lt;/Polyline&gt;&lt;/Canvas&gt; Polygon多边形Polygon叫多边形，与Polyline类似，都有一个Points属性，只不过，Polygon会把起点和终点连接起来。就拿上一节的例子，我们只是简单地把Polyline换成Polygon，其它设置保持不变。如下所示： 12345678910111213&lt;Canvas x:Name=&quot;canvas&quot;&gt; &lt;Polygon StrokeThickness=&quot;20&quot; Points=&quot;30,30 200,30 50,250 220,250&quot;&gt; &lt;Polygon.Stroke&gt; &lt;LinearGradientBrush StartPoint=&quot;30,30&quot; EndPoint=&quot;220,250&quot; MappingMode=&quot;Absolute&quot;&gt; &lt;GradientStop Color=&quot;Red&quot; Offset=&quot;1&quot; /&gt; &lt;GradientStop Color=&quot;Yellow&quot; Offset=&quot;0.66&quot; /&gt; &lt;GradientStop Color=&quot;Green&quot; Offset=&quot;0&quot; /&gt; &lt;/LinearGradientBrush&gt; &lt;/Polygon.Stroke&gt; &lt;/Polygon&gt;&lt;/Canvas&gt; 结果，在Polyline下面原本呈现的Z字形，在Polygon下面就变成了一个8字形，可以很明显的看到它的起点和终点相连起来了。 同理，我们在C#后端，也相应的修改成Polygon对象。 123456789101112131415161718192021222324252627282930public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); &#125; private int count = 0; private Polygon polygon = null; private void Window_PreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e) &#123; if (count++ == 0) &#123; polygon = new Polygon(); polygon.StrokeThickness = 5; polygon.Stroke = Brushes.Red; canvas.Children.Add(polygon); &#125; var point = e.GetPosition(canvas); polygon.Points.Add(point); &#125; private void Window_PreviewMouseRightButtonUp(object sender, MouseButtonEventArgs e) &#123; count = 0; &#125;&#125; 最后，效果如上，用鼠标绘制出来的就是封闭的多边形。 Path路径12345678910public sealed class Path : Shape&#123; public static readonly DependencyProperty DataProperty; public Path(); public Geometry Data &#123; get; set; &#125; protected override Geometry DefiningGeometry &#123; get; &#125;&#125; 从定义上看，Path只有一个Data属性，这个属性的类型为Geometry。而Geometry又是一个抽象类，所以我们不能直接使用它，那它肯定会有一系列可以实例化的子类。没错，Geometry表示一个几何，而几何的图形可以分为好几种。 几何名称 说明 LineGeometry 直线几何 RectangleGeometry 矩形几何 EllipseGeometry 椭圆几何 PathGeometry 路径几何 StreamGeometry PathGeometry的轻量级替代品，不支持 Bidning、动画等功能 CombinedGeometry 多图形组合，形成单一几何几何图形 GeometryGroup 多图形组合，形成几何图形组 接下来，我们分别讲一下这几种几何的用法。 一、LineGeometry直线几何 12345&lt;Path Stroke=&quot;Blue&quot; Fill=&quot;Red&quot;&gt; &lt;Path.Data&gt; &lt;LineGeometry StartPoint=&quot;10,20&quot; EndPoint=&quot;100,200&quot;/&gt; &lt;/Path.Data&gt;&lt;/Path&gt; 二、RectangleGeometry矩形几何 12345&lt;Path Stroke=&quot;Blue&quot; Fill=&quot;Red&quot;&gt; &lt;Path.Data&gt; &lt;RectangleGeometry Rect=&quot;50,20,30,40&quot; /&gt; &lt;/Path.Data&gt;&lt;/Path&gt; 三、EllipseGeometry椭圆几何 12345&lt;Path Stroke=&quot;Yellow&quot; Fill=&quot;LightGreen&quot;&gt; &lt;Path.Data&gt; &lt;EllipseGeometry Center=&quot;150,80&quot; RadiusX=&quot;60&quot; RadiusY=&quot;50&quot;/&gt; &lt;/Path.Data&gt;&lt;/Path&gt; 从上面的3个例子来看，Line、Rectangle、Ellipse控件能够画出来的效果，Path都可以画出来。而接下来我们要分享的是，Line、Rectangle、Ellipse控件画不出来的效果，Path也能画出来。那就是PathGeometry路径几何。 四、PathGeometry路径几何 PathGeometry微微有点复杂。它有一个Figures属性，可以容纳很多较复杂的图形。Figures是一个集合，其中的元素是PathFigure类型，而PathFigure中的Segments属性又是一个集合，其中的元素类型为PathSegment。 PathSegment是一个抽象类，我们可以实例化PathSegment的子类放到PathFigure中，然后把PathFigure放到PathGeometry中，这样就可以绘制不同的路径图形了。那么PathSegment有哪些子类呢？ LineSegment 直线段 ArcSegment 圆弧线段 BezierSegment 三次方贝塞尔曲线段 QuadraticBezierSegmnt 二次方贝塞尔曲线段 PolyLineSegment 折线段 PolyBezierSegment 多三次方贝塞尔曲线段 PolyQuadraticBezierSegment 多二次方贝塞尔曲 PathFigure有一个StartPoint属性表示起点坐标，而Segments集合中的元素就是上面那张表中的各种线段实例，它们将依次首尾相接，最终绘制成形。 我们以LineSegment和ArcSegment为例。 12345678910111213141516171819&lt;Path Stroke=&quot;Black&quot; Fill=&quot;LightPink&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathGeometry.Figures&gt; &lt;PathFigure StartPoint=&quot;150,200&quot;&gt; &lt;LineSegment Point=&quot;300,200&quot;/&gt; &lt;ArcSegment Point=&quot;300 50&quot; Size=&quot;100 100&quot; SweepDirection=&quot;Clockwise&quot; IsLargeArc=&quot;False&quot;/&gt; &lt;ArcSegment Point=&quot;300 200&quot; Size=&quot;100 100&quot; SweepDirection=&quot;Clockwise&quot; IsLargeArc=&quot;False&quot;/&gt; &lt;/PathFigure&gt; &lt;/PathGeometry.Figures&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt;&lt;/Path&gt; 首先，PathFigure 图形的起点坐标为（150,200），然后第一个元素是线段，终点坐标为（300,200），图形的坐标原点是左上角（0，0），所以，往下就是Y轴正半轴方向，往右就是X轴正半轴方向。 然后，画了两条圆弧，第一条圆弧的起点坐标就是线段的终点坐标，即（300,200），圆弧的终点坐标为（300 50），大小为（100 100），第二条圆弧的终点坐标又回到了线段的终点坐标（300 200），于是就出现了图中的样子。 ArcSegment的常用属性如下：Point：指明圆弧连接的终点；Size：指明完整椭圆的横轴半径和纵轴半径；IsLargeArc：指明是否使用大弧去连接 ；SweepDirection ：指明圆弧是顺时针方向还是逆时针方向；RotationAngle：指明圆弧椭圆的旋转角度； 接下来，我们再讲一下BezierSegment贝塞尔曲线。 BezierSegment需要4个坐标点来完成图形的绘制，分别是起点，控制点1，控制点2和终点。 123&lt;PathFigure IsFilled=&quot;False&quot; StartPoint=&quot;5,5&quot;&gt; &lt;BezierSegment Point1=&quot;200,50&quot; Point2=&quot;50,200&quot; Point3=&quot;350,250&quot;/&gt;&lt;/PathFigure&gt; 如上所示，（5，5）表示起点（StartPoint属性），Point1属性（200,50）和Point2属性（50,200）表示两个控制点，Point3属性（350,250）表示终点。 五、Path的标记语法 通过上面的示例我们会发现要绘制复杂的图形，需要实例化各种子类，代码繁琐，这时就需要了解Path的路径标记语法，它大大减少了代码量。您可以从以下的表格或微软官网中获得相关知识。 命令 用途 语法 示例 对应标签语法 M 移动到起点坐标 M 起点 M 150,200 L 绘制直线 L 终点 L 300,200 H 水平直线 H 终点横坐标 V 垂直直线 V 终点横坐标 A 绘制圆弧 A 母椭圆尺寸 旋转角度 是否大弧 顺时针&#x2F;逆时针 终点 A 180，80 45 1 1 150，150 C 三次方贝塞尔曲线 C 控制点1 控制点2 终点 C 200,50 50,200 350,250 Q 二次方贝塞尔曲线 Q 控制点1 终点 Q 200,50 350,250 S 平滑三次方贝塞尔曲线 S 控制点2 终点 S 200,50 350,250 T 平滑二次方贝塞尔曲线 T 终点 T 350,250 Z 闭合图形 Z M 10,150 L40,150 L40,250 L10,250 Z 1&lt;Path Fill=&quot;HotPink&quot; Data=&quot;M 10,150 L40,150 L40,250 L10,250 Z&quot;/&gt; 最后，我们通过Path的路径标记语法画了一个封闭的矩形图形，可以看到代码量的书写大大减少了。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"WPF - 编程","slug":"WPF-编程","permalink":"http://example.com/tags/WPF-%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"WPF编程基础上（一）","slug":"WPF基础学习上","date":"2025-05-11T10:00:24.000Z","updated":"2025-05-13T14:34:26.244Z","comments":true,"path":"2025/05/11/WPF基础学习上/","permalink":"http://example.com/2025/05/11/WPF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%8A/","excerpt":"","text":"BindingPath12341. this.DataContext = new MainViewModel();2. &lt;Window.DataContext&gt; &lt;local:MainViewModel /&gt; &lt;/Window.DataContext&gt; 12345//xaml&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding Path=Message&#125;&quot;/&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding Message&#125;&quot;/&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding Path=.&#125;&quot;/&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding .&#125;&quot;/&gt; 1234567//用程序来写var binding = new Bingding&#123; Path = new PropertyPath(&quot;Message&quot;), Mode BindingMode.TwoWay&#125;;BindingOperations.SetBinding(tbl,TextBlock.TextProperty,bingding); 123456789101112131415&lt;TextBlock&gt; &lt;TextBlock.Text&gt; &lt;MultiBinding&gt; &lt;Binding/&gt; &lt;/MultiBinding&gt; &lt;/TextBlock.Text&gt;&lt;/TextBlock&gt; &lt;TextBlock&gt; &lt;TextBlock.Text&gt; &lt;PriorityBinding&gt; &lt;Binding/&gt; &lt;/PriorityBinding&gt; &lt;/TextBlock.Text&gt;&lt;/TextBlock&gt; Source12345678910&lt;Windows.DataContext&gt; &lt;sys:String x:Key=&quot;str&quot;&gt;Hello,world&lt;/sys:String&gt;&lt;/Windows.DataContext&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;Binding Source=&#123;StaticResource str&#125;&#125;&quot;/&gt;&lt;TextBlock Name=&quot;tbl&quot; Text=&quot;&#123;DynamicResource str&#125;&quot;/&gt; private void Window_Loaded(object sender,RoutedEventArgs e) &#123; this.Resources[&quot;str&quot;] = &quot;Goodbye&quot;; &#125; 123456class MyResource&#123; public string Message&#123;get;&#125; = &quot;public Property&quot;; public static string StaticString = &quot;Static string&quot;; public const string ConstString = &quot;Const String&quot;;&#125; 12345678&lt;Windows.DataContext&gt; &lt;local:MyResource x:key=&quot;myres&quot; /&gt;&lt;/Windows.DataContext&gt;&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;StaticResource myres,Path=Message&#125;&#125;&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Static local:MyResource.StaticString&#125;&#125;&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Static local:MyResource.ConstString&#125;&#125;&quot;/&gt;//enum&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Static HorizontalAlignment.Stretch&#125;&#125;&quot;/&gt; 12&lt;CollectionViewSource/&gt;&lt;ObjectDataProvider/&gt; ElementName12&lt;TextBox Name=&quot;txt&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding ElementName=txt,Path=text&#125;&quot; /&gt; 绑定失败的例子： 123456&lt;TextBox Name=&quot;txt&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding ElementName=txt,Path=text&#125;&quot; &gt; &lt;TextBlock.ToolTip&gt; &lt;TextBlock Text=&quot;&#123;Binding ElementName=txt,Path=text&#125;&quot;&gt; &lt;/TextBlock.ToolTip&gt;&lt;/TextBlock&gt; 原因scope 123456&lt;TextBox Name=&quot;txt&quot;/&gt;&lt;TextBlock Text=&quot;&#123;Binding ElementName=txt,Path=text&#125;&quot; &gt; &lt;TextBlock.ToolTip&gt; &lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Reference txt&#125;,Path=text&#125;&quot;&gt; &lt;/TextBlock.ToolTip&gt;&lt;/TextBlock&gt; ModeRelativeSource相对源 FindAncestor 寻找父级 AncestorType 父级类型 AncestorLevel 父级级别 PreviousData Self 自己 TemplateParent 12//当前窗口屏幕上方距离&lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=FindAncestor , Path= Top&#125;&#125;&quot;/&gt; 12345//绑定同级&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;TextBox /&gt; &lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource AncestorType=StackPanel ,Path=Chilren[0].Text&#125;&#125;&quot;/&gt;&lt;/StackPanel&gt; 123456789101112131415//绑定自己&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;TextBox /&gt; &lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Self,Path=ActualWidth&#125;&#125;&quot;/&gt;&lt;/StackPanel&gt;//方法2&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;TextBox /&gt; &lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;x:Static RealativeSource.Self,Path=ActualWidth&#125;&#125;&quot;/&gt;&lt;/StackPanel&gt;//方法3&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;TextBox /&gt; &lt;TextBlock Text=&quot;&#123;Binding RelativeSource 2,Path=ActualWidth&#125;&#125;&quot;/&gt;&lt;/StackPanel&gt; 123456789101112//情况少用&lt;StackPanel Name=&quot;panel&quot; Margin=&quot;10&quot;&gt; &lt;Label Padding=&quot;10&quot; Content=&quot;Hello&quot;&gt; &lt;Label.Template&gt; &lt;ControlTemplate TargetType=&quot;Label&quot;&gt; &lt;Border&gt; &lt;ContentPresenter Margin=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplateParent&#125;,Path=Padding,Mode=OneWay&#125;&quot;/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Label.Template&gt; &lt;/Label&gt;&lt;/StackPanel&gt; Misc.(其他)123//浮点数，保留3位小数&lt;TextBlock Text=&quot;&#123;Binding ElementName=window,Path=Top,StringFormat=&#x27;Top:&#123;0:F3&#125;&#x27;&#125;&quot;/&gt;&lt;Label Content=&quot;&#123;Binding ElementName=window,Path=Left,ContentStringFormat=&#x27;Left:&#123;0:F3&#125;&#x27;&#125;&quot;/&gt; 12//TextBox实时更新&lt;TextBox Text=&quot;&#123;Binding ElementName=tb1,Path=Text,UpdateSourceTrigger=PropertyChanged&#125;&quot;/&gt; TargetNullValue 当获取或设置源的值为 null 时将使用TargetNullValue的值。 FallbackValue 当增加了绑定语法时，有时绑定失败了啥都不显示，我们可能需要一些提示语句来提示我们绑定失败，此时就用到了 FallbackValue。 依赖属性（DP） 是类的静态字段 只能存在于DependencyObject上 WPF控件都继承了DependencyObject,且拥有大量DependencyProperty 最终会存放在DP类中的静态HashTable中 实现 属性名 属性类型 对应的类型 初始值 值发生变化时的回调方法 附加属性写在单独的类中（类可以不是DependencyObject） 只有在这个回调方法中可以知道当前的属性被附加在了什么上 语法 常规 123456789101112class CustomTextBox : TextBox&#123; public bool IsHighlighted &#123; get &#123; return (bool)GetValue(IsHighlightedProperty); &#125; set &#123; SetValue(IsHighlightedProperty, value); &#125; &#125; public static readonly DependencyProperty IsHighlightedProperty = DependencyProperty.Register(&quot;IsHighlighted&quot;, typeof(bool), typeof(CustomTextBox), new PropertyMetadata(false)); &#125; 属性修改时的回调 1234567public static readonly DependencyProperty IsHighlightedProperty = DependencyProperty.Register(&quot;IsHighlighted&quot;, typeof(bool), typeof(CustomTextBox), new PropertyMetadata(false,callback));private static void callback(DependencyObject d, DependencyPropertyChangedEventArgs e)&#123; ...&#125; 只读属性 12345678910111213141516/// &lt;summary&gt;/// 只读/// &lt;/summary&gt; public bool HasText =&gt; (bool)GetValue(HasTextProperty);public static readonly DependencyProperty HasTextProperty;public static readonly DependencyPropertyKey HasTextPropertyKey;static CustomTextBox()&#123; HasTextPropertyKey = DependencyProperty.RegisterReadOnly(&quot;HasText&quot;, typeof(bool), typeof(CustomTextBox), new PropertyMetadata(false )); HasTextProperty = HasTextPropertyKey.DependencyProperty;&#125; 附加属性（AP）为什么不选择DP 已有控件的类都是写好的，没有其他办法为他添加DP 有些属性并不专属于某种控件，而是具有通用性 Grid.ROw DockPanel.Dock Canvas.Left AP不必写在DependencyObject上 语法 123&lt;TextBox Grid.Row=&quot;0&quot;&gt; &lt;Grid.Column&gt;1&lt;/Grid.Column&gt;&lt;/TextBox&gt; 123&lt;TextBox ap:TextBoxHelper.Title=&quot;Hello&quot;&gt; &lt;ap:TextBoxHelper.Content&gt;World&lt;/ap:TextBoxHelper.Content&gt;&lt;/TextBox&gt; 控件父类控件的父类们 我们以最常用的Button控件为例。首先看看它的父类们：Button-&gt;ButtonBase-&gt;ContentControl-&gt;Control-&gt;FrameworkElement-&gt;UIElement-&gt;Visual-&gt;DependencyObject-&gt;DispatcherObject。 然后再看一个最常用的StackPanel控件的继承路线：StackPanel-&gt;Panel-&gt;FrameworkElement-&gt;UIElement-&gt;Visual-&gt;DependencyObject-&gt;DispatcherObject。 最后再看一个Rectangle矩形图形的继承路线：Rectangle-&gt;Shape-&gt;FrameworkElement-&gt;UIElement-&gt;Visual-&gt;DependencyObject-&gt;DispatcherObject。 我们会发现它们的继承路线最终都在FrameworkElement这一层汇合，换句话说，这三种控件的身上都流着FrameworkElement的血，那自然也流淌着UIElement-&gt;Visual-&gt;DependencyObject-&gt;DispatcherObject这四个父类的血了。 DispatcherObject DependencyObject Visual UIElement FrameworkElement DispatcherObject类当你们在后台线程中要访问控件时，就可以从控件中找到那位中间商Dispatcher，由中间商来完成你要对控件的操作访问。（调度员） 在开发过程中，难免需要在后台线程中去操作控件，于是Dispatcher调度员提供了Invoke和BeginInvoke两个方法，供我们可以安全的访问UI线程中的控件。 官方解释在 WPF 中， DispatcherObject 只能由 Dispatcher 它与之关联的访问。 例如，后台线程无法更新与 Dispatcher UI 线程上关联的内容Button。 为了使后台线程访问该 Content 属性 Button，后台线程必须将工作委托给 Dispatcher 与 UI 线程关联的工作。 这是通过使用 Invoke 或BeginInvoke。 Invoke 是同步的， BeginInvoke 是异步的。 操作将添加到指定DispatcherPriority位置的队列Dispatcher中。 1234567891011121314151617181920212223namespace HelloWorld&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); Task.Run(() =&gt; &#123; Task.Delay(3000).Wait(); button.Dispatcher.Invoke(() =&gt; &#123; button.Content = &quot;www.wpfsoft.com&quot;; &#125;); &#125;); &#125; &#125;&#125; DependencyObject类在需要的时候主动去改变控件的值的开发模式，我们称为事件驱动模式。 于是微软在WPF框架中推出了更省事的处理方式——数据驱动模式。什么是数据驱动模式？**控件的属性不再被直接赋值，而是绑定了另一个”变量“，当这个”变量“发生改变时，控件的属性也会跟着改变，这样的属性也被称为依赖属性。**这有点像初中数学中的y&#x3D;x这样的函数，y是因变量，x是自变量，y随着x的变化而变化。 提前阅读 DependencyObject 类表示参与依赖属性系统的对象。属性系统的主要功能是计算属性的值，并提供有关已更改的值的系统通知。 参与属性系统的另一个类 DependencyProperty。 DependencyProperty 允许将依赖属性注册到属性系统，并提供有关每个依赖属性的标识和信息，而 DependencyObject 为基类，使对象能够使用此依赖属性。INotifyPropertyChanged 类用于通知UI刷新，注重的仅仅是数据更新后的通知。DependencyObject 类用于给UI添加依赖和附加属性，注重数据与UI的关联。如果简单的数据通知，两者都可以实现的。 我们来看一下DependencyObject类的定义，比较常用的是GetValue和SetValue。GetValue表示获取某一个依赖属性的值，由于不确定这个值是什么类型，所以微软把这个函数的返回值设计成object。SetValue表示设置某一个依赖属竹的值，所有它有两个参数，第一个参数dp表示要设置的依赖属性，第二个参数value表示新值。 1234567891011121314151617181920212223public class DependencyObject : DispatcherObject&#123; public DependencyObject(); public DependencyObjectType DependencyObjectType &#123; get; &#125; public bool IsSealed &#123; get; &#125; public void ClearValue(DependencyProperty dp); public void ClearValue(DependencyPropertyKey key); public void CoerceValue(DependencyProperty dp); public sealed override bool Equals(object obj); public sealed override int GetHashCode(); public LocalValueEnumerator GetLocalValueEnumerator(); public object GetValue(DependencyProperty dp); public void InvalidateProperty(DependencyProperty dp); public object ReadLocalValue(DependencyProperty dp); public void SetCurrentValue(DependencyProperty dp, object value); public void SetValue(DependencyProperty dp, object value); public void SetValue(DependencyPropertyKey key, object value); protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e); protected internal virtual bool ShouldSerializeProperty(DependencyProperty dp); &#125; Visual类Visual类是WPF框架中第三个父类，主要是为 WPF 中的呈现提供支持，其中包括命中测试、坐标转换和边界框计算。它位于程序集:PresentationCore.dll库文件中，它的命名空间:System.Windows.Media。 官方引用 Visual 类是派生每个 FrameworkElement 对象的基本抽象。 该类还用作在 WPF 中编写新控件的入口点，在 Win32 应用程序模型中，该类在许多方面可视为窗口句柄 (HWND)。Visual 对象是一个核心 WPF 对象，它的主要作用是提供呈现支持。 用户界面控件如 Button 和 TextBox）派生自 Visual 类，并使用该类来保存它们的呈现数据。 Visual 对象为以下项提供支持：输出显示：呈现视觉对象的持久、序列化的绘图内容。转换：针对视觉对象执行转换。剪裁：为视觉对象提供剪裁区域支持。命中测试：确定坐标或几何形状是否包含在视觉对象的边界内。边框计算：确定视觉对象的边框。 换句话说，将来我们要学习的Button、TextBox、CheckBox、Gird、ListBox等所有控件都继承了Visual类，控件在绘制到界面的过程中，涉及到转换、裁剪、边框计算等功能，都是使用了Visual父类的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class Visual : DependencyObject, IResource&#123; protected Visual(); protected DependencyObject VisualParent &#123; get; &#125; protected virtual int VisualChildrenCount &#123; get; &#125; protected internal DoubleCollection VisualYSnappingGuidelines &#123; get; protected set; &#125; protected internal Vector VisualOffset &#123; get; protected set; &#125; protected internal Geometry VisualClip &#123; get; protected set; &#125; protected internal Rect? VisualScrollableAreaClip &#123; get; protected set; &#125; protected internal CacheMode VisualCacheMode &#123; get; protected set; &#125; protected internal BitmapEffectInput VisualBitmapEffectInput &#123; get; protected set; &#125; protected internal BitmapEffect VisualBitmapEffect &#123; get; protected set; &#125; protected internal Effect VisualEffect &#123; get; protected set; &#125; protected internal Transform VisualTransform &#123; get; protected set; &#125; protected internal BitmapScalingMode VisualBitmapScalingMode &#123; get; protected set; &#125; protected internal DoubleCollection VisualXSnappingGuidelines &#123; get; protected set; &#125; protected internal double VisualOpacity &#123; get; protected set; &#125; protected internal EdgeMode VisualEdgeMode &#123; get; protected set; &#125; protected internal ClearTypeHint VisualClearTypeHint &#123; get; set; &#125; protected internal TextRenderingMode VisualTextRenderingMode &#123; get; set; &#125; protected internal TextHintingMode VisualTextHintingMode &#123; get; set; &#125; protected internal Brush VisualOpacityMask &#123; get; protected set; &#125; public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual); public bool IsAncestorOf(DependencyObject descendant); public bool IsDescendantOf(DependencyObject ancestor); public Point PointFromScreen(Point point); public Point PointToScreen(Point point); public GeneralTransform2DTo3D TransformToAncestor(Visual3D ancestor); public GeneralTransform TransformToAncestor(Visual ancestor); public GeneralTransform TransformToDescendant(Visual descendant); public GeneralTransform TransformToVisual(Visual visual); protected void AddVisualChild(Visual child); protected virtual Visual GetVisualChild(int index); protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters); protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters); protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi); protected void RemoveVisualChild(Visual child); protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved); protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);&#125; 代码分析 首先，我们可以看到，Visual类继承了DependencyObject类。另外Visual类是一个抽象类，不可以被实例。Visual类提供了一系列的属性和方法。我们在这里捡一些比较重要的分析一下。 VisualParent属性：这个属性表示获取一个可视化父对象。因为XAML的代码结构就是一棵xml树，每个控件都对象几乎都有一个可视化父对象。 VisualChildrenCount属性：获取当前对象的子元素数量。 VisualOffset属性：指当前可视对象的偏移量值。需要注意的是这个属性被声明成protected internal。啥意思呢？VisualOffset属性只能由同一个程序集的其它类访问，或Visual的子类访问。 protected internal protected internal 关键字组合是一种成员访问修饰符， 表示受保护的内部成员。 VisualOpacity属性：获取或设置 Visual 的不透明度。 VisualEffect属性：获取或设置要应用于 Visual 的位图效果。 VisualTransform属性：获取或设置 Transform 的 Visual 值。 这些属性都只读为了解Visual类的基础，因为这些属性都被设计成protected internal，我们的控件虽然继承了这个Visual类，但在实际的使用过程中是感知不到这些属性的，自然也不能实操它们。 我们真正能在继承的控件中直接使用的是Visual类中被声明为public的方法成员。它们有以下几个： DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual); &#x2F;&#x2F;返回两个可视对象的公共上级。 bool IsAncestorOf(DependencyObject descendant); &#x2F;&#x2F;确定可视对象是否为后代可视对象的上级。 bool IsDescendantOf(DependencyObject ancestor); &#x2F;&#x2F;确定可视对象是否为上级可视对象的后代。 Point PointFromScreen(Point point); &#x2F;&#x2F;将屏幕坐标中的 Point 转换为表示 Point 的当前坐标系的 Visual。 Point PointToScreen(Point point); &#x2F;&#x2F;将表示 Point 的当前坐标系的 Visual 转换为屏幕坐标中的 Point。 GeneralTransform2DTo3D TransformToAncestor(Visual3D ancestor); &#x2F;&#x2F;返回一个转换，该转换可用于将 Visual 中的坐标转换为可视对象的指定 Visual3D 上级。 GeneralTransform TransformToAncestor(Visual ancestor); &#x2F;&#x2F;返回一个转换，该转换可用于将 Visual 中的坐标转换为可视对象的指定 Visual 上级。 GeneralTransform TransformToDescendant(Visual descendant); &#x2F;&#x2F;返回一个转换，该转换可用于将 Visual 中的坐标转换为指定的可视对象后代。 GeneralTransform TransformToVisual(Visual visual); &#x2F;&#x2F;返回一个转换，该转换可用于将 Visual 中的坐标转换为指定的可视对象。 由此可见，Visual类所做的事情只为控件呈现相关，但还不是去呈现控件，只是提供呈现的基础。那么，谁又去继承了Visual类，成为继Visual类之后又一个控件的基类呢？答案是UIElement类。 UIElement类UIElement类继承了Visual类，在WPF框架中排行老四（第4个基类）。它位于程序集:PresentationCore.dll之中，命名空间:System.Windows。 这个基类非常非常重要，理解了这个类，就理解了WPF所有控件1&#x2F;3的知识与用法。我们先来看一下它的全貌。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404public class UIElement : Visual, IAnimatable, IInputElement&#123;public static readonly RoutedEvent PreviewMouseDownEvent;public static readonly DependencyProperty AreAnyTouchesOverProperty;public static readonly DependencyProperty AreAnyTouchesDirectlyOverProperty;public static readonly DependencyProperty IsKeyboardFocusedProperty;public static readonly DependencyProperty IsStylusCaptureWithinProperty;public static readonly DependencyProperty IsStylusCapturedProperty;public static readonly DependencyProperty IsMouseCaptureWithinProperty;public static readonly DependencyProperty IsMouseCapturedProperty;public static readonly DependencyProperty IsKeyboardFocusWithinProperty;public static readonly DependencyProperty IsStylusOverProperty;public static readonly DependencyProperty IsMouseOverProperty;public static readonly DependencyProperty IsMouseDirectlyOverProperty;public static readonly RoutedEvent TouchLeaveEvent;public static readonly RoutedEvent TouchEnterEvent;public static readonly RoutedEvent LostTouchCaptureEvent;public static readonly RoutedEvent GotTouchCaptureEvent;public static readonly RoutedEvent TouchUpEvent;public static readonly RoutedEvent PreviewTouchUpEvent;public static readonly RoutedEvent TouchMoveEvent;public static readonly RoutedEvent PreviewTouchMoveEvent;public static readonly RoutedEvent TouchDownEvent;public static readonly RoutedEvent PreviewTouchDownEvent;public static readonly RoutedEvent DropEvent;public static readonly RoutedEvent PreviewDropEvent;public static readonly RoutedEvent DragLeaveEvent;public static readonly RoutedEvent PreviewDragLeaveEvent;public static readonly DependencyProperty AreAnyTouchesCapturedProperty;public static readonly DependencyProperty AreAnyTouchesCapturedWithinProperty;public static readonly DependencyProperty AllowDropProperty;public static readonly DependencyProperty RenderTransformProperty;public static readonly RoutedEvent ManipulationCompletedEvent;public static readonly RoutedEvent ManipulationBoundaryFeedbackEvent;public static readonly RoutedEvent ManipulationInertiaStartingEvent;public static readonly RoutedEvent ManipulationDeltaEvent;public static readonly RoutedEvent ManipulationStartedEvent;public static readonly RoutedEvent ManipulationStartingEvent;public static readonly DependencyProperty IsManipulationEnabledProperty;public static readonly DependencyProperty FocusableProperty;public static readonly DependencyProperty IsVisibleProperty;public static readonly DependencyProperty IsHitTestVisibleProperty;public static readonly DependencyProperty IsEnabledProperty;public static readonly DependencyProperty IsFocusedProperty;public static readonly RoutedEvent DragOverEvent;public static readonly RoutedEvent LostFocusEvent;public static readonly DependencyProperty SnapsToDevicePixelsProperty;public static readonly DependencyProperty ClipProperty;public static readonly DependencyProperty ClipToBoundsProperty;public static readonly DependencyProperty VisibilityProperty;public static readonly DependencyProperty UidProperty;public static readonly DependencyProperty CacheModeProperty;public static readonly DependencyProperty BitmapEffectInputProperty;public static readonly DependencyProperty EffectProperty;public static readonly DependencyProperty BitmapEffectProperty;public static readonly DependencyProperty OpacityMaskProperty;public static readonly DependencyProperty OpacityProperty;public static readonly DependencyProperty RenderTransformOriginProperty;public static readonly RoutedEvent GotFocusEvent;public static readonly RoutedEvent PreviewDragOverEvent;public static readonly DependencyProperty IsStylusDirectlyOverProperty;public static readonly RoutedEvent PreviewDragEnterEvent;public static readonly RoutedEvent StylusMoveEvent;public static readonly RoutedEvent PreviewStylusMoveEvent;public static readonly RoutedEvent StylusUpEvent;public static readonly RoutedEvent PreviewStylusUpEvent;public static readonly RoutedEvent StylusDownEvent;public static readonly RoutedEvent PreviewStylusDownEvent;public static readonly RoutedEvent QueryCursorEvent;public static readonly RoutedEvent LostMouseCaptureEvent;public static readonly RoutedEvent GotMouseCaptureEvent;public static readonly RoutedEvent MouseLeaveEvent;public static readonly RoutedEvent MouseEnterEvent;public static readonly RoutedEvent MouseWheelEvent;public static readonly RoutedEvent PreviewStylusInAirMoveEvent;public static readonly RoutedEvent PreviewMouseWheelEvent;public static readonly RoutedEvent PreviewMouseMoveEvent;public static readonly RoutedEvent MouseRightButtonUpEvent;public static readonly RoutedEvent PreviewMouseRightButtonUpEvent;public static readonly RoutedEvent MouseRightButtonDownEvent;public static readonly RoutedEvent PreviewMouseRightButtonDownEvent;public static readonly RoutedEvent DragEnterEvent;public static readonly RoutedEvent PreviewMouseLeftButtonUpEvent;public static readonly RoutedEvent MouseLeftButtonDownEvent;public static readonly RoutedEvent PreviewMouseLeftButtonDownEvent;public static readonly RoutedEvent MouseUpEvent;public static readonly RoutedEvent PreviewMouseUpEvent;public static readonly RoutedEvent MouseDownEvent;public static readonly RoutedEvent MouseMoveEvent;public static readonly RoutedEvent StylusInAirMoveEvent;public static readonly RoutedEvent MouseLeftButtonUpEvent;public static readonly RoutedEvent StylusLeaveEvent;public static readonly RoutedEvent StylusEnterEvent;public static readonly RoutedEvent GiveFeedbackEvent;public static readonly RoutedEvent PreviewGiveFeedbackEvent;public static readonly RoutedEvent QueryContinueDragEvent;public static readonly RoutedEvent TextInputEvent;public static readonly RoutedEvent PreviewTextInputEvent;public static readonly RoutedEvent LostKeyboardFocusEvent;public static readonly RoutedEvent PreviewLostKeyboardFocusEvent;public static readonly RoutedEvent GotKeyboardFocusEvent;public static readonly RoutedEvent PreviewGotKeyboardFocusEvent;public static readonly RoutedEvent KeyUpEvent;public static readonly RoutedEvent PreviewKeyUpEvent;public static readonly RoutedEvent KeyDownEvent;public static readonly RoutedEvent PreviewQueryContinueDragEvent;public static readonly RoutedEvent PreviewStylusButtonUpEvent;public static readonly RoutedEvent PreviewKeyDownEvent;public static readonly RoutedEvent StylusInRangeEvent;public static readonly RoutedEvent PreviewStylusInRangeEvent;public static readonly RoutedEvent StylusOutOfRangeEvent;public static readonly RoutedEvent PreviewStylusSystemGestureEvent;public static readonly RoutedEvent PreviewStylusOutOfRangeEvent;public static readonly RoutedEvent GotStylusCaptureEvent;public static readonly RoutedEvent LostStylusCaptureEvent;public static readonly RoutedEvent StylusButtonDownEvent;public static readonly RoutedEvent StylusButtonUpEvent;public static readonly RoutedEvent PreviewStylusButtonDownEvent;public static readonly RoutedEvent StylusSystemGestureEvent; public UIElement(); public string Uid &#123; get; set; &#125;public Visibility Visibility &#123; get; set; &#125;public bool ClipToBounds &#123; get; set; &#125;public Geometry Clip &#123; get; set; &#125;public bool SnapsToDevicePixels &#123; get; set; &#125;public bool IsFocused &#123; get; &#125;public bool IsEnabled &#123; get; set; &#125;public bool IsHitTestVisible &#123; get; set; &#125;public bool IsVisible &#123; get; &#125;public bool AreAnyTouchesCapturedWithin &#123; get; &#125;public int PersistId &#123; get; &#125;public bool IsManipulationEnabled &#123; get; set; &#125;public bool AreAnyTouchesOver &#123; get; &#125;public bool AreAnyTouchesDirectlyOver &#123; get; &#125;public bool AreAnyTouchesCaptured &#123; get; &#125;public IEnumerable&lt;TouchDevice&gt; TouchesCaptured &#123; get; &#125;public IEnumerable&lt;TouchDevice&gt; TouchesCapturedWithin &#123; get; &#125;public IEnumerable&lt;TouchDevice&gt; TouchesOver &#123; get; &#125;public CacheMode CacheMode &#123; get; set; &#125;public bool Focusable &#123; get; set; &#125;public BitmapEffectInput BitmapEffectInput &#123; get; set; &#125;public bool IsMouseDirectlyOver &#123; get; &#125;public BitmapEffect BitmapEffect &#123; get; set; &#125;public Size RenderSize &#123; get; set; &#125;public bool IsArrangeValid &#123; get; &#125;public bool IsMeasureValid &#123; get; &#125;public Size DesiredSize &#123; get; &#125;public bool AllowDrop &#123; get; set; &#125;public CommandBindingCollection CommandBindings &#123; get; &#125;public InputBindingCollection InputBindings &#123; get; &#125;public bool HasAnimatedProperties &#123; get; &#125;public bool IsMouseOver &#123; get; &#125;public Effect Effect &#123; get; set; &#125;public bool IsStylusOver &#123; get; &#125;public bool IsMouseCaptured &#123; get; &#125;public bool IsMouseCaptureWithin &#123; get; &#125;public bool IsStylusDirectlyOver &#123; get; &#125;public bool IsStylusCaptured &#123; get; &#125;public bool IsStylusCaptureWithin &#123; get; &#125;public bool IsKeyboardFocused &#123; get; &#125;public bool IsInputMethodEnabled &#123; get; &#125;public double Opacity &#123; get; set; &#125;public Brush OpacityMask &#123; get; set; &#125;public bool IsKeyboardFocusWithin &#123; get; &#125;public IEnumerable&lt;TouchDevice&gt; TouchesDirectlyOver &#123; get; &#125;public Point RenderTransformOrigin &#123; get; set; &#125;public Transform RenderTransform &#123; get; set; &#125;protected StylusPlugInCollection StylusPlugIns &#123; get; &#125;protected virtual bool IsEnabledCore &#123; get; &#125;protected internal virtual bool HasEffectiveKeyboardFocus &#123; get; &#125; public event KeyEventHandler KeyUp;public event EventHandler&lt;TouchEventArgs&gt; TouchMove;public event EventHandler&lt;TouchEventArgs&gt; PreviewTouchMove;public event EventHandler&lt;TouchEventArgs&gt; TouchDown;public event EventHandler&lt;TouchEventArgs&gt; PreviewTouchDown;public event DragEventHandler Drop;public event DragEventHandler PreviewDrop;public event DragEventHandler DragLeave;public event DragEventHandler PreviewDragLeave;public event DragEventHandler DragOver;public event DragEventHandler PreviewDragOver;public event DragEventHandler DragEnter;public event DragEventHandler PreviewDragEnter;public event GiveFeedbackEventHandler GiveFeedback;public event GiveFeedbackEventHandler PreviewGiveFeedback;public event QueryContinueDragEventHandler QueryContinueDrag;public event QueryContinueDragEventHandler PreviewQueryContinueDrag;public event TextCompositionEventHandler TextInput;public event EventHandler&lt;TouchEventArgs&gt; PreviewTouchUp;public event EventHandler&lt;TouchEventArgs&gt; TouchUp;public event EventHandler&lt;TouchEventArgs&gt; LostTouchCapture;public event TextCompositionEventHandler PreviewTextInput;public event EventHandler&lt;ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting;public event EventHandler&lt;ManipulationDeltaEventArgs&gt; ManipulationDelta;public event EventHandler&lt;ManipulationStartedEventArgs&gt; ManipulationStarted;public event EventHandler&lt;ManipulationStartingEventArgs&gt; ManipulationStarting;public event DependencyPropertyChangedEventHandler FocusableChanged;public event DependencyPropertyChangedEventHandler IsVisibleChanged;public event DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;public event DependencyPropertyChangedEventHandler IsEnabledChanged;public event RoutedEventHandler LostFocus;public event EventHandler&lt;TouchEventArgs&gt; GotTouchCapture;public event RoutedEventHandler GotFocus;public event DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;public event DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;public event DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;public event DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;public event DependencyPropertyChangedEventHandler IsMouseCapturedChanged;public event DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;public event DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;public event EventHandler&lt;TouchEventArgs&gt; TouchLeave;public event EventHandler&lt;TouchEventArgs&gt; TouchEnter;public event EventHandler LayoutUpdated;public event KeyboardFocusChangedEventHandler LostKeyboardFocus;public event KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;public event KeyboardFocusChangedEventHandler GotKeyboardFocus;public event StylusEventHandler PreviewStylusMove;public event StylusEventHandler StylusMove;public event StylusEventHandler PreviewStylusInAirMove;public event StylusEventHandler StylusInAirMove;public event StylusEventHandler StylusEnter;public event StylusEventHandler StylusLeave;public event StylusEventHandler PreviewStylusInRange;public event StylusEventHandler StylusInRange;public event StylusEventHandler PreviewStylusOutOfRange;public event StylusEventHandler StylusOutOfRange;public event StylusSystemGestureEventHandler PreviewStylusSystemGesture;public event StylusSystemGestureEventHandler StylusSystemGesture;public event StylusEventHandler GotStylusCapture;public event StylusEventHandler LostStylusCapture;public event StylusButtonEventHandler StylusButtonDown;public event StylusButtonEventHandler StylusButtonUp;public event StylusButtonEventHandler PreviewStylusButtonDown;public event StylusButtonEventHandler PreviewStylusButtonUp;public event KeyEventHandler PreviewKeyDown;public event KeyEventHandler KeyDown;public event KeyEventHandler PreviewKeyUp;public event StylusEventHandler StylusUp;public event KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;public event StylusEventHandler PreviewStylusUp;public event StylusDownEventHandler PreviewStylusDown;public event MouseButtonEventHandler PreviewMouseDown;public event MouseButtonEventHandler MouseDown;public event MouseButtonEventHandler PreviewMouseUp;public event MouseButtonEventHandler MouseUp;public event MouseButtonEventHandler PreviewMouseLeftButtonDown;public event MouseButtonEventHandler MouseLeftButtonDown;public event MouseButtonEventHandler PreviewMouseLeftButtonUp;public event MouseButtonEventHandler MouseLeftButtonUp;public event MouseButtonEventHandler PreviewMouseRightButtonDown;public event MouseButtonEventHandler MouseRightButtonDown;public event MouseButtonEventHandler PreviewMouseRightButtonUp;public event MouseButtonEventHandler MouseRightButtonUp;public event MouseEventHandler PreviewMouseMove;public event MouseEventHandler MouseMove;public event MouseWheelEventHandler PreviewMouseWheel;public event MouseWheelEventHandler MouseWheel;public event MouseEventHandler MouseEnter;public event MouseEventHandler MouseLeave;public event MouseEventHandler GotMouseCapture;public event MouseEventHandler LostMouseCapture;public event QueryCursorEventHandler QueryCursor;public event StylusDownEventHandler StylusDown;public event DependencyPropertyChangedEventHandler IsStylusCapturedChanged;public event EventHandler&lt;ManipulationCompletedEventArgs&gt; ManipulationCompleted;public event EventHandler&lt;ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback; public void AddHandler(RoutedEvent routedEvent, Delegate handler);public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);public void AddToEventRoute(EventRoute route, RoutedEventArgs e);public void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);public void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);public void Arrange(Rect finalRect);public void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);public void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);public bool CaptureMouse();public bool CaptureStylus();public bool CaptureTouch(TouchDevice touchDevice);public bool Focus();public object GetAnimationBaseValue(DependencyProperty dp);public IInputElement InputHitTest(Point point);public void InvalidateArrange();public void InvalidateMeasure();public void InvalidateVisual();public void Measure(Size availableSize);public virtual bool MoveFocus(TraversalRequest request);public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);public void RaiseEvent(RoutedEventArgs e);public void ReleaseAllTouchCaptures();public void ReleaseMouseCapture();public void ReleaseStylusCapture();public bool ReleaseTouchCapture(TouchDevice touchDevice);public void RemoveHandler(RoutedEvent routedEvent, Delegate handler);public bool ShouldSerializeCommandBindings();public bool ShouldSerializeInputBindings();public Point TranslatePoint(Point point, UIElement relativeTo);public void UpdateLayout();protected virtual void ArrangeCore(Rect finalRect);protected virtual Geometry GetLayoutClip(Size layoutSlotSize);protected override HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);protected override GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);protected virtual Size MeasureCore(Size availableSize);protected virtual void OnAccessKey(AccessKeyEventArgs e);protected virtual void OnChildDesiredSizeChanged(UIElement child);protected virtual AutomationPeer OnCreateAutomationPeer();protected virtual void OnDragEnter(DragEventArgs e);protected virtual void OnDragLeave(DragEventArgs e);protected virtual void OnDragOver(DragEventArgs e);protected virtual void OnDrop(DragEventArgs e);protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);protected virtual void OnGotFocus(RoutedEventArgs e);protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);protected virtual void OnGotMouseCapture(MouseEventArgs e);protected virtual void OnGotStylusCapture(StylusEventArgs e);protected virtual void OnGotTouchCapture(TouchEventArgs e);protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);protected virtual void OnKeyDown(KeyEventArgs e);protected virtual void OnKeyUp(KeyEventArgs e);protected virtual void OnLostFocus(RoutedEventArgs e);protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);protected virtual void OnLostMouseCapture(MouseEventArgs e);protected virtual void OnLostStylusCapture(StylusEventArgs e);protected virtual void OnLostTouchCapture(TouchEventArgs e);protected virtual void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e);protected virtual void OnManipulationCompleted(ManipulationCompletedEventArgs e);protected virtual void OnManipulationDelta(ManipulationDeltaEventArgs e);protected virtual void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e);protected virtual void OnManipulationStarted(ManipulationStartedEventArgs e);protected virtual void OnManipulationStarting(ManipulationStartingEventArgs e);protected virtual void OnMouseDown(MouseButtonEventArgs e);protected virtual void OnMouseEnter(MouseEventArgs e);protected virtual void OnMouseLeave(MouseEventArgs e);protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);protected virtual void OnMouseMove(MouseEventArgs e);protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);protected virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);protected virtual void OnMouseUp(MouseButtonEventArgs e);protected virtual void OnMouseWheel(MouseWheelEventArgs e);protected virtual void OnPreviewDragEnter(DragEventArgs e);protected virtual void OnPreviewDragLeave(DragEventArgs e);protected virtual void OnPreviewDragOver(DragEventArgs e);protected virtual void OnPreviewDrop(DragEventArgs e);protected virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);protected virtual void OnPreviewKeyDown(KeyEventArgs e);protected virtual void OnPreviewKeyUp(KeyEventArgs e);protected virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);protected virtual void OnPreviewMouseDown(MouseButtonEventArgs e);protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);protected virtual void OnPreviewMouseMove(MouseEventArgs e);protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);protected virtual void OnPreviewMouseUp(MouseButtonEventArgs e);protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);protected virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);protected virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);protected virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);protected virtual void OnPreviewStylusDown(StylusDownEventArgs e);protected virtual void OnPreviewStylusInAirMove(StylusEventArgs e);protected virtual void OnPreviewStylusInRange(StylusEventArgs e);protected virtual void OnPreviewStylusMove(StylusEventArgs e);protected virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);protected virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);protected virtual void OnPreviewStylusUp(StylusEventArgs e);protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);protected virtual void OnPreviewTouchDown(TouchEventArgs e);protected virtual void OnPreviewTouchMove(TouchEventArgs e);protected virtual void OnPreviewTouchUp(TouchEventArgs e);protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);protected virtual void OnQueryCursor(QueryCursorEventArgs e);protected virtual void OnRender(DrawingContext drawingContext);protected virtual void OnStylusButtonDown(StylusButtonEventArgs e);protected virtual void OnStylusButtonUp(StylusButtonEventArgs e);protected virtual void OnStylusDown(StylusDownEventArgs e);protected virtual void OnStylusEnter(StylusEventArgs e);protected virtual void OnStylusInAirMove(StylusEventArgs e);protected virtual void OnStylusInRange(StylusEventArgs e);protected virtual void OnStylusLeave(StylusEventArgs e);protected virtual void OnStylusMove(StylusEventArgs e);protected virtual void OnStylusOutOfRange(StylusEventArgs e);protected virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);protected virtual void OnStylusUp(StylusEventArgs e);protected virtual void OnTextInput(TextCompositionEventArgs e);protected virtual void OnTouchDown(TouchEventArgs e);protected virtual void OnTouchEnter(TouchEventArgs e);protected virtual void OnTouchLeave(TouchEventArgs e);protected virtual void OnTouchMove(TouchEventArgs e);protected virtual void OnTouchUp(TouchEventArgs e);protected internal virtual DependencyObject GetUIParentCore();protected internal virtual void OnRenderSizeChanged(SizeChangedInfo info);protected internal override void OnVisualParentChanged(DependencyObject oldParent);&#125; UIElement类代码分析 第一部分 路由事件 UIElement基类定义了大量的路由事件。什么是路由事件？路由事件和xaml的可视化树概念相关，控件的事件被触发后，会沿着这棵树广播，有两个方向，要么往树的根部广播，要么往树的枝叶广播，如果不广播就是直接事件。 所以，路由事件分为冒泡事件和隧道事件，冒泡，是从触发源为出发点，依次传递到父节点，直到最后的根节点。隧道事件是不管谁是触发源，都是从根节点触发，到子节点，直到触发节点。 从空间上来说，冒泡事件和隧道事件是成对出现的。从时间来说，都是先触发隧道事件，然后是冒泡事件。从命名来说，隧道事件都是以Preview开头的事件。 根据命名规则，我们可以大致猜测出一个结果，带Key的基本都是与键盘相关的事件（如按下键位、抬起键位），带Mouse的基本都是与鼠标相关的事件（如左键单击、双击），带Stylus的基本都是与触摸相关的事件，具体用到哪一类型的事件，再详细查阅一下相关说明文档即可。 重点：关于这些事件的回调函数，即以On开头的方法成员，都被声明成了protected virtual，意思是他们都可以被重载，这使得我们在开发业务时更加方便。 第二部分 依赖属性 UIElement基类还定义了大量的依赖属性。前面的章节中，在DependencyObject类中我们简单提到过依赖属性。在这里我们以UIElement基类的Visibility属性为例。 123public Visibility Visibility &#123; get; set; &#125; public static readonly DependencyProperty VisibilityProperty; 上面有两个成员，Visibility是普通的属性成员，VisibilityProperty是WPF的依赖属性成员，以Property结尾的字样作为WPF的依赖属性命名规则。而这两个成员合起来，才能被称为一个完整的依赖属性。这个Visibility 属性表示设置或获取控件的可见性。当我们要设置控件的可见性时，只需要如下设置即可。 12345&lt;TextBlock Text=&quot;WPF中文网&quot; Visibility=&quot;Visible&quot; FontSize=&quot;48&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; Visibility实际上是一个枚举，它包含3个值，分别是Visible、Hidden、Collapsed。其含义分别是显示、隐藏、彻底隐藏（不占布局位置）。 Visibility 状态会影响该元素的所有输入处理。 不可见的元素不会参与命中测试，也不会接收输入事件，即使鼠标位于元素可见时所在的边界上也是如此。 但是在这一节中，我们只是探讨UIElement基类提供了哪些方面的属性，并不详细探讨依赖属性，所以下面我们把目光聚焦到UIElement基类的常用属性上。另外由于WPF中几乎所有控件都继承了这个基类，意思就是说所有的控件都有这些属性可以使用。下面我在描述的时候将采用“控件”两字来解释一些技术细节。 Uid属性:获取或设置控件的唯一标识符，像人们的身份证一样。这个值默认是string.Empty。 Visibility属性：获取或设置控件的可见性。默认是Visible。 ClipToBounds属性：如果该值为true，表示进行裁剪，以适配它的父控件。比如有时候我们外面有一个Panel，里面的控件尺寸太大，势必会“撑破”外面的父控件，为了布局美观，只好削足适履。 Clip属性：用于剪裁区域大小的几何图形。需要注意的是，这个属性和上面的ClipToBounds属性是有区别的。ClipToBounds是裁剪控件自身，Clip是裁剪控件里面的内容。比如Image图像控件，我们在显示一张图时，就可以运用Clip进行裁剪后显示，通常在显示用户头像时裁剪成圆形时使用。如下所示 12345678910&lt;Image Source=&quot;sampleImages\\Waterlilies.jpg&quot; Width=&quot;200&quot; Height=&quot;150&quot; HorizontalAlignment=&quot;Left&quot;&gt; &lt;Image.Clip&gt; &lt;EllipseGeometry RadiusX=&quot;100&quot; RadiusY=&quot;75&quot; Center=&quot;100,75&quot;/&gt; &lt;/Image.Clip&gt;&lt;/Image&gt; SnapsToDevicePixels属性：如果该值为true，表示控件的呈现是否应使用特定于设备的像素设置。意思是开启后可以最大限度的防锯齿效果，默认为false。 IsFocused属性：这是一个只读属性，表示当前控件是否有焦点。 IsEnabled属性：如果该值为true，表示禁用控件，反之启用控件。 IsHitTestVisible属性：获取或设置一个值，该值声明是否可以返回此元素作为其呈现内容的某些部分的点击测试结果。 IsVisible属性：这是一个只读属性，表示当前控件是否显示。 Focusable属性：如果该值为true，表示控件可以得到焦点，大部份内容控件都默认可以获得焦点。 IsKeyboardFocused属性：表示该控件是否具有键盘焦点。 IsMouseOver属性：表示鼠标是否在控件上面。通常在设计控件的样式（Style）时会用到。 IsStylusOver属性：表示触笔指针是否在控件的上方。 IsSealed属性：表示当前类型是否为只读类。 Opacity属性：设置控件的透明度，取值范围是0-1之间的double值。 OpacityMask属性：设置一个画笔，作为控件的蒙板。比如我们给一张图片设置一个掩码，就可以使用ImageBrush这种图片画笔来实现。 12345&lt;Image Height=&quot;150&quot; Width=&quot;200&quot; Source=&quot;sampleImages/Waterlilies.jpg&quot; &gt; &lt;Image.OpacityMask&gt; &lt;ImageBrush ImageSource=&quot;sampleImages/tornedges.png&quot;/&gt; &lt;/Image.OpacityMask&gt;&lt;/Image&gt; AllowDrop属性：表示控件是否允许拖拽操作。 RenderTransform属性：（非常重要）如果要设置控件的移动、缩放、旋转，需要这此属性进行设置。 UIElement类总结 通过上述的代码分析，我们大致可以得出以下结论，UIElement基类为我们提供了一系列的鼠标、键盘和触摸事件，并提供了一些常用的依赖属性。它可以呈现继承它的所有控件，为控件布局时调整位置和大小，响应用户的输入，引发一系列的路由事件，并继承了IAnimatable动画接口，用于支持动画的某些方面。 我们熟悉了UIElement的这些属性和事件之后，实际上意味着我们也熟悉了WPF所有控件的这些属性。下一节，我们将探讨UIElement的子类FrameworkElement。 FrameworkElement基类论重要性，完全不亚于UIElement基类。甚至论起与开发者的“亲密度”，FrameworkElement更像是近水的楼台。 FrameworkElement类FrameworkElement类继承于UIElement类，继承关系是：Object-&gt;DispatcherObject-&gt;DependencyObject-&gt;Visual-&gt;UIElement-&gt;FrameworkElement，它也是WPF控件的众多父类中最核心的基类，从这里开始，继承树开始分支，分别是Shape图形类、Control控件类和Panel布局类三个方向。 FrameworkElement类本质上也是提供了一系列属性、方法和事件。同时又扩展 UIElement 并添加了以下功能： 官方文档 1.布局系统定义： FrameworkElement 为中 UIElement定义为虚拟成员的某些方法提供特定的 WPF 框架级实现。 最值得注意的是， FrameworkElement 会密封某些 WPF 核心级布局替代，并改为提供派生类应替代的 WPF 框架级别的等效项。 例如，密封但 FrameworkElementArrangeCore 提供 ArrangeOverride。 这些更改反映了这样一个事实，即在 WPF 框架级别，有一个可以呈现任何 FrameworkElement 派生类的完整布局系统。 在 WPF 核心级别，将构建基于 WPF 的常规布局解决方案的某些成员已就位，但未定义布局系统的实际引擎。2.逻辑树： 常规 WPF 编程模型通常以元素树的方式表示。 支持将元素树表示为逻辑树，以及支持在标记中定义该树的支持是在 级别实现的 FrameworkElement 。 但请注意， FrameworkElement 故意不定义内容模型，并将该责任留给派生类。3.对象生存期事件： 了解何时初始化元素 (调用构造函数) 或首次将元素加载到逻辑树中时，这通常很有用。 FrameworkElement 定义多个与对象生存期相关的事件，这些事件为涉及元素的代码隐藏操作（例如添加更多子元素）提供有用的挂钩。4.支持数据绑定和动态资源引用： 对数据绑定和资源的属性级支持由 DependencyProperty 类实现，并体现在属性系统中，但解析存储为 Expression (数据绑定和动态资源的编程构造) 中存储的成员值的能力由 FrameworkElement实现。5.风格：FrameworkElement 定义 Style 属性。 但是， FrameworkElement 尚未定义对模板的支持或支持修饰器。 这些功能由控件类（如 和 ContentControl）Control引入。6.更多动画支持： 某些动画支持已在 WPF 核心级别定义，但 FrameworkElement 通过实现 BeginStoryboard 和相关成员扩展了此支持。 我们来看看这个基类的结构定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class FrameworkElement : UIElement, IFrameworkInputElement, IInputElement, ISupportInitialize, IHaveResources, IQueryAmbient&#123; public static readonly DependencyProperty StyleProperty; public static readonly DependencyProperty MaxHeightProperty; public static readonly DependencyProperty FlowDirectionProperty; public static readonly DependencyProperty MarginProperty; public static readonly DependencyProperty HorizontalAlignmentProperty; public static readonly DependencyProperty VerticalAlignmentProperty; public static readonly DependencyProperty FocusVisualStyleProperty; public static readonly DependencyProperty CursorProperty; public static readonly DependencyProperty ForceCursorProperty; public static readonly RoutedEvent UnloadedEvent; public static readonly DependencyProperty ToolTipProperty; public static readonly DependencyProperty ContextMenuProperty; public static readonly RoutedEvent ToolTipOpeningEvent; public static readonly RoutedEvent ToolTipClosingEvent; public static readonly RoutedEvent ContextMenuOpeningEvent; public static readonly RoutedEvent ContextMenuClosingEvent; public static readonly DependencyProperty MinHeightProperty; public static readonly DependencyProperty HeightProperty; public static readonly RoutedEvent LoadedEvent; public static readonly DependencyProperty MinWidthProperty; public static readonly DependencyProperty MaxWidthProperty; public static readonly DependencyProperty OverridesDefaultStyleProperty; public static readonly DependencyProperty UseLayoutRoundingProperty; public static readonly DependencyProperty BindingGroupProperty; public static readonly DependencyProperty LanguageProperty; public static readonly DependencyProperty NameProperty; public static readonly DependencyProperty TagProperty; public static readonly DependencyProperty DataContextProperty; public static readonly RoutedEvent RequestBringIntoViewEvent; public static readonly RoutedEvent SizeChangedEvent; public static readonly DependencyProperty ActualWidthProperty; public static readonly DependencyProperty ActualHeightProperty; public static readonly DependencyProperty LayoutTransformProperty; public static readonly DependencyProperty InputScopeProperty; public static readonly DependencyProperty WidthProperty; protected internal static readonly DependencyProperty DefaultStyleKeyProperty; public FrameworkElement(); public Transform LayoutTransform &#123; get; set; &#125; public double Width &#123; get; set; &#125; public double MinWidth &#123; get; set; &#125; public double MaxHeight &#123; get; set; &#125; public double Height &#123; get; set; &#125; public double MinHeight &#123; get; set; &#125; public double ActualHeight &#123; get; &#125; public double MaxWidth &#123; get; set; &#125; public double ActualWidth &#123; get; &#125; public TriggerCollection Triggers &#123; get; &#125; public object Tag &#123; get; set; &#125; public string Name &#123; get; set; &#125; public XmlLanguage Language &#123; get; set; &#125; public BindingGroup BindingGroup &#123; get; set; &#125; public object DataContext &#123; get; set; &#125; public ResourceDictionary Resources &#123; get; set; &#125; public DependencyObject TemplatedParent &#123; get; &#125; public bool UseLayoutRounding &#123; get; set; &#125; public FlowDirection FlowDirection &#123; get; set; &#125; public InputScope InputScope &#123; get; set; &#125; public Thickness Margin &#123; get; set; &#125; public Style Style &#123; get; set; &#125; public VerticalAlignment VerticalAlignment &#123; get; set; &#125; public bool OverridesDefaultStyle &#123; get; set; &#125; public HorizontalAlignment HorizontalAlignment &#123; get; set; &#125; public ContextMenu ContextMenu &#123; get; set; &#125; public object ToolTip &#123; get; set; &#125; public DependencyObject Parent &#123; get; &#125; public bool IsInitialized &#123; get; &#125; public bool ForceCursor &#123; get; set; &#125; public Cursor Cursor &#123; get; set; &#125; public Style FocusVisualStyle &#123; get; set; &#125; public bool IsLoaded &#123; get; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal InheritanceBehavior InheritanceBehavior &#123; get; set; &#125; protected internal virtual IEnumerator LogicalChildren &#123; get; &#125; protected internal object DefaultStyleKey &#123; get; set; &#125; public event ToolTipEventHandler ToolTipClosing; public event ToolTipEventHandler ToolTipOpening; public event RoutedEventHandler Unloaded; public event DependencyPropertyChangedEventHandler DataContextChanged; public event SizeChangedEventHandler SizeChanged; public event RequestBringIntoViewEventHandler RequestBringIntoView; public event EventHandler&lt;DataTransferEventArgs&gt; SourceUpdated; public event EventHandler&lt;DataTransferEventArgs&gt; TargetUpdated; public event RoutedEventHandler Loaded; public event EventHandler Initialized; public event ContextMenuEventHandler ContextMenuClosing; public event ContextMenuEventHandler ContextMenuOpening; public static FlowDirection GetFlowDirection(DependencyObject element); public static void SetFlowDirection(DependencyObject element, FlowDirection value); public bool ApplyTemplate(); public virtual void BeginInit(); public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior, bool isControllable); public void BeginStoryboard(Storyboard storyboard); public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior); public void BringIntoView(); public void BringIntoView(Rect targetRectangle); public virtual void EndInit(); public object FindName(string name); public object FindResource(object resourceKey); public BindingExpression GetBindingExpression(DependencyProperty dp); public sealed override bool MoveFocus(TraversalRequest request); public virtual void OnApplyTemplate(); public sealed override DependencyObject PredictFocus(FocusNavigationDirection direction); public void RegisterName(string name, object scopedElement); public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding); public BindingExpression SetBinding(DependencyProperty dp, string path); public void SetResourceReference(DependencyProperty dp, object name); public bool ShouldSerializeResources(); public bool ShouldSerializeStyle(); public bool ShouldSerializeTriggers(); public object TryFindResource(object resourceKey); public void UnregisterName(string name); public void UpdateDefaultStyle(); protected sealed override void ArrangeCore(Rect finalRect); protected virtual Size ArrangeOverride(Size finalSize); protected override Geometry GetLayoutClip(Size layoutSlotSize); protected override Visual GetVisualChild(int index); protected sealed override Size MeasureCore(Size availableSize); protected virtual Size MeasureOverride(Size availableSize); protected virtual void OnContextMenuClosing(ContextMenuEventArgs e); protected virtual void OnContextMenuOpening(ContextMenuEventArgs e); protected override void OnGotFocus(RoutedEventArgs e); protected virtual void OnInitialized(EventArgs e); protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e); protected virtual void OnToolTipClosing(ToolTipEventArgs e); protected virtual void OnToolTipOpening(ToolTipEventArgs e); protected internal void AddLogicalChild(object child); protected internal DependencyObject GetTemplateChild(string childName); protected internal override DependencyObject GetUIParentCore(); protected internal override void OnRenderSizeChanged(SizeChangedInfo sizeInfo); protected internal virtual void OnStyleChanged(Style oldStyle, Style newStyle); protected internal override void OnVisualParentChanged(DependencyObject oldParent); protected internal virtual void ParentLayoutInvalidated(UIElement child); protected internal void RemoveLogicalChild(object child); &#125; 属性分析 1.LayoutTransform 属性：获取或设置在执行布局时应应用于此元素的图形转换。这个属性与UIElement类中的RenderTransform属性有相似之处，所以我们在此将两者进行对比说明一下。两个属性都是Transform类型，而Transform是一个抽象类，这个类可以实现控件在平面中的各种转换，包括 旋转 (System.Windows.Media.RotateTransform) 缩放 (System.Windows.Media.ScaleTransform)、 倾斜 (System.Windows.Media.SkewTransform) 、 平移 (System.Windows.Media.TranslateTransform)。 虽然两个属性都可以达到控件的变换效果，但是两者还是有区别的。LayoutTransform属性是在控件布局之前对控件进行变换，而RenderTransform属性是在布局结束后执行控件的变换，LayoutTransform开销比RenderTransform要大，所以，尽量使用RenderTransform属性去实现控件的变换。（我们会在后面专门探讨控件的变换） 2.Width属性：这是表示控件的宽度。与之相关的还有以下几个属性。 ActualWidth：获取此元素的呈现宽度。只读属性。 MaxWidth：获取或设置一个控件的最大宽度。 MinWidth：获取或设置一个控件的最小宽度。 3.Height属性：这是表示控件的高度，与之相关的还有以下几个属性。 ActualHeight：获取此元素的呈现高度。只读属性。 MaxHeight：获取或设置一个控件的最大高度。 MinHeight：获取或设置一个控件的最小高度。 4.Tag属性：这个属性非常重要，它是object类型，意味着可以保存任意类型的对象值。它就像FrameworkElement类身上的一个小口袋，但确能容纳万物。我们通常会将一些与控件相关的数据临时存放在Tag属性中，当把控件作为参数传递时，小口袋里面的对象也随之传递过去了。 5.Name属性：获取或设置控件的标识名称。在同一个窗体、页、用户控件中，Name标识是唯一的。设置了控件的名称后，我们就可以在后端代码直接以这个标识去引用控件。 6.Margin属性：获取或设置控件的外边距。如下所示，我们定义了一个button的margin，距离左边、上边、右边和下边的像素分别是20、40、60、80。 123 &lt;Grid&gt; &lt;Button Content=&quot;WPF中文网&quot; Margin=&quot;20 40 60 80&quot; /&gt;&lt;/Grid&gt; Padding属性说明 与Margin相对应的是Padding，表示设置控件的内边距。但是这个属性并不在FrameworkElement中，而在Control类中，从本节第一张图所示，说明只有内容控件才具有Padding，而Shape和Panel是没有Padding属性的。 7.HorizontalAlignment属性：设置控件的水平对齐方式。这个对齐方式是相对于父元素而言的，比如我们有一个Button控件，在外面还包裹了一层Grid控件，那么，设置Button控件的HorizontalAlignment属性，可以将Button控件分别显示在Grid控件的左边、中间、右边三个位置。 8.VerticalAlignment属性：设置控件的垂直对齐方式。与HorizontalAlignment属性类似，只是对方的方向不同，可以设置控件在垂直方向上是居于顶部、中间、还是底部三个位置。 总结：上述两个属性的值都是枚举型，它们都有一个共同的值，那就是stretch，表示是拉伸的方式填充父元素的布局。 9.ToolTip属性：获取或设置用户界面 (UI) 中为此元素显示的工具提示对象。指鼠标移到控件上方时显示的提示内容，它是一个object类型，意味着可以显示任意布局外观。 10.Parent属性：获取此元素的逻辑父元素。它是一个只读属性。 接下来，我们将介绍几个比较重要的属性，这些属性是WPF框架中非常核心的知识概念，需要单独形成章节来学习，在这里，我们只是通过这些属性来引出其概念。 WPF样式（Style） 什么是样式？简单来说，是指控件呈现时的样子。比如我们上班时会穿上工作服，休假时会穿上更个性化的衣服，我还是那个我，但是身上的衣服却不同，不管是颜色、款式，甚至包括我们的头饰、妆容，都会有所不同。 对于控件而言，同样都是button按钮，有的按钮是方的，有的是圆的，有的是蓝色，有的是红色，有的有文字，有的有图标，如果做到这些不同的样式呢？答案是Style属性。 11.Style属性：获取或设置此元素呈现时所使用的样式。（关于Style样式我们会专门拿一章节来探讨） 与Style相关的还有一个属性，叫FocusVisualStyle，顾名思义，控件在获得焦点时的样式。 WPF资源（ResourceDictionary） 什么是资源？资源，也就是资源字典，也就是ResourceDictionary类，它提供一个哈希表&#x2F;字典实现，其中包含组件所使用的 WPF 资源以及 WPF 应用程序的其他元素。我们可以把WPF的控件、窗体、Application应用所用到的一切资源都放在其中，将多个ResourceDictionary元素合并起来形成一个ResourceDictionary元素（ResourceDictionary也是一个隐式集合）。所以FrameworkElement类设计一个资源属性。 12.Resources 属性：获取或设置本地定义的资源字典。关于Resources资源我们会专门拿一章节来探讨） WPF的数据上下文（DataContext） 我们曾经在前面的《DependencyObject类》一文中提到过数据驱动模式，控件的值绑定某个“变量”，当“变量”的值发生改变，控件的值也跟着改变，反过来说，当控件的值发生改变，“变量”的值也跟着改变。那么这个特指的“变量”是什么？它和我们今天要介绍的数据上下文有什么关系？ 答案是，这个“变量”其实也是一个属性，且必须是一个属性（重点），它是谁的属性？WPF说，它是某个ViewModel类的属性。 假定我们有一个View窗体，窗体有一个TextBox控件；又假如我们还有一个ViewModel实体，这个实体中有一个叫Name的属性。如果我们要将TextBox控件的Text属性和ViewModel实体的Name属性成功的建立绑定关系，必备的条件是什么？ 首先，由于View窗体继承于FrameworkElement类，所以每个窗体（或控件）都有一个叫DataContext的数据上下文属性。所以必备的条件是：**ViewModel实体必须先赋值给View窗体的DataContext，ViewModel的Name属性才能绑定到TextBox控件的Text属性。**换言之，领导之间要先搭好桥，下属和下属才好配合工作。这就是DataContext的概念和用途。（关于DataContext数据上下文我们会专门拿一章节来探讨） 13.DataContext属性：获取或设置元素参与数据绑定时的数据上下文。 14.ContextMenu属性：设置与获取控件的上下文菜单 ，就是鼠标在控件上右键时弹出来的菜单。 15.Cursor属性：获取或设置在鼠标指针位于此元素上时显示的光标。 友情提示 上述所介绍的属性，是WPF中所有控件都有的属性哦，所以，学一个FrameworkElement类，就把所有控件都学了30%呢。——重庆教主 事件分析 FrameworkElement类提供了12个事件，一般比较常用的是：Initialized、Loaded、Unloaded、SizeChanged等事件。 方法成员 FrameworkElement类还提供了一些方法成员。 1.FindName(String)：表示查找某个元素。比如我们在窗体中要查找某个控件。 2.FindResource(Object)：查找某个资源。如果在调用对象上找不到该资源，则接下来搜索逻辑树中的父元素，然后搜索应用程序、主题，最后搜索系统资源。实在找不到就抛出异常。 3.TryFindResource(Object)：尝试去找某个资源。建议使用这个方法。 4.RegisterName (string , object );注册控件的名称到父控件上。 12345678button2 = new Button();button2.Name = &quot;Button2&quot;; // 注册button2的名称到myMainPanel控件上myMainPanel.RegisterName(button2.Name, button2);button2.Content = &quot;Button 2&quot;;button2.Click += new RoutedEventHandler(button2Clicked);myMainPanel.Children.Add(button2); 5.SetBinding(DependencyProperty, BindingBase)和SetBinding(DependencyProperty, String)，这两个成员都和绑定相关，我们将在后面做专题介绍。 最后，我们来看哪些类会继承这个FrameworkElement基类，以便于了解我们接下来要学哪些内容。 Microsoft.Windows.Themes.BulletChromeMicrosoft.Windows.Themes.ScrollChromeSystem.Windows.Controls.AccessTextSystem.Windows.Controls.AdornedElementPlaceholderSystem.Windows.Controls.ContentPresenterSystem.Windows.Controls.ControlSystem.Windows.Controls.DecoratorSystem.Windows.Controls.ImageSystem.Windows.Controls.InkCanvasSystem.Windows.Controls.ItemsPresenterSystem.Windows.Controls.MediaElementSystem.Windows.Controls.PageSystem.Windows.Controls.PanelSystem.Windows.Controls.Primitives.DocumentPageViewSystem.Windows.Controls.Primitives.GridViewRowPresenterBaseSystem.Windows.Controls.Primitives.PopupSystem.Windows.Controls.Primitives.TickBarSystem.Windows.Controls.Primitives.TrackSystem.Windows.Controls.TextBlockSystem.Windows.Controls.ToolBarTraySystem.Windows.Controls.Viewport3DSystem.Windows.Documents.AdornerSystem.Windows.Documents.AdornerLayerSystem.Windows.Documents.DocumentReferenceSystem.Windows.Documents.FixedPageSystem.Windows.Documents.GlyphsSystem.Windows.Documents.PageContentSystem.Windows.Interop.HwndHostSystem.Windows.Shapes.Shape 好，关于FrameworkElement类的成员，我们就先讲这么多，在介绍完WPF的父类之后，下一章，我们正式开始学习WPF控件。 布局控件布局控件概述在WPF中，布局的方式十分丰富，有按表格布局的Grid和UniformGrid栅格控件，有类似Winform拖放的Canvas控件，有按照垂直或水平排列的StackPanel控件，也有按照东西南北中方位排列的DockPanel控件，还有以瀑布流方式WrapPanel控件，以及按Tab页切换显示的TabControl控件。微软将它们抽象成Panel基类，并让这个基类继承于FrameworkElement类。 控件名称 布局方式 Grid 网格，根据自定义行和列来设置控件的布局 StackPanel 栈式面板，包含的元素在竖直或水平方向排成一条直线 WrapPanel 自动折行面板，包含的元素在排满一行后，自动换行 DockPanel 泊靠式面板，内部的元素可以选择泊靠方向 UniformGrid 网格,UniformGrid就是Grid的简化版，每个单元格的大小相同。 Canvas 画布，内部元素根据像素为单位绝对坐标进行定位 Border 装饰的控件，此控件用于绘制边框及背景，在Border中只能有一个子控件 Panel基类Panel其实是一个抽象类，不可以实例化，WPF所有的布局控件都从Panel继承而来，所以我们在学习布局控件之前，要先了解一下这个类。首先看一下它的定义： 1234567891011121314151617181920212223242526272829public abstract class Panel : FrameworkElement, IAddChild&#123; public static readonly DependencyProperty BackgroundProperty; public static readonly DependencyProperty IsItemsHostProperty; public static readonly DependencyProperty ZIndexProperty; protected Panel(); public bool HasLogicalOrientationPublic &#123; get; &#125; public Orientation LogicalOrientationPublic &#123; get; &#125; public bool IsItemsHost &#123; get; set; &#125; public UIElementCollection Children &#123; get; &#125; public Brush Background &#123; get; set; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal UIElementCollection InternalChildren &#123; get; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; protected internal virtual Orientation LogicalOrientation &#123; get; &#125; protected internal virtual bool HasLogicalOrientation &#123; get; &#125; public static int GetZIndex(UIElement element); public static void SetZIndex(UIElement element, int value); public bool ShouldSerializeChildren(); protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent); protected override Visual GetVisualChild(int index); protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost); protected override void OnRender(DrawingContext dc); protected internal override void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved); &#125; 从它的代码定义来看，它继承于FrameworkElement基类和IAddChild接口。所以，所有 Panel 元素都支持 FrameworkElement 定义的基本大小调整和定位属性，包括 Height、Width、HorizontalAlignment、VerticalAlignment、Margin 和 LayoutTransform。 它有一个Background属性，意味着所有的布局控件都可以设置背景颜色。另外，它还有一个Children属性，这是一个集合属性，也就是说，所有的布局控件都可以添加多个子元素。这一点从它继承的IAddChild接口也能得到印证。 12345678910namespace System.Windows.Markup&#123; //提供了一种分析允许混合的子元素或文本的元素的方法。 public interface IAddChild &#123; //添加子对象。 void AddChild(object value); //将节点的文本内容添加到对象。 void AddText(string text); &#125; Panel提供了GetZIndex和SetZIndex方法成员，分别表示获取某个元素的ZIndex顺序和设置某个元素的ZIndex顺序。 什么是ZIndex？这是Panel提供的一个附加属性。假如一个单行单列的Grid布局控件中有两个Button,正常情况下，这两个Button都会以撑满Grid的方式呈现在Grid中，那么，到底哪一个Button在上面，哪一个Button在下面呢？就看这两个Button的Panel.ZIndex附加属性的值，值越大越在上面，而值较小的那个Button将被上面的Button遮盖，从而在视觉上，用户只能看到一个Button。 附加属性 附加属性的一个用途是允许子元素存储实际上由父元素定义的属性的唯一值。 此功能的一项应用是让子元素通知父级它们希望如何在用户界面 (UI) 中呈现，这对应用程序布局非常有用。 1234&lt;Grid &gt; &lt;Button Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20 40 60 80&quot; Padding=&quot;50&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20 40 60 80&quot; Padding=&quot;50&quot; /&gt;&lt;/Grid&gt; 在上面的示例中，正常情况下，会显示“WPF中文网2”按钮，但是我们故意叫其Panel.ZIndex&#x3D;0，从而小于上面那个按钮的属性值，所以显示了“WPF中文网1”按钮。 WPF 提供了一套全面的派生 Panel 实现，可实现许多复杂的布局。这里有一个非常非常需要注意的事项，那就是Panel的Background属性。有时候我们希望在布局控件上实现鼠标点击事件的获取，请记得一定要给Background属性设置一个颜色值，如果不希望有具体的颜色，那就设置成Transparent 。不然，您会踩坑的！因为布局控件的Background属性没有值时，是不能引发鼠标相关事件的。 深入探究Panel类 Panel作为布局控件的基类，拥有一个叫Children的属性，这个属性的类型是UIElementCollection。我们来看一下它的结构： 1234567891011121314151617181920212223242526public class UIElementCollection : IList, ICollection, IEnumerable&#123; public UIElementCollection(UIElement visualParent, FrameworkElement logicalParent); public virtual UIElement this[int index] &#123; get; set; &#125; public virtual int Capacity &#123; get; set; &#125; public virtual object SyncRoot &#123; get; &#125; public virtual bool IsSynchronized &#123; get; &#125; public virtual int Count &#123; get; &#125; public virtual int Add(UIElement element); public virtual void Clear(); public virtual bool Contains(UIElement element); public virtual void CopyTo(UIElement[] array, int index); public virtual void CopyTo(Array array, int index); public virtual IEnumerator GetEnumerator(); public virtual int IndexOf(UIElement element); public virtual void Insert(int index, UIElement element); public virtual void Remove(UIElement element); public virtual void RemoveAt(int index); public virtual void RemoveRange(int index, int count); protected void ClearLogicalParent(UIElement element); protected void SetLogicalParent(UIElement element); &#125; 从它所定义的方法来看，我们会看到一些添加或移除某个元素的方法成员，例如Add，Insert，Remove，Contains等等，而这些方法的参数都有一个叫UIElement的形参，说明什么问题？只要继承于UIElement的类（或控件），都可以添加到Panel或Panel子类的Children中，从而在前端呈现出来。 WPF提供了六个用于UI布局的Panel子类，分别是：Grid、StackPanel、WrapPanel、DockPanel、 VirtualizingStackPanel和 Canvas。 这些面板元素易于使用、功能齐全并且可扩展，足以适用于大多数应用程序。 一个Panel 的呈现就是测量和排列子控件，然后在屏幕上绘制它们。所以在布局的过程中会经过一系列的计算，那么子控件越多，执行的计算次数就越多，则性能就会变差。如果不需要进行复杂的布局，则尽量少用复杂布局控件（如 Grid和自定义复杂的Panel）；如果能简单布局实现就尽量使用构造相对简单的布局（如 Canvas、UniformGrid等），这种布局可带来更好的性能。 如果有可能，我们应尽量避免调用 UpdateLayout方法。 布局系统为Panel中的每个子控件完成两个处理过程：测量处理过程（Measure）和排列处理过程（Arrange）。每个子 Panel 均提供自己的 MeasureOverride 和 ArrangeOverride 方法，以实现自己特定的布局行为。 每个派生 Panel 元素都以不同方式处理大小调整约束。 了解 Panel 如何处理水平或垂直方向上的约束可以使布局更容易预测。 控件名称 x维度 y维度 Grid 约束 约束，Auto 应用于行和列的情形除外 StackPanel（垂直） 约束 按内容约束 StackPanel（水平） 按内容约束 约束 DockPanel 约束 约束 WrapPanel 按内容约束 按内容约束 Canvas 按内容约束 按内容约束 Grid控件（网格布局）Grid控件其实是一个窗体的默认控件，我们创建一个WPF应用程序后，其主窗体里面会有一个Grid控件。我们先来看一下此类的结构定义： 1234567891011121314151617181920212223242526272829303132333435public class Grid : Panel, IAddChild&#123; public static readonly DependencyProperty ShowGridLinesProperty; public static readonly DependencyProperty ColumnProperty; public static readonly DependencyProperty RowProperty; public static readonly DependencyProperty ColumnSpanProperty; public static readonly DependencyProperty RowSpanProperty; public static readonly DependencyProperty IsSharedSizeScopeProperty; public Grid(); public ColumnDefinitionCollection ColumnDefinitions &#123; get; &#125; public bool ShowGridLines &#123; get; set; &#125; public RowDefinitionCollection RowDefinitions &#123; get; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; public static int GetColumn(UIElement element); public static int GetColumnSpan(UIElement element); public static bool GetIsSharedSizeScope(UIElement element); public static int GetRow(UIElement element); public static int GetRowSpan(UIElement element); public static void SetColumn(UIElement element, int value); public static void SetColumnSpan(UIElement element, int value); public static void SetIsSharedSizeScope(UIElement element, bool value); public static void SetRow(UIElement element, int value); public static void SetRowSpan(UIElement element, int value); public bool ShouldSerializeColumnDefinitions(); public bool ShouldSerializeRowDefinitions(); protected override Size ArrangeOverride(Size arrangeSize); protected override Visual GetVisualChild(int index); protected override Size MeasureOverride(Size constraint); protected internal override void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved); &#125; Grid有两个非常关键的属性ColumnDefinitions和RowDefinitions，分别表示列的数量集合和行的数量集合。ColumnDefinitions集合中的元素类型是ColumnDefinition类，RowDefinitions集合中元素类型是RowDefinition类。默认的Gridr控件没有定义行数和列数，也就是说，Grid默认情况下，行数和列数都等于1，那么它就只有一个单元格。 1234&lt;Grid &gt; &lt;Button Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20 40 60 80&quot; Padding=&quot;50&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20 40 60 80&quot; Padding=&quot;50&quot; /&gt;&lt;/Grid&gt; 如上述代码所示，此时的Grid因为只有一个单元格，而Grid的Children属性里面有两个Button，势必有一个Button会被遮盖。假如我们希望两个按钮同时显示，应该怎么办呢？这时就有了两个选格，第一，两个Button左右排列显示，第二，两个Button上下排列显示。 一、左右排列 12345678&lt;Grid &gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; Padding=&quot;50&quot; /&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; Padding=&quot;50&quot; /&gt;&lt;/Grid&gt; 代码分析 我们在Grid控件的ColumnDefinitions属性增加了两个ColumnDefinition对象，如果分别设置了两个按钮的Grid.Column附加属性，指示两个Button分别显示在第一列和第二列，从而实现了左右排列，具两个按钮分别占据了50%的区域。这是因为我们并没有指定两个ColumnDefinition对象的宽度。 二、上下排列 12345678&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; Padding=&quot;50&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; Padding=&quot;50&quot; /&gt; &lt;/Grid&gt; 要实现上下排列，我们只需要在Grid控件的RowDefinitions中增加两行元素即可，即RowDefinition对象。同时，指定每个Button显示在哪一行，例如Grid.Row&#x3D;”0”，表示显示在第一行。 三、上下左右排列 现在我们将左右排列和上下排列两种模式合并起来，看看会发生什么状况。 1234567891011121314&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 我们创建了4个Button，并分别设置了它们所在的行和列，至此，网格的布局效果跃然纸上。以上就是Grid控件的基本用法。 深入探究Grid控件 在实际开发中，我们可能会遇到更复杂的用法，比如第一行只显示一个button，需要跨列显示，或者第一列只占整个Grid的20%的宽度等等，这就需要了解ColumnDefinition和RowDefinition。另外，我们需要显示Grid的网格线，又该如何实现呢？接下来，我们一一去探寻。 四、跨列排列 12345678910111213&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; Grid.ColumnSpan=&quot;2&quot;/&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 我们在原有基础上删掉了一个按钮，并将第一个按钮的Grid.ColumnSpan附加属性设置为2，表示从第0列往右跨两列，正好就呈现出图中的效果。您也可以尝试跨行显示，只需要设置按钮的Grid.RowSpan属性。 五、固定列宽 1234567891011121314&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;120&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 如图所示，我们只需要设置第一行ColumnDefinition的Width属性，让其宽度固定为120像素，那么第二列的宽度等于Grid的宽度减去120像素，其内部的Button宽度也随之自适应。这就是WPF布局自适应的好处。 六、调整行高和列宽 Grid控件的行高和列宽的设置十分丰富，了解它们的用法，有助于设计出更出色的布局。 名称 说明 绝对设置尺寸 使用设备无关单位准确地设置尺寸，就是给一个实际的数字，但通常将此值指定为整数（像素）。如： 自动设置尺寸 值为Auto，实际作用就是取实际控件所需的最小值，每行和每列的尺寸刚好满足需要，这是最有用的尺寸设置方式。如： 按比例设置设置尺寸 按比例将空间分割到一组行和列中。这是对所有行和列的标准设置。通常值为或N，实际作用就是取尽可能大的值，当某一列或行被定义为则是尽可能大，当出现多列或行被定义为则是代表几者之间按比例方设置尺寸。如： 指定权重，即第2列的宽度是第1列的两倍 七、Grid显示网格线 1234567891011121314&lt;Grid ShowGridLines=&quot;True&quot; Margin=&quot;5&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;120&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 只需要设置Grid的ShowGridLines&#x3D;True，就可以显示Grid的网格线，但是这种虚线效果并不友好，我们还有曲线救国的方案。 1234567891011121314151617&lt;Grid Margin=&quot;5&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;120&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Border Grid.Row=&quot;0&quot; Grid.RowSpan=&quot;2&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; BorderBrush=&quot;Gray&quot; BorderThickness=&quot;1&quot;/&gt; &lt;Border Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; BorderBrush=&quot;Gray&quot; BorderThickness=&quot;0 0 0 1&quot;/&gt; &lt;Border Grid.Row=&quot;0&quot; Grid.RowSpan=&quot;2&quot; Grid.Column=&quot;0&quot; BorderBrush=&quot;Gray&quot; BorderThickness=&quot;0 0 1 0&quot;/&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网1&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网2&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;WPF中文网3&quot; Panel.ZIndex=&quot;1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;WPF中文网4&quot; Panel.ZIndex=&quot;0&quot; Margin=&quot;20&quot; /&gt;&lt;/Grid&gt; 我们在Grid内部增加了3个Border，第一个Border用来显示外边框，第二个Border显示中间的横线，第三个Border显示中间的竖线，这时所用的知识点几乎都是Grid的跨行和跨列属性，另外还有边框颜色刷子BorderBrush和边框厚度BorderThickness。 总结 Grid控件绝对是WPF中所有布局控件中最好用的一个，因为它自适应屏幕的宽度，最关键的一点是，它在呈现时，其ActualWidth实际宽度和ActualHeight实际高度会有一个计算值，我们在业务开发中，有时候要根据父控件的实际宽度和高度来计算子控件的呈现位置和大小。 除了Grid这种网格化的布局，下面我们将介绍另一种布局方式——均分布局 UniformGrid控件（均分布局）UniformGrid和Grid有些相似，只不过UniformGrid的每个单元格面积都是相等的，不管是横向的单元格，或是纵向的单元格，它们会平分整个UniformGrid。我们先看看它的结构定义： 12345678910111213141516public class UniformGrid : Panel&#123; public static readonly DependencyProperty FirstColumnProperty; public static readonly DependencyProperty ColumnsProperty; public static readonly DependencyProperty RowsProperty; public UniformGrid(); public int FirstColumn &#123; get; set; &#125; public int Columns &#123; get; set; &#125; public int Rows &#123; get; set; &#125; protected override Size ArrangeOverride(Size arrangeSize); protected override Size MeasureOverride(Size constraint); &#125; UniformGrid控件提供了3个属性，分别是FirstColumn、Columns 、Rows 。FirstColumn表示第一行要空几个单元格，后面两个属性分别用于设置行数和列数。接下来我们以实际的例子来分析这3个属性的用法。 123456&lt;UniformGrid&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;2&quot;/&gt;&lt;/UniformGrid&gt; 这是我们没有UniformGrid的属性的效果，它会根据子元素的数量和UniformGrid自身的尺寸来决定行数和列数。 123456&lt;UniformGrid FirstColumn=&quot;1&quot; Rows=&quot;3&quot; Columns=&quot;3&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;2&quot;/&gt;&lt;/UniformGrid&gt; 我们故意设计了当前UniformGrid为3行3列，同时设置第一行第一个单元格保持空白，于是我们就看到了上图中的效果。 UniformGrid控件使用非常简单方便，通常用于局部的布局。 StackPanel控件（栈式布局）StackPanel用于水平或垂直堆叠子元素。也就是说，StackPanel同样也有一个Children属性，而Children集合中的元素呈现在界面上时，只能是按水平或垂直方式布局。我们先来看看它的结构定义： 1234567891011121314151617181920212223242526272829303132333435363738public class StackPanel : Panel, IScrollInfo, IStackMeasure&#123; public static readonly DependencyProperty OrientationProperty; public StackPanel(); public double HorizontalOffset &#123; get; &#125; public double ViewportHeight &#123; get; &#125; public double ViewportWidth &#123; get; &#125; public double ExtentHeight &#123; get; &#125; public double ExtentWidth &#123; get; &#125; public bool CanVerticallyScroll &#123; get; set; &#125; public bool CanHorizontallyScroll &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; public double VerticalOffset &#123; get; &#125; public ScrollViewer ScrollOwner &#123; get; set; &#125; protected internal override Orientation LogicalOrientation &#123; get; &#125; protected internal override bool HasLogicalOrientation &#123; get; &#125; public void LineDown(); public void LineLeft(); public void LineRight(); public void LineUp(); public Rect MakeVisible(Visual visual, Rect rectangle); public void MouseWheelDown(); public void MouseWheelLeft(); public void MouseWheelRight(); public void MouseWheelUp(); public void PageDown(); public void PageLeft(); public void PageRight(); public void PageUp(); public void SetHorizontalOffset(double offset); public void SetVerticalOffset(double offset); protected override Size ArrangeOverride(Size arrangeSize); protected override Size MeasureOverride(Size constraint); &#125; StackPanel提供了一些属性和方法，最常用的是Orientation枚举属性，用于设置子控件在StackPanel内部的排列方式，分别是水平排列（Horizontal）和垂直排列（Vertical）。默认值是垂直排列（Vertical）。 一、水平排列 123456&lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;20&quot; /&gt;&lt;/StackPanel&gt; 请注意，当StackPanel子元素处于垂直排列时，此时子元素的宽度默认与StakcPanel的宽度保持一致，但是子元素的高度是与其自身的高度自适应显示。 二、垂直排列 123456&lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;20&quot; /&gt;&lt;/StackPanel&gt; 请注意，当StackPanel子元素处于水平排列时，此时子元素的高度默认与StakcPanel的高度保持一致，但是子元素的宽度是与其自身的宽度自适应显示。 深入探究StackPanel控件 可以利用子控件的HorizontalAlignment属性或VerticalAlignment来设置子控件在StackPanel内部的显示位置，比如在垂直排列布局模式下，可以设置HorizontalAlignment属性值，Left表示显示在左则，Right显示在右则，Center则居中显示，Stretch表示拉伸填充显示。 需要注意的是，由于WPF的控件布局都是采用自适应计算每个控件的位置，所以在设置了HorizontalAlignment或VerticalAlignment后，子控件的宽度和高度都会重新计算，主要是根据自身内容的尺寸计算。 12345678910111213&lt;ScrollViewer&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Left&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Right&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;20&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网6&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网7&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网8&quot; Margin=&quot;20&quot; /&gt; &lt;Button Content=&quot;WPF中文网9&quot; Margin=&quot;20&quot; /&gt; &lt;/StackPanel&gt;&lt;/ScrollViewer&gt; 于是，我们可以看到上图中前三行的按钮都是根据自身内容的宽高自适应绘制的。另外，如果StackPanel内部的子控件太多，则需要配合滚动条容器ScrollViewer控件。 和StackPanel类似的控件，还有两个，分别是WrapPanel和DockPanel。下一节，我们将探讨WrapPanel控件。 WrapPanel控件（瀑布流布局）WrapPanel控件表示将其子控件从左到右的顺序排列，如果第一行显示不了，则自动换至第二行，继续显示剩余的子控件。我们来看看它的结构定义： 12345678910111213141516public class WrapPanel : Panel&#123; public static readonly DependencyProperty ItemWidthProperty; public static readonly DependencyProperty ItemHeightProperty; public static readonly DependencyProperty OrientationProperty; public WrapPanel(); public double ItemWidth &#123; get; set; &#125; public double ItemHeight &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; protected override Size ArrangeOverride(Size finalSize); protected override Size MeasureOverride(Size constraint); &#125; 这个控件比较简单，只提供了3个属性，分别是Orientation代表子控件的排列方向，ItemWidth代表子控件的（最大）宽度，ItemHeight代表子控件的（最大）高度。默认的排列方向是水平方向。 一、水平排列 123456789101112&lt;WrapPanel Orientation=&quot;Horizontal&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Left&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Right&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网6&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网7&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网8&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网9&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网10&quot; Margin=&quot;5&quot; /&gt;&lt;/WrapPanel&gt; 由上图所示，我们在WrapPanel的Children属性中放了10个Button，分成了两行显示，请注意一个细节，WrapPanel的子元素的高度和宽度都是根据子元素自身内容的尺寸呈现。另外，当WrapPanel处于水平排列时，子元素的HorizontalAlignment是不起作用的。 二、垂直排列 12345678910111213141516171819202122&lt;WrapPanel Orientation=&quot;Vertical&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Left&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Right&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网6&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网7&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网8&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网9&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网10&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网12&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网13&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网14&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网15&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网16&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网17&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网18&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网19&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网20&quot; Margin=&quot;5&quot; /&gt; &lt;/WrapPanel&gt; 这里我们放了20个button在WrapPanel控件中，并设置Orientation属性为Vertical（垂直排列），此时，请观察前面3个按钮的HorizontalAlignment状态，可以很清晰的看到，第一个按钮居左显示，第二个按钮居右显示，第三个按钮居中显示，说明在Vertical垂直排列下，子元素的水平状态才会生效，反之亦然。 三、指定子元素宽高 123456789101112&lt;WrapPanel Orientation=&quot;Horizontal&quot; ItemWidth=&quot;80&quot; ItemHeight=&quot;80&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Left&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Right&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网6&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网7&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网8&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网9&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网10&quot; Margin=&quot;5&quot; /&gt;&lt;/WrapPanel&gt; 由此可以，我们也可以指定子元素的宽度和高度，以便统一观察。下一节，我们将探讨与WrapPanel非常相似的布局控件DockPanel。 DockPanel控件（停靠布局）官方解释，定义一个区域，从中可以按相对位置水平或垂直排列各个子元素。我们还是先来看一下它的结构定义： 123456789101112131415public class DockPanel : Panel&#123; public static readonly DependencyProperty LastChildFillProperty; public static readonly DependencyProperty DockProperty; public DockPanel(); public bool LastChildFill &#123; get; set; &#125; public static Dock GetDock(UIElement element); public static void SetDock(UIElement element, Dock dock); protected override Size ArrangeOverride(Size arrangeSize); protected override Size MeasureOverride(Size constraint); &#125; DockPanel提供了一个LastChildFill 属性，用来指示最后一个子元素是否填满剩余的空间。其次，它还提供了一个枚举依赖属性，叫Dock。这个属性是附加到子元素身上的，用来指示子元素在DockPanel显示停靠方位，其值分为Left，Right，Top，Bottom。 DockPanel因为继承了FrameworkElement基类，所以您还可以使用FrameworkElement基类的HorizontalAlignment（水平对齐）和VerticalAlignment（垂直对齐）两个属性，用来设置子元素的排列方式。接下来我们将演示它最基本的用法。 一、经典布局 1234567&lt;DockPanel&gt; &lt;Button DockPanel.Dock=&quot;Left&quot; Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; /&gt; &lt;Button DockPanel.Dock=&quot;Top&quot; Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; /&gt; &lt;Button DockPanel.Dock=&quot;Right&quot; Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; /&gt; &lt;Button DockPanel.Dock=&quot;Bottom&quot; Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt;&lt;/DockPanel&gt; 这是DockPanel最经典的布局方式，上下左右都停靠一个控件，中间剩余的空间，全部由最后一个控件填满。 二、水平布局 1234567&lt;DockPanel LastChildFill=&quot;False&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt;&lt;/DockPanel&gt; 我们只需要设置LastChildFill为False，并设置HorizontalAlignment属性，并再指定子控件的停靠方向，就可以达到上图的效果。 1234567&lt;DockPanel LastChildFill=&quot;False&quot; VerticalAlignment=&quot;Top&quot;&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot;/&gt;&lt;/DockPanel&gt; 你可以通过摸索HorizontalAlignment（水平对齐）和VerticalAlignment（垂直对齐）两个属性，还可以达到更多意想不到的效果哦。 VirtualizingStackPanel 类VirtualizingStackPanel 类（虚拟化元素）和StackPanel 类在用法上几乎差不多。其作用是在水平或垂直的一行中排列并显示内容。它继承于一个叫VirtualizingPanel的抽象类，而这个VirtualizingPanel抽象类继承于Panel布局基类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class VirtualizingStackPanel : VirtualizingPanel, IScrollInfo, IStackMeasure&#123; public static readonly DependencyProperty IsVirtualizingProperty; public static readonly DependencyProperty VirtualizationModeProperty; public static readonly DependencyProperty OrientationProperty; public static readonly RoutedEvent CleanUpVirtualizedItemEvent; public VirtualizingStackPanel(); public double VerticalOffset &#123; get; &#125; public double HorizontalOffset &#123; get; &#125; public double ViewportHeight &#123; get; &#125; public double ViewportWidth &#123; get; &#125; public double ExtentHeight &#123; get; &#125; public double ExtentWidth &#123; get; &#125; public bool CanVerticallyScroll &#123; get; set; &#125; public bool CanHorizontallyScroll &#123; get; set; &#125; public Orientation Orientation &#123; get; set; &#125; public ScrollViewer ScrollOwner &#123; get; set; &#125; protected override bool CanHierarchicallyScrollAndVirtualizeCore &#123; get; &#125; protected internal override Orientation LogicalOrientation &#123; get; &#125; protected internal override bool HasLogicalOrientation &#123; get; &#125; public static void AddCleanUpVirtualizedItemHandler(DependencyObject element, CleanUpVirtualizedItemEventHandler handler); public static void RemoveCleanUpVirtualizedItemHandler(DependencyObject element, CleanUpVirtualizedItemEventHandler handler); public virtual void LineDown(); public virtual void LineLeft(); public virtual void LineRight(); public virtual void LineUp(); public Rect MakeVisible(Visual visual, Rect rectangle); public virtual void MouseWheelDown(); public virtual void MouseWheelLeft(); public virtual void MouseWheelRight(); public virtual void MouseWheelUp(); public virtual void PageDown(); public virtual void PageLeft(); public virtual void PageRight(); public virtual void PageUp(); public void SetHorizontalOffset(double offset); public void SetVerticalOffset(double offset); protected override Size ArrangeOverride(Size arrangeSize); protected override double GetItemOffsetCore(UIElement child); protected override Size MeasureOverride(Size constraint); protected virtual void OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs e); protected override void OnClearChildren(); protected override void OnItemsChanged(object sender, ItemsChangedEventArgs args); protected virtual void OnViewportOffsetChanged(Vector oldViewportOffset, Vector newViewportOffset); protected virtual void OnViewportSizeChanged(Size oldViewportSize, Size newViewportSize); protected override bool ShouldItemsChangeAffectLayoutCore(bool areItemChangesLocal, ItemsChangedEventArgs args); protected internal override void BringIndexIntoView(int index); &#125; VirtualizingStackPanel 类有什么作用？ 比如在ListBox集合控件中需要显示500条数据，那整个屏幕只能显示20条，剩余的480条数据在ListBox控件要不要一次性绘制出来？其实就算绘制出来，用户的屏幕也看不见，只能是拖动滚动条才能看见后面的数据。既然屏幕只能显示20条数据，何不只绘制20条数据的UI子元素，剩下的480条数据的子元素在拖动滚动条时才绘制，这将大大减少计算机的性能消耗，提高UI界面的呈现速度，提高软件的流畅性。 所以，VirtualizingStackPanel 类的作用是开启虚拟化技术，延迟那些看不见的子元素的绘制与渲染。 要开启这项技术，只需要设置Listbox集合控件的附加属性VirtualizingStackPanel.IsVirtualizing&#x3D;”True”即可。因为ListBox的ItemsPanel（元素布局模板）默认采用了VirtualizingStackPanel控件布局。 Canvas控件（绝对布局）Canvas控件允许我们像Winform一样拖拽子控件进行布局，而子控件的位置相对于Canvas来说是绝对的，所以我将它称为绝对布局。我们来看看它的结构定义： 12345678910111213141516171819202122public class Canvas : Panel&#123; public static readonly DependencyProperty LeftProperty; public static readonly DependencyProperty TopProperty; public static readonly DependencyProperty RightProperty; public static readonly DependencyProperty BottomProperty; public Canvas(); public static double GetBottom(UIElement element); public static double GetLeft(UIElement element); public static double GetRight(UIElement element); public static double GetTop(UIElement element); public static void SetBottom(UIElement element, double length); public static void SetLeft(UIElement element, double length); public static void SetRight(UIElement element, double length); public static void SetTop(UIElement element, double length); protected override Size ArrangeOverride(Size arrangeSize); protected override Geometry GetLayoutClip(Size layoutSlotSize); protected override Size MeasureOverride(Size constraint); &#125; 观察它的结构，我们可以看到它提供了4个依赖属性，分别是LeftProperty，RightProperty，TopProperty和BottomProperty。其实是将这4个属性附加到子元素身上，以此来设置子元素距离Canvas上下左右的像素位置。 1234567&lt;Canvas&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; /&gt; &lt;Button Content=&quot;WPF中文网5&quot; Margin=&quot;5&quot; /&gt;&lt;/Canvas&gt; 上面的示例并没有指定button控件在Canvas控件中的上下左右停靠位置，所以这5个button默认会显示在Canvas的左上角，且只能显示最后一个，前面4个会被遮盖。我们来看看下面的例子。 1234567&lt;Canvas&gt; &lt;Button Content=&quot;WPF中文网1&quot; Margin=&quot;5&quot; Canvas.Left=&quot;50&quot;/&gt; &lt;Button Content=&quot;WPF中文网2&quot; Margin=&quot;5&quot; Canvas.Top=&quot;50&quot;/&gt; &lt;Button Content=&quot;WPF中文网3&quot; Margin=&quot;5&quot; Canvas.Right=&quot;50&quot;/&gt; &lt;Button Content=&quot;WPF中文网4&quot; Margin=&quot;5&quot; Canvas.Bottom=&quot;50&quot;/&gt; &lt;Button Content=&quot;WPF中文网5&quot; Canvas.Left=&quot;200&quot; Canvas.Top=&quot;150&quot; /&gt;&lt;/Canvas&gt; 上面的源代码中，我们从上到下，分别来分析一下5个button。 第一个button，设置了Canvas.Left&#x3D;”50”，它将保持距离Canvas左边50像素。 第二个button，设置了Canvas.Top&#x3D;”50”，它将保持距离Canvas顶部50像素。 第三个button，设置了Canvas.Right&#x3D;”50”，它将保持距离Canvas右侧50像素。 第四个button，设置了Canvas.Bottom&#x3D;”50”，它将保持距离Canvas底部50像素。 第五个button，设置了Canvas.Left&#x3D;”200” Canvas.Top&#x3D;”150”，也就是同时距离Canvas左边200像素，顶部150像素。 Border控件（边框布局）严格来说，Border并不是一个布局控件，因为它并不是Panel的子类，而是Decorator装饰器的子类，而Decorator继承于FrameworkElement。要了解Border的用法，我们要先看看它的父类Decorator。 12345678910111213public class Decorator : FrameworkElement, IAddChild&#123; public Decorator(); public virtual UIElement Child &#123; get; set; &#125; protected override int VisualChildrenCount &#123; get; &#125; protected internal override IEnumerator LogicalChildren &#123; get; &#125; protected override Size ArrangeOverride(Size arrangeSize); protected override Visual GetVisualChild(int index); protected override Size MeasureOverride(Size constraint); &#125; Decorator 装饰器只有一个Child 属性，说明Decorator只能容纳一个子元素（UIElement），也就是Border只能容纳一个子元素。那我们再看看Border的结构定义： 123456789101112131415161718192021public class Border : Decorator&#123; public static readonly DependencyProperty BorderThicknessProperty; public static readonly DependencyProperty PaddingProperty; public static readonly DependencyProperty CornerRadiusProperty; public static readonly DependencyProperty BorderBrushProperty; public static readonly DependencyProperty BackgroundProperty; public Border(); public Thickness BorderThickness &#123; get; set; &#125; public Thickness Padding &#123; get; set; &#125; public CornerRadius CornerRadius &#123; get; set; &#125; public Brush BorderBrush &#123; get; set; &#125; public Brush Background &#123; get; set; &#125; protected override Size ArrangeOverride(Size finalSize); protected override Size MeasureOverride(Size constraint); protected override void OnRender(DrawingContext dc); &#125; 我们直接以表格的形式给出Border的相关属性。 属性 说明 BorderThickness 设置Border边框的厚度（像素宽度） Padding 设置子元素相对于Border边框的距离 CornerRadius 设置Border的圆角 BorderBrush 设置Border边框的颜色画刷 Background 设置Border的背景颜色画刷 正是因为Border有这么多实用的属性， 所以， 我们通常在布局界面时，Border（装饰器）控件是首选。接下来，我们以一个例子来说明Border有多么好用。 12345678910111213&lt;WrapPanel Margin=&quot;10&quot;&gt; &lt;Border Height=&quot;35&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; BorderBrush=&quot;Gray&quot;&gt; &lt;TextBlock Text=&quot;矩形 - Border控件&quot; Margin=&quot;5&quot; /&gt; &lt;/Border&gt; &lt;Border Height=&quot;35&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; BorderBrush=&quot;Gray&quot; CornerRadius=&quot;20&quot;&gt; &lt;TextBlock Text=&quot;椭圆 - Border控件&quot; Margin=&quot;5&quot; /&gt; &lt;/Border&gt; &lt;Border Width=&quot;150&quot; Height=&quot;150&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; Background=&quot;Red&quot; BorderBrush=&quot;Gray&quot; CornerRadius=&quot;75&quot;&gt; &lt;TextBlock Text=&quot;圆形Border控件&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; FontSize=&quot;16&quot; FontWeight=&quot;Bold&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot;/&gt; &lt;/Border&gt;&lt;/WrapPanel&gt; 我们分别写了3个Border，第一个Border被设计成矩形，第二个Border增加了圆角属性，第三个Border通过CornerRadius属性，将值设置为宽度或高度的一半，就形成了一个正圆。 将来，我们再配合WPF的模板、样式、触发器会让Border的用法更上一层楼。 WPF布局Demo示例通过前面的章节学习，我们来尝试利用学过的布局控件，设计一款简单的UI界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;auto&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;!--Top--&gt; &lt;DockPanel Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; Background=&quot;#126A74&quot; Height=&quot;60&quot;&gt; &lt;TextBlock Text=&quot;WPF中文网应用程序&quot; Foreground=&quot;White&quot; FontSize=&quot;20&quot; Margin=&quot;15,15&quot;/&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Right&quot;&gt; &lt;Border Height=&quot;35&quot; Margin=&quot;10&quot; BorderThickness=&quot;1&quot; BorderBrush=&quot;#CA5100&quot; Background=&quot;#CA5100&quot; CornerRadius=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;退出系统&quot; Foreground=&quot;White&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;10 0 10 0&quot;/&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;/DockPanel&gt; &lt;!--left--&gt; &lt;StackPanel Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Width=&quot;350&quot;&gt; &lt;Border Height=&quot;250&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; Background=&quot;#439D84&quot;&gt; &lt;TextBlock Text=&quot;参数区域&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot; FontSize=&quot;16&quot;/&gt; &lt;/Border&gt; &lt;Border Height=&quot;250&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; Background=&quot;#9CDC7B&quot;&gt; &lt;TextBlock Text=&quot;参数区域&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot; FontSize=&quot;16&quot;/&gt; &lt;/Border&gt; &lt;Border Height=&quot;110&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; Background=&quot;#E97752&quot;&gt; &lt;TextBlock Text=&quot;参数区域&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot; FontSize=&quot;16&quot;/&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;!--right--&gt; &lt;Grid Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot;&gt; &lt;Border Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; BorderBrush=&quot;#F7BD93&quot; CornerRadius=&quot;5&quot; Background=&quot;#FDD2B2&quot;&gt; &lt;TextBlock Text=&quot;主体区域&quot; Margin=&quot;5&quot; /&gt; &lt;/Border&gt; &lt;Border Width=&quot;150&quot; Height=&quot;150&quot; Margin=&quot;10&quot; Padding=&quot;5&quot; BorderThickness=&quot;1&quot; Background=&quot;Red&quot; BorderBrush=&quot;Gray&quot; CornerRadius=&quot;75&quot;&gt; &lt;TextBlock Text=&quot;开始运行&quot; Margin=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; FontSize=&quot;16&quot; FontWeight=&quot;Bold&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;White&quot;/&gt; &lt;/Border&gt; &lt;/Grid&gt; &lt;!--bottom--&gt; &lt;Grid Grid.Row=&quot;2&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; Background=&quot;#CA5100&quot;&gt; &lt;TextBlock Text=&quot;版本：1.0.2.5 | 版权所有：中国WPF中文网科技有限公司 www.wpfsoft.com&quot; Margin=&quot;10 5 10 5&quot; Foreground=&quot;White&quot;/&gt; &lt;/Grid&gt;&lt;/Grid&gt; 我们通过Grid栅格布局出界面的主要区域，然后给每个区域进行二次布局，比如Top区域，我们DockPanel和StackPanel的组合，设计成左右两个子区域，左边是应用程序的名称，右边是退出按钮。 中间区域，分为两部分组成，左边是一个StackPanel，里面有一个Border，右边是一个Grid。(注：左侧的StackPanel改成Grid的效果会更好哦) 底部区域是一个Grid,和一个TextBlock内容控件。好，我们布局控件的内容就先介绍到这里，在后续的章节中， 我们还会给出更多的例子来诠释WPF的其它知识点，而这些知识都有可能用以布局控件，所以，我们还会进一步学习布局控件的实战。 GridSplitter分割窗口ridSplitter控件用来分割窗体的布局，必须放在Grid栅格控件中配合使用，通过鼠标按住GridSplitter进行左右或上下拖动，即可调整行列尺寸。 注意事项： 1、如果您希望GridSplitter控件可以水平调整左右的Grid列宽时，那么HorizontalAlignment属性必须设置为Stretch或者Center。 2、如果您希望GridSplitter控件可以垂直调整行高，那么VerticalAlignment属性必须设置为Stretch或者Center。 3、ShowsPreview属性表示拖动时是否及时绘制调整尺寸。 接下来，我们通过一个例子来说明它的用法 前端代码 12345678910111213141516171819202122232425262728&lt;Window x:Class=&quot;HelloWorld.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:HelloWorld&quot; mc:Ignorable=&quot;d&quot; FontSize=&quot;14&quot; Title=&quot;WPF中文网之控件课程 - www.wpfsoft.com&quot; Height=&quot;350&quot; Width=&quot;500&quot;&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition Width=&quot;auto&quot;/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Border Grid.Column=&quot;0&quot; Background=&quot;LightBlue&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot; LineHeight=&quot;20&quot;&gt; 您好，我是站长重庆教主，欢迎来到 WPF中文网，我们的网址是：http://www.wpfsoft.com。您还可以在百度、B站、51CTO、csdn搜索我的名字，以便找到我其它的技术文章或视频课程。本站上线于2023年8月3日，在一个稀松平常的午后，我突然想搭建一个关于学习和分享WPF框架的博客网站，于是开始注册域名、购买空间、安装网站、设置栏目，不到3个小时，WPF中文网就诞生了。 &lt;/TextBlock&gt; &lt;/Border&gt; &lt;GridSplitter Grid.Column=&quot;1&quot; Width=&quot;5&quot; HorizontalAlignment=&quot;Center&quot; ShowsPreview=&quot;False&quot;/&gt; &lt;Border Grid.Column=&quot;2&quot; Background=&quot;LightCoral&quot;&gt; &lt;TextBlock TextWrapping=&quot;Wrap&quot; Padding=&quot;10&quot; LineHeight=&quot;20&quot;&gt;接下来的日子里，我将从WPF的起源、概述、学习路径等，一路写下去，一直把WPF最后一滴知识详尽才会封笔，我明白这是一场耗费个人巨大精力的战争。但是，那些我曾踩过的坑与走过的弯路，都无时无刻不提醒着我，尽量像讲故事一样，把这一切都写下来吧，总结自己，照亮来者。 &lt;/TextBlock&gt; &lt;/Border&gt; &lt;/Grid&gt;&lt;/Window&gt; 接下来我们看看F5运行后，可以用鼠标左右拖动的窗体效果。最好是为GridSplitter单独分配一行或者一列，同时，GridSplitter需要跨越整行或整列，这样的效果会更好。如上面的代码所示，我们在Grid中分割了3个单元格（3列），将GridSplitter居在放置，简单设置一下GridSplitter的属性，就可以达到我们的目的了。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"WPF - 编程","slug":"WPF-编程","permalink":"http://example.com/tags/WPF-%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"WPF编程高级","slug":"WPF高级学习","date":"2025-05-10T11:00:24.000Z","updated":"2025-05-13T15:40:12.938Z","comments":true,"path":"2025/05/10/WPF高级学习/","permalink":"http://example.com/2025/05/10/WPF%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"数据绑定什么是数据绑定DataContext数据上下文Binding（绑定）INotifyPropertyChanged接口ObservableCollection泛型集合IValueConverter转换器IMultiValueConverter多值转换器ValidationRule验证规则样式WPF样式概述Resource资源ResourceDictionary资源字典Trigger触发器MultiTrigger多条件触发器DataTrigger数据触发器MultiDataTrigger 数据触发器EventTrigger事件触发器模板LogicalTree逻辑树VisualTree可视化树ControlTemplate控件模板ControlTemplate的触发器TemplateBinding模板绑定DataTemplate数据模板ItemsPanelTemplate元素模板ListBox的ItemContainerStyleListBox模板样式实战Button的模板样式实战命令什么是命令ICommandSource命令源ICommand接口RoutedUICommand预定义命令CommandBinding命令绑定ApplicationCommands命令实战WPF事件转Command命令Mvvmlight之RelayCommandPrism之DelegateCommandReactiveUI之ReactiveCommand依赖属性什么是依赖属性DependencyProperty定义使用依赖属性的回调函数什么是附加属性PasswordBox与附加属性实战路由事件什么是路由事件路由事件实战什么是附加事件附加事件实战转换什么是Transform转换RotateTransform旋转ScaleTransform缩放SkewTransform倾斜TranslateTransform平移TransformGroup与图片查看器画刷什么是画刷SolidColorBrush纯色画刷LinearGradientBrush渐变画刷RadialGradientBrush径向渐变ImageBrush图像画刷VisualBrush放大镜+水印文字特效DropShadowEffect阴影特效BlurEffect模糊特效动画什么是动画DoubleAnimation动画在C#代码中使用动画","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"WPF - 编程","slug":"WPF-编程","permalink":"http://example.com/tags/WPF-%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"CSharp学习","slug":"CSharp学习","date":"2025-05-10T10:00:24.000Z","updated":"2025-05-12T13:14:24.323Z","comments":true,"path":"2025/05/10/CSharp学习/","permalink":"http://example.com/2025/05/10/CSharp%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"反射反射是指在程序运行中，查看、操作其他程序集或者自身的元数据的各种信息（类、函数、变量、对象等）的行为。C#中的反射（Reflection）是一种强大的特性，允许你在运行时检查和操作程序集、类型和对象的信息，基本上，使用反射可以在代码运行时检查和操作指定的类及其成员。C#反射的原理主要基于元数据（与C#特性相似），即程序集中存储的有关类型、方法等的信息。 C#反射技术主要基于System.Type类和System.Reflection.Assemble类，通过Type类可以访问关于任何数据类型的信息，Assemble类用于访问给定程序集的相关信息，或把这个程序集加载到程序中。 反射的使用因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性 一.System.Type类Type类是一个抽象类。只要实例化了一个Type对象，实际上就实例化了Type的一个派生类。尽管一般情况下派生类只提供各种Type方法和属性的不同重载，但是这些方法和属性返回对应数据类型的正确数据，Type有与每种数据类型对应的派生类。它们一般不添加新的方法或属性通常，获取指向任何给定的Type引用有三种常用方式： 使用typeof运算符，这个运算符的参数是类型的名称，但不放在引号中： 1Type t =typeof(double); 使用GetType()方法，所以类都会从System.Object继承这个方法： 12double d =10;Type t = d.GetType(); 在一个变量上调用GetType()方法，返回的Type对象只与该数据类型相关，不包含该类型实例的任何信息。 调用Type类的静态方法GetType()： 1Type t =Type.GetType(&quot;System.Double&quot;); Type是很多反射功能的入口，它实现很多方法和属性，可用的属性都是只读的：可以使用Type确定数据的类型，但不能使用它修改该类型。 Type属性由Type实现的属性分为3类。 *包含与类相关的各种名称的字符串： Name：数据类型名 FullName：数据类型的完全限定名（包含名称空间） Namespace：在其中定义数据类型的名称空间名 *获取Type对象的引用的属性： BaseType：该对象的直接基本类型 UnderlyingSystemType：该Type在.NET运行库中映射到的类型 *布尔属性 IsAbstract，IsArray,IsClass,IsEnum等判断Type是什么类型的属性。 Type方法System.Type的大多数方法都用于获取对应数据类型的成员信息：构造函数，属性，方法和事件等。它有许多方法，但它们都有相同的模式。例如，获取数据类型的方法的信息：GetMethod()和GetMethods()。GetMethod()方法返回MethodInfo对象的一个引用，其中包含一个指定方法的细节信息；而GetMethods()返回这种引用的一个数组。 二.ActivatorActivator（快速实例化对象的类）用于将Type对象快捷实例化为对象 12345678static void Main(string[] args)&#123; Type t = typeof(Test); // 无参构造 Test test = Activator.CreateInstance(t) as Test; // 有参构造 test = Activator.CreateInstance(t, 99) as Test;&#125; 三.Assembly类相关概念主要用来加载其他程序集，加载后才能用Type来使用其他程序集中的信息，如果想要使用不是自己程序集中的内容，需要先加载程序集。 dll文件（库文件）可以简单的把库文件看成一种代码仓库 在C#中，程序集可以以DLL或EXE文件形式存储，并可以通过反射API在运行时加载和操作，其中包含了编译后的代码和元数据。程序集通常需要在运行时被加载，以便在应用程序中使用其中定义的类型和成员。 程序集在运行时的加载可以发生在两种不同的上下文中，分别是： 上下文中解析（Contextual Resolve）：这是程序集加载的一种默认行为，其中.NET运行时会尝试根据程序集的引用和依赖关系来自动解析和加载程序集。当你在代码中引用一个程序集，并且它有其他依赖的程序集，运行时会自动查找和加载这些依赖的程序集，以便构建完整的程序集树。 特定路径加载（LoadFrom）：LoadFrom方法允许你显式指定程序集的路径，而不依赖于运行时上下文进行解析。你可以使用Assembly.LoadFrom方法来加载程序集，提供程序集的完整文件路径作为参数。这种方式适用于需要加载特定位置的程序集，而不需要考虑运行时上下文中的解析。 加载方法 1.Assembly.Load： 当使用Assembly.Load时，参数是程序集的显示名称（可以包含长名称、版本、文化和公共密钥令牌信息）。此方法将在应用程序域的上下文中查找和加载程序集。如果程序集已经被加载，则将返回现有的程序集引用。Load方法最适合在已知需要加载程序集的完整名称的情况下使用。 1Assembly assembly = Assembly.Load(&quot;System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;); 2.Assembly.LoadFrom： 使用 Assembly.LoadFrom 时，参数是包含程序集文件的路径。此方法将从指定路径加载程序集，并在包含目录下解析其依赖项。注意，这可能会导致同一个程序集被多次加载，例如，当相同的程序集位于不同的目录时。LoadFrom适用于需要从特定路径加载程序集，而不必在上下文中解析的情况。 1Assembly assembly = Assembly.LoadFrom(@&quot;C:\\MyAssemblies\\MyAssembly.dll&quot;); 3.Assembly.LoadFile： Assembly.LoadFile 与 Assembly.LoadFrom 类似，因为它需要一个包含程序集文件的路径作为参数。然而，LoadFile 在加载程序集时不会将其添加到上下文中，也不会解析其依赖项。这意味着，如果程序集具有未解析的依赖项，可能会在运行时出现问题。LoadFile 在只需要检查程序集信息而无需实际执行代码的场景下非常有用。 1Assembly assembly = Assembly.LoadFile(@&quot;C:\\MyAssemblies\\MyAssembly.dll&quot;); 然后就可以通过assembly1.GetType();传入带命名空间的类名获取程序集下的指定类的类信息 特性一、特性是什么1、特性定义**特性（Attribute）**是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。 特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：预定义特性和自定义特性。 2、特性的语法特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。positional_parameters 规定必需的信息，name_parameter 规定可选的信息。 12[attribute(positional_parameters, name_parameter = value, ...)]element 3、特性和注释有什么区别特性很厉害，加了特性之后，就有很厉害的功能[Obsolete]编译时就有提示，影响了编译器[Obsolete(“请不要使用这个了，请使用什么来代替”, true)]甚至导致编译报错[Serializable]对象就可以序列化，影响了程序运行 123456789101112131415161718192021222324252627using System;namespace MyAttribute&#123; /// &lt;summary&gt; /// 这里是注释，除了让人看懂这里写的是什么，对运行没有任何影响 /// &lt;/summary&gt; ///[Obsolete(&quot;请不要使用这个了，请使用什么来代替&quot;)]//对编译都产生了影响，编译出现警告 ///[Obsolete(&quot;请不要使用这个了，请使用什么来代替&quot;, true)]//对编译都产生了影响，编译报错不通过 [Serializable]//可以序列化和反序列化 public class Student &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public void Study() &#123; Console.WriteLine($&quot;这里是&#123;this.Name&#125;在学习&quot;); &#125; public string Answer([Custom]string name) &#123; return $&quot;This is &#123;name&#125;&quot;; &#125; &#125;&#125; 特性无处不在：EF–MVC–WCF–WebService–UnitTest–IOC–AOP–SuperSocket 二、特性声明和使用1、什么是特性特性其实就是一个类，直接或间接继承自Attribute 123456789101112131415161718192021222324252627282930313233#region 程序集 mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089// C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\mscorlib.dll// Decompiled with ICSharpCode.Decompiler 6.1.0.5902#endregionusing System.Reflection;using System.Runtime.InteropServices;namespace System&#123; [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Delegate, Inherited = false)] [ComVisible(true)] public sealed class SerializableAttribute : Attribute &#123; internal static Attribute GetCustomAttribute(RuntimeType type) &#123; if ((type.Attributes &amp; TypeAttributes.Serializable) != TypeAttributes.Serializable) &#123; return null; &#125; return new SerializableAttribute(); &#125; internal static bool IsDefined(RuntimeType type) &#123; return type.IsSerializable; &#125; &#125;&#125;#if false // 反编译日志缓存中的 9 项#endif 属性更改通知123456789101112131415161718192021222324public class ViewModelBase : INotifyPropertyChanged&#123; public event EventHandler&lt;PropertyChangedExtendedEventArgs&gt; PropertyChangedExtended; public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged(object oldValue, object newValue,[CallerMemberName] string propertyName=&quot;&quot;) &#123; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); PropertyChangedExtended?.Invoke(this, new PropertyChangedExtendedEventArgs(propertyName, oldValue, newValue)); &#125;&#125;public class PropertyChangedExtendedEventArgs : PropertyChangedEventArgs&#123; public object OldValue &#123; get; &#125; public object NewValue &#123; get; &#125; public PropertyChangedExtendedEventArgs(string propertyName, object oldValue, object newValue) : base(propertyName) &#123; OldValue = oldValue; NewValue = newValue; &#125;&#125; 1234567891011121314151617181920212223public class Book : ViewModelBase&#123; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; var oldValue = name; name = value; OnPropertyChanged(oldValue, value); &#125; &#125; private string author; public string Author &#123; get &#123; return author; &#125; set &#123; var oldValue = author; author = value; OnPropertyChanged(oldValue,value); &#125; &#125;&#125; 委托C# 委托（Delegate）是一种类型安全的函数指针，它是 .NET Framework 中一种重要的编程概念，用于封装方法的引用。委托允许你将方法作为参数传递给其他方法，注册事件处理器，实现回调机制，以及在异步编程和多线程编程中扮演关键角色。以下是关于 C# 委托的详细介绍： 委托是 C# 语言中的一个特色，通常将委托分为命名方法委托、多播委托、匿名委托，其中命名方法委托是使用最多的一种委托。 在 C#语言中命名方法委托是最常用的一种委托，其定义的语法形式如下。 1修饰符 delegate 返回值类型 委托名 ( 参数列表 ); 从上面的定义可以看出，委托的定义与方法的定义是相似的。例如定义一个不带参数的委托，代码如下。 1public delegate void MyDelegate(); 在定义好委托后就到了实例化委托的步骤，命名方法委托在实例化委托时必须带入方法的具体名称。 实例化委托的语法形式如下。 1委托名 委托对象名 = new 委托名 ( 方法名 ); 委托中传递的方法名既可以是静态方法的名称，也可以是实例方法的名称。 需要注意的是，在委托中所写的方法名必须与委托定义时的返回值类型和参数列表相同。 在实例化委托后即可调用委托，语法形式如下。 1委托对象名 ( 参数列表 ); （1）委托可以声明在类外部，也可以在类内部 （2）跟方法有点类似，有参数，返回值，访问修饰符，比方法声明多一个关键字delegate 123456789101112131415161718192021222324252627282930313233namespace MyDelegate&#123; /// &lt;summary&gt; /// 1.无参数无返回值委托 /// &lt;/summary&gt; public delegate void NoReturnNoParaOutClass(); public class CustomDelegate &#123; /// &lt;summary&gt; /// 2.无参数无返回值委托 /// &lt;/summary&gt; public delegate void NoReturnNoPara(); /// &lt;summary&gt; /// 3.有参数无返回值委托 /// &lt;/summary&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; public delegate void NoReturnWithPara(int x, int y); /// &lt;summary&gt; /// 4.无参数有返回值的委托 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public delegate int WithReturnNoPara(); /// &lt;summary&gt; /// 5.带参数带返回值的委托 /// &lt;/summary&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public delegate int WithReturnWithPara(out int x, ref int y); &#125;&#125; （1）委托是一个类，继承自MulticastDelegate MulticastDelegate这个类我们自己定义的类是无法继承的 （2）委托的构造函数，需要传递一个方法作为参数 （3）委托的内部有三个方法Invoke，BeginInvoke，EndInvoke 二、委托实例化和执行 1、委托实例化 （1）通过New来实例化 （2）直接&#x3D;一个方法，这个是编译器提供的语法糖 （3）直接&#x3D;一个匿名委托 （4）直接&#x3D;一个Lambda 2、委托执行（1）Inovke执行委托 如果委托定义没有参数，则Inovke也没有参数；委托没有返回值，则Inovke也没有返回值 （2）BeginInvoke开启一个新线程执行委托 NetCore不支持，NetFamework支持 NetCore有更好的多线程功能来支持实现类似功能 （3）EndInvoke等待BeginInvoke执行完成后再执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System;namespace MyDelegate&#123; public class CustomDelegateShow &#123; public static void Show() &#123; //1、委托实例化 //（1）通过New来实例化，要求传递一个和这个委托的参数和返回值完全匹配的方法 NoReturnNoParaOutClass noReturnNoParaOutClass = new NoReturnNoParaOutClass(NoReturnNoParaMehtod); //（2）直接=一个方法，要求方法和这个委托的参数和返回值完全匹配，这个是编译器提供的语法糖 NoReturnNoParaOutClass noReturnNoParaOutClass2 = NoReturnNoParaMehtod; //（3）直接=一个匿名委托，要求和这个委托的参数和返回值完全匹配 NoReturnNoParaOutClass noReturnNoParaOutClass3 = delegate () &#123; Console.WriteLine(&quot;这是一个无参数无返回值的方法。。。&quot;); &#125;; //（4）直接=一个Lambda，要求和这个委托的参数和返回值完全匹配 NoReturnNoParaOutClass noReturnNoParaOutClass4 = ()=&gt; &#123; Console.WriteLine(&quot;这是一个无参数无返回值的方法。。。&quot;); &#125;; //无参无返回值委托实例化 CustomDelegate.NoReturnNoPara noReturnNoPara = NoReturnNoParaMehtod; //带参数无返回值委托实例化 CustomDelegate.NoReturnWithPara noReturnWithPara = NoReturnWithParaMehtod; //无参数带返回值委托实例化 CustomDelegate.WithReturnNoPara withReturnNoPara = WithReturnNoParaMehtod; //带参数带返回值委托实例化 CustomDelegate.WithReturnWithPara withReturnWithPara = WithReturnWithParaMehtod; //2、委托执行 //（1）Inovke执行方法，如果委托定义没有参数，则Inovke也没有参数；委托没有返回值，则Inovke也没有返回值 noReturnNoParaOutClass.Invoke(); //（2）BeginInvoke开启一个新的线程去执行委托 //NetCore不支持，NetFamework支持 NetCore有更好的多线程功能来支持实现类似功能 //noReturnNoParaOutClass.BeginInvoke((a) =&gt; Console.WriteLine(&quot;方法调用结束。。。&quot;), null); //（3）EndInvoke等待BeginInvoke方法执行完成后再执行EndInvoke后面的代码 //NetCore不支持，NetFamework支持 NetCore有更好的多线程功能来支持实现类似功能 //noReturnNoParaOutClass.EndInvoke(null); //无参无返回值委托执行 noReturnNoPara.Invoke(); //带参数无返回值委托执行 noReturnWithPara.Invoke(1,2); //无参数带返回值委托执行 int result=withReturnNoPara.Invoke(); //带参数带返回值委托执行 int x = 1; int y = 1; int result2 = withReturnWithPara.Invoke(out x, ref y); &#125; private static void NoReturnNoParaMehtod() &#123; Console.WriteLine(&quot;这是一个无参数无返回值的方法。。。&quot;); &#125; private static void NoReturnWithParaMehtod(int x, int y) &#123; Console.WriteLine($&quot;这是一个带参数无返回值的方法。。。&quot;); &#125; private static int WithReturnNoParaMehtod() &#123; Console.WriteLine($&quot;这是一个无参数带返回值的方法。。。&quot;); return default(int); &#125; private static int WithReturnWithParaMehtod(out int x, ref int y) &#123; Console.WriteLine($&quot;这是一个带参数带返回值的方法。。。&quot;); x = 1; return default(int); &#125; &#125;&#125; 框架内置委托Action&#x2F;Func是.NET Framework3.0时代的产物 1、Action（1）Action是来自于System.RunTime的一个声明好的可以带有一个或者多个参数无返回值的委托（2）最多支持16个入参，正常使用足够 12Action action = new Action(NoreturnNopara);Action&lt;int&gt; action1 = new Action&lt;int&gt;(DoNothingInt); （3）想要支持更多的参数呢，可以自己定义 &#x2F;&#x2F;参数不够自己定义 12//参数不够自己定义public delegate void Action&lt;in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16, in T17&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17); 2、Func（1）Func是来自于System.RunTime的一个声明好有返回值的委托，也可以有参数（2）如果既然有参数也有返回值，前面是输入参数类型，最后面的作为返回值类型（3）最多支持16个入参，正常足够使用 123Func&lt;int&gt; func = new Func&lt;int&gt;(ReturnNopara);Func&lt;int, int&gt; func1 = new Func&lt;int, int&gt;(ToInt);Func&lt;int, string, int&gt; func2 = new Func&lt;int, string, int&gt;(DoNothingIntAndStringNew); （4）想要支持更多的参数呢，可以自己定义 12//参数不够自己定义public delegate TResult Func&lt;in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16, in T17, out TResult&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, T17 arg17); 3、为什么要用框架内置委托（1）委托的本质是类，定义多个委托，其实就是新增了多个类，定义好的两个委托参数和返回值都是一致的，但是因为是不同的类，没有继承不能通用（2）既然是系统框架给我们定义好了这两个委托，自然是希望我们在以后的开发中，都去使用这两个委托，这样就可以把委托类型做到统一（3）那之前定义好的委托是去不掉的，这被称之为历史包袱 https://www.cnblogs.com/guoqiang1/p/8138889.html https://blog.csdn.net/wenchm/article/details/134553445 另：（十月的寒流） 作用 1、将函数作为函数的参数进行传递（回调函数、LINQ） 2、基于委托生成事件（声明事件并用来注册） （按钮） 123强类型委托Action&lt;T1&gt;Func&lt;T1,TResult&gt; 注意: 调用委托时，如果其中的一个委托报错，则后面的不会被调用 只有最后一个的返回值才会作为委托的返回值 因为是数组，所以 remove 的复杂度是O(n) 线程不安全 委托为什么不等于函数指针 委托可以”指向”多个函数 委托可以指向同一个函数多次 函数是包含在类中的，所以函数引用也包含了所在对象的信息;而C&#x2F;c++的函数指针只是函数的入口地址 异步调用 BeginInvoke EndInvoke Covariance&amp; Contravariance Predicate 返回值是bool 为什么不使用接口 使用接口非常不灵活，比如使用LINQ，要频繁传入各种形式的函数，且必须有类去实现接口 传接口对象其实说自了是在传类的引用，那么就有可能会将类的其他公共成员也暴露出来，引起不必要的麻 无法使用多播委托与事件提供的各种功能，比如添加与删除 类的方法是封装好的，而使用匿名委托可以随处声明，并使用当前作用域可访问的所有变量 内置的强类型委托等充分提供了各种常见形式的委托类型，没有必要自己写大量接口 事件另：（十月的寒流） 希望一个类的某些成员在发生变化时候能够被外界观测到 CollectionChanged TextChanged 标准.Net事件模式 1234delegate EventHandler(object sender,EventArgs e)EventArgsButton.ClickTextbox.TextChanged 推荐的命名规范 名词+动词（被动） 123456CollectionChangedEventRaisedPropertyChangedOnEventRaisedOnpropertyChangedRaisePropertyChange 事件说白了是C#提供的语法糖，效果是 将委托以私有变量的形式封装在类内，不让外面访问 对于委托进行了封装，从而定义add 与remove 方法 在add 与 remove 中通过互锁的方式提供了线程安全性 依赖属性is out refasync awitLinqSelectSelectMany用于将每个元素投影为一个序列，然后“平展”这些序列，将它们合并为一个序列。（用于将多个序列合并为一个序列。） SelectMany 有几个重载版本，最常用的版本接受两个参数： 一个转换函数，它接受一个源序列中的元素，并返回一个新序列（通常是一个 IEnumerable&lt;T&gt; 类型的序列）。 一个结果选择函数，它接受转换函数返回的序列中的每个元素，并返回最终结果中的元素。 下面是一个简单的 SelectMany 示例： 12345678910111213141516171819202122using System;using System.Collections.Generic;using System.Linq;class Program&#123; static void Main() &#123; int[][] numbers = &#123; new int[] &#123;1, 2, 3&#125;, new int[] &#123;4, 5, 6&#125;, new int[] &#123;7, 8, 9&#125; &#125;; var flattened = numbers.SelectMany(arr =&gt; arr); foreach (var num in flattened) &#123; Console.WriteLine(num); &#125; &#125;&#125; 在这个示例中，我们有一个二维整数数组 numbers。我们使用 SelectMany 来“平展”这个数组，将其转换为一个一维整数数组。转换函数 arr =&gt; arr 接受每个内部数组 arr，并直接返回它，这样 SelectMany 就会将所有内部数组合并为一个数组。 SelectMany 也可以用于更复杂的场景，例如，当你有一个对象数组，每个对象都有一个子对象集合，你可以使用 SelectMany 来获取所有子对象的列表。 下面是一个更复杂的示例： 123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.Linq;class Program&#123; static void Main() &#123; var customers = new List&lt;Customer&gt; &#123; new Customer &#123; Name = &quot;Customer A&quot;, Orders = new List&lt;Order&gt; &#123; new Order &#123; OrderId = 1 &#125;, new Order &#123; OrderId = 2 &#125; &#125;&#125;, new Customer &#123; Name = &quot;Customer B&quot;, Orders = new List&lt;Order&gt; &#123; new Order &#123; OrderId = 3 &#125;, new Order &#123; OrderId = 4 &#125; &#125;&#125; &#125;; var allOrders = customers.SelectMany(c =&gt; c.Orders); foreach (var order in allOrders) &#123; Console.WriteLine($&quot;Order ID: &#123;order.OrderId&#125;&quot;); &#125; &#125;&#125;class Customer&#123; public string Name &#123; get; set; &#125; public List&lt;Order&gt; Orders &#123; get; set; &#125;&#125;class Order&#123; public int OrderId &#123; get; set; &#125;&#125; 在这个示例中，我们有一个 Customer 对象的列表，每个 Customer 都有一个 Orders 集合。我们使用 SelectMany 来获取所有 Order 对象的列表，而不是分别对每个 Customer 的 Orders 集合进行操作。 如果你的目标是创建一个新序列，其中包含对源序列中每个元素进行一对一转换的结果，使用 Select。 如果你的目标是创建一个新序列，其中包含对源序列中每个元素进行一对多转换的结果，并且需要将这些结果“平铺”成一个单一序列，使用 SelectMany。 WhereWhere 方法接受一个返回布尔值的委托（通常是一个lambda表达式），并且返回一个新序列，其中只包含满足该条件的元素。 下面是一个使用 Where 方法的基本示例： 12345678910111213141516171819using System;using System.Linq;public class Program&#123; public static void Main() &#123; int[] numbers = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; // 使用Where方法筛选出偶数 var evenNumbers = numbers.Where(n =&gt; n % 2 == 0); Console.WriteLine(&quot;Even numbers:&quot;); foreach (var number in evenNumbers) &#123; Console.WriteLine(number); &#125; &#125;&#125; 在这个例子中，Where 方法用于筛选出数组 numbers 中的偶数。Lambda表达式 n =&gt; n % 2 == 0 定义了筛选条件，即选择那些除以2余数为0的整数。 Where 方法不会改变原始数据集合，而是创建一个新的序列，包含满足条件的元素。这个新序列是一个 IEnumerable&lt;T&gt; 类型，你可以使用 foreach 循环来遍历它，或者将其转换成其他集合类型，如 List&lt;T&gt; 或 Array。 Where 方法可以与其他LINQ方法结合使用，以构建更复杂的查询。例如，你可以先使用 Where 筛选数据，然后使用 OrderBy 对结果进行排序，或者使用 Select 对结果进行投影（转换）。 12345678var evenNumbersSorted = numbers .Where(n =&gt; n % 2 == 0) // 筛选出偶数 .OrderBy(n =&gt; n); // 按升序排序foreach (var number in evenNumbersSorted)&#123; Console.WriteLine(number);&#125; 在这个例子中，我们先筛选出偶数，然后对这些偶数进行排序。 Aggregate在 C# 中，Aggregate 方法是 LINQ（语言集成查询）的一部分，它用于对一个集合中的所有元素应用一个累积函数。这个方法可以用来执行各种操作，比如计算总和、平均值、连接字符串等。 Aggregate 方法的基本语法如下： 1result = source.Aggregate(func); 其中 source 是一个集合，func 是一个累积函数，它定义了如何处理每个元素以及如何累积结果。 累积函数 func 可以接受两个参数： 累积状态（通常称为 accumulator 或 s）：这是累积过程的中间结果。 当前元素（通常称为 element 或 x）：这是集合中当前正在处理的元素。 Aggregate 方法也可以接受一个种子值作为初始累积状态，这在某些情况下非常有用。 下面是一个简单的例子，用于计算一个整数列表的总和： 123List&lt;int&gt; numbers = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5 &#125;;int sum = numbers.Aggregate(0, (s, x) =&gt; s + x);Console.WriteLine(sum); // 输出 15 在这个例子中，0 是种子值，累积函数 (s, x) =&gt; s + x 定义了如何将每个元素累加到累积状态上。 Aggregate 方法也可以用来创建复杂的数据结构，比如连接字符串列表： 123List&lt;string&gt; words = new List&lt;string&gt; &#123; &quot;Hello&quot;, &quot;world&quot;, &quot;!&quot; &#125;;string sentence = words.Aggregate((s, x) =&gt; s + &quot; &quot; + x);Console.WriteLine(sentence); // 输出 &quot;Hello world !&quot; 在这个例子中，累积函数 (s, x) =&gt; s + &quot; &quot; + x 定义了如何将每个字符串连接到累积状态上，初始累积状态是列表的第一个元素。 Aggregate 方法非常灵活，可以根据需要定义复杂的累积逻辑。它是对集合进行迭代和累积操作的有力工具。 Z-score(Z评分法)Z评分法（Z-score）是一种统计学上的概念，用于表示一个数值相对于整个数据集的平均值的标准差数目。在统计学中，Z分数（Z-score）能够告诉我们一个给定的数据点距离平均值有多远，通过用标准差来表示这个距离。一个数据的Z分数告诉我们它是在平均值之上还是之下，以及它与平均值的距离有多远。 Z评分法的计算公式是：Z&#x3D;(X−μ) &#x2F; σ X 是观测值 \\mu：μ 是平均值（均值） \\sigma：σ 是标准差 在应用中，Z评分法常用于： 标准化：将不同分布的数据转换为标准正态分布，便于比较。 排名和比较：在教育、医学等领域的测试成绩，可以通过Z分数进行比较。 异常值检测：在数据分析中，Z分数可以帮助识别数据集中的异常值或离群点。 σ（标准差）标准差（Standard Deviation，缩写为SD或σ）是统计学中衡量一组数值离散程度的一种度量。它描述的是数据分布的宽度，或者说是数据分布的离散程度。标准差越大，表示数据的波动越大，数据分布越分散；标准差越小，表示数据的波动越小，数据分布越集中。 对于一组数据，标准差计算的基本步骤如下： 计算平均值（均值）μ。 求每个数值与平均值的差的平方。 计算这些平方差的平均值，即方差σ²。 计算方差的平方根，得到标准差σ。 用数学公式表示，标准差的计算过程是： CP和CPKCP（Capability Index，能力指数）和CPK（Capability Process Index，过程能力指数）是质量管理中的两个常用指标，用来衡量一个生产过程是否能够满足产品规格的要求。通俗地说，CP和CPK就是在说一个生产过程做出来的产品质量怎么样，是不是很稳定，能不能做到大多数产品都在标准范围内。 CP（能力指数）：这个指标主要是看生产出来的产品特性值分布的宽度是否在规格允许的范围之内。CP值越大，说明产品的质量越稳定，大部分的产品都集中在规格中心附近。如果CP值小，那么产品质量就可能比较分散，有些产品可能会超出规格。 CPK（过程能力指数）：这个指标不仅考虑了产品特性值的分布宽度，还考虑了这个分布的中心位置是否偏离了规格的中心。CPK值越大，表示生产过程不仅产品质量分布窄，而且中心位置也控制得很好，几乎没有偏离。如果CPK值小，说明生产过程可能存在问题，导致产品质量不稳定或者偏离规格中心。举个例子，就像射击靶心一样，CP值高就像所有的子弹都打在了靶子上，但可能没有全部集中在靶心；而CPK值高则意味着子弹不仅都打在了靶子上，而且还非常集中地打在了靶心。两者都高，说明射手既有很好的准确度，也有很好的稳定性。 补偿值CavityData(腔体数据) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/// &lt;summary&gt;/// 腔体数据/// &lt;/summary&gt;public class CavityData&#123; // 通过索引获取注液泵数据 public InjectorPumpData this[int index] &#123; get &#123; return InjectorPumpDatas[index]; &#125; &#125; public int CavitySerialNumber &#123; get; private set; &#125; /// &lt;summary&gt; /// 注液泵数据集合 /// &lt;/summary&gt; public List&lt;InjectorPumpData&gt; InjectorPumpDatas &#123; get; private set; &#125; /// &lt;summary&gt; /// 初始化腔体数据结构 /// &lt;/summary&gt; /// &lt;param name=&quot;needleCount&quot;&gt;针头个数&lt;/param&gt; public CavityData(int CavitySerialNumber, int injectorPumpCount, int[] needleCount) &#123; //4-24修改 this.CavitySerialNumber = CavitySerialNumber; InjectorPumpDatas = new List&lt;InjectorPumpData&gt;(); for (int i = 0; i &lt; injectorPumpCount; i++) &#123; InjectorPumpDatas.Add(new InjectorPumpData(this.CavitySerialNumber, i, needleCount)); &#125; &#125; /// &lt;summary&gt; /// 添加数据 /// &lt;/summary&gt; public void Add(int injectorPumpSerialNumber, int needleSerialNumber, double infusionVolume) &#123; InjectorPumpDatas[injectorPumpSerialNumber].Add(needleSerialNumber, infusionVolume); &#125; /// &lt;summary&gt; /// 添加注液针补偿数据 /// &lt;/summary&gt; public void AddCompensation(int injectorPumpSerialNumber, int needleSerialNumber, double compensation) &#123; InjectorPumpDatas[injectorPumpSerialNumber].AddCompensation(needleSerialNumber, compensation); &#125; /// &lt;summary&gt; /// 添加数据 /// &lt;/summary&gt; public void AddRange(int injectorPumpSerialNumber, int needleSerialNumber, IEnumerable&lt;double&gt; infusionVolume) &#123; InjectorPumpDatas[injectorPumpSerialNumber].AddRange(needleSerialNumber, infusionVolume); &#125; /// &lt;summary&gt; /// 清空 /// &lt;/summary&gt; public void Clear() &#123; foreach (var injectorPumpData in InjectorPumpDatas) &#123; injectorPumpData.Clear(); &#125; &#125;&#125; 保有量：二注后称 减去 一注前称 注液差：下料称重时，计算注液针灌入量误差。应灌注量-实际灌注量 数据集A：灌注量误差和注液针补偿缓存 数据集B：提取注液针补偿值与当前注液针补偿值相等的最后连续n个数据，写入PLC地址 数据集C：通过计算集合B的平均值和标准差，结合Z评分法剔除异常点得到集合C（Z分法需要一个阈值，这个阈值开放）；通过指数加权移动平均（这里有个平缓系数，也会开放），计算数据集C的注液针灌入量误差的平均值mean；计算新的注液针补偿值，注液针补偿&#x3D;当前注液针补偿+mean（当前注液针补偿通过plc获取） &#x2F;&#x2F;应灌注量：1.733 实际:1.741 误差0.008 当前补偿值0 数据集A：0+0.008 12345//应灌注量 1.733 4.78()//实际灌注量 1.741=》1.740//对应补偿值 -0.001//误差 1.733-1.741 = -0.008//理论补偿 = -0.001+(-0.008) = -0.009 1234567891011121314151617181920动态注液针补偿逻辑 PLC端:1 PLC开放注液针补偿地址，这些地址里面的值只能上位机更改，同时触摸屏实时显示2 注液前，PLC先把相应注液针补偿地址里面的值搬运到临时地址 (防止 PLC把注液针补偿写给注液泵后，上位机更新了教值，导致随电芯搬运的注液针补偿值和实际的补偿值不一致)，然后把这个补偿当作当前电芯的注液针补偿值，并一起搬运到下料3. 注液前后，注液针补偿值随电芯搬运到下料称重处 上位机端:1、下料称重，计算注液针灌入量误差，注液针灌入量误差=应灌入量-实际灌入量2. 读取当前电芯的注液针补偿值，将注液针灌入量误差和注液针补偿值缓存起来，作为数据集A3. 每下料一个电芯，查询数据集A，把注液针补偿值与当前注液针补偿值相等的最后连续n个数据提取出来，作为数据集B.并通过数据集B 的注液针灌入量误差计算新的注液针补偿值，如果新的注液针补偿值在设定的范围内，写给PLC对应的地址 把注液针补偿值与当前注液针补偿值相等的最后连续n个数据提取出来。这里不太对，应该是不论补偿值是否相等，都提取出来，然后根据每对“注液针灌入量误差和注液针补偿值”计算出一个“理论补偿值”，一共计算出n个，形成数据集，然后用这个数据集来做EWMA计算最终的，也就是当前的“理论补偿值”，并写入PLC。否则的话你打开自动调整，他会连续不停的调整补偿值，你很难得到包含n个不变的注液针补偿值的数据集 计算注液针补偿值:1. 通过计算数据集B的平均值和标准差，并结合Z分法来别除异常点,得到数据集C(Z分法需要一个负值，这个负值开放)2. 通过指数加权移动平均(这里有个平缓系数，也会开放)，计算数据集C的注液针灌入量误差的平均值mean3. 计算新的注液针补偿值,注液针补偿=当前注液针补偿+mean(当前注液针补偿通过PLC对用的地址读取》 对应PC补偿值：实际那根针的补偿值，PLC给出对应PC补偿值 当前PC补偿值：下料时候读取，看看是否人为修改了 理论PC补偿值：（？理论上应该补偿多少）对应PC补偿值+注液差 计算PC补偿值：（？通过算法计算出） 动态补偿值计算权重：0.1 动态补偿值异常因子：1.5 自定义控件Visual Tree和Logical Tree（可视化树和逻辑树）https://www.cnblogs.com/jellochen/p/3439903.html 在WPF中，用户界面是由XAML来呈现的。粗略地讲，从宏观上看，叶子为布局组件和控件所组成的树既是逻辑树，从微观上看，将逻辑树的叶子再放大可看到其内部是由可视化组件（继承自Visual类）组成的，叶子为这些可视化组件组成的树既是可视树。 当然，让我们更详细地探讨WPF中的逻辑树和可视化树。 逻辑树逻辑树是基于对象的层次结构，它反映了元素的父子关系和内容属性。在逻辑树中，每个节点都是一个继承自FrameworkElement或FrameworkContentElement的元素。逻辑树主要用于以下目的： 数据绑定：逻辑树用于确定数据绑定的范围和上下文。 样式继承：样式可以从父元素继承到子元素，逻辑树定义了这种继承的路径。 资源查找：当元素请求资源时，WPF会在逻辑树中向上查找，以找到定义的资源。 事件路由：逻辑树用于确定事件如何在不同元素之间传递，包括冒泡事件和隧道事件。逻辑树的构建通常是通过XAML文件中定义的元素和内容属性来完成的。例如，如果你在XAML中定义了一个Grid，里面包含了一个Button，那么Grid将是Button的父元素，在逻辑树中Button将是Grid的子节点。 可视化树可视化树是一个更详细的层次结构，它包含了逻辑树中的所有元素，以及为了渲染和布局目的而添加的其他可视化对象。可视化树的每个节点都是一个继承自Visual或Visual3D的对象。可视化树主要用于以下目的： 布局：可视化树用于计算元素的大小和位置，以及如何对它们进行布局。 渲染：WPF渲染引擎使用可视化树来确定如何在屏幕上绘制元素。 输入处理：可视化树用于确定哪些元素接收输入，如鼠标点击和键盘输入。可视化树的构建是基于逻辑树，但比逻辑树更复杂。例如，一个简单的Button可能在可视化树中包含多个子节点，如Border、ContentPresenter和其他用于渲染按钮外观的元素。这些额外的可视化对象不会出现在逻辑树中。 两者之间的关系逻辑树和可视化树是紧密相关的。每个逻辑树节点至少在可视化树中有一个对应的节点，但可视化树可能包含逻辑树中没有的额外节点。这是因为WPF的渲染模型需要额外的可视化对象来支持复杂的布局和渲染效果。 实际应用在开发WPF应用程序时，理解逻辑树和可视化树的概念非常重要。例如，当你遇到布局或渲染问题时，你可能需要检查可视化树来确定是否有额外的可视化对象影响了布局或渲染。同样，当你使用数据绑定或样式时，你需要考虑逻辑树中的元素关系。WPF提供了一个名为VisualTreeHelper的类，它包含了一些静态方法，可以用于遍历和检查可视化树。此外，LogicalTreeHelper类提供了一些方法来遍历逻辑树。总结来说，逻辑树和可视化树是WPF中管理UI元素的两种不同层次的表示。逻辑树关注元素之间的逻辑关系，而可视化树关注元素如何在实际屏幕上呈现。理解这两者之间的关系对于高效地开发WPF应用程序至关重要。 类索引器闭包多线程基本概念什么是线程 线程是操作系统中能够独立运行的最小单位，也是程序中能够并发执行的一段指令序列 线程是进程的一部分，一个进程可以包含多个线程，这些线程共享进程的资源 进程有入口线程，也可以创建更多的线程 为什么要多线程？ 批量重复任务希望同时进行（比如对于数组中的每个元素都进行相同且耗时的操作） 多个不同任务希望同时进行，互不干扰（比如有多个后台线程需要做轮询等操作） 什么是线程池？ 一组预先创建的线程，可以被重复使用来执行多个任务 避免频繁地创建和销毁线程，从而减少了线程创建和销毁的开销，提高了系统的性能和效率 异步编程默认使用线程池 什么是线程安全？线程安全 多个线程访问共享资源时，对共享资源的访问不会导致数据不一致或不可预期的结果 同步机制 用于协调和控制多个线程之间执行顺序和互斥访问共享资源 确保线程按照特定的顺序执行，避免竞态条件和数据不一致的问题 原子操作 在执行过程中不会被中断的操作。不可分割，要么完全执行，要么完全不执行，没有中间状态 在多线程环境下，原子操作能够保证数据的一致性和可靠性，避免出现竞态条件和数据竞争的问题 线程不安全的两个例子12345678910111213141516171819202122计数const int total = 100_000;int count = 0;var thread1 = new Thread(Increment);var thread2 = new Thread(Increment);thread1.Start();thread2.Start();thread1.Join();thread2.Join();Console.WriteLine($&quot;Count: &#123;count&#125;&quot;);void Increment()&#123; for (int i = 0; i &lt; total; i++) count++;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445操作队列var queue = new Queue&lt;int&gt;();var producer = new Thread(Producer);var consumer1 = new Thread(Consumer);var consumer2 = new Thread(Consumer);producer.Start();consumer1.Start();consumer2.Start();producer.Join();Thread.Sleep(100); // Wait for consumers to finishconsumer1.Interrupt();consumer2.Interrupt();consumer1.Join();consumer2.Join();void Producer()&#123; for (int i = 0; i &lt; 20; i++) &#123; Thread.Sleep(20); queue.Enqueue(i); &#125;&#125;void Consumer()&#123; try &#123; while (true) &#123; if (queue.TryDequeue(out var res)) Console.WriteLine(res); Thread.Sleep(1); &#125; &#125; catch (ThreadInterruptedException) &#123; Console.WriteLine(&quot;Thread interrupted.&quot;); &#125;&#125; 常用实现方式 线程 线程池 异步编程 考虑一下自带方法？ Parallel For、ForEach、Invoke PLINQ AsParallel、AsSequential AsOrdered 1234567891011121314151617181920212223242526Parallel 与 PLINQvar inputs = Enumerable.Range(1,20).ToArray();int HeavyJob(int input)&#123; Thread.Sleep(300); return input;&#125;// Sequentialvar forOutputs = new int[inputs.Length];for (int i = 0; i &lt; inputs.Length; i++)&#123; forOutputs[i] = HeavyJob(inputs[i]);&#125;// Parallelvar parallelOutputs = new int[inputs.Length];Parallel.For(0, inputs.Length, i =&gt;&#123; parallelOutputs[i] = HeavyJob(inputs[i]);&#125;);// PLINQvar plinqOutputs = inputs.AsParallel().Select(HeavyJob).ToArray(); 12345678910111213141516171819PLINQ 与信号量using System.Diagnostics;var inputs = Enumerable.Range(1,20).ToArray();var semaphore = new Semaphore(3, 3);int HeavyJob(int input)&#123; semaphore.WaitOne(); Thread.Sleep(300); semaphore.Release(); return input;&#125;var sw = Stopwatch.StartNew();var plinqOutputs = inputs.AsParallel().Select(HeavyJob).ToArray();sw.Stop();Console.WriteLine($&quot;Elapsed time: &#123;sw.ElapsedMilliseconds&#125;ms&quot;); 线程Thread线程的创建 创建 Thread 实例，并传入 ThreadStart 委托 还可以配置线程，如是否为后台线程 调用 Thread.Start 方法，还可以传参 线程的终止 调用 Thread.Join 方法，等待线程的结束 调用 Thread.Interrupt 方法，中断线程的执行 会在相应线程中抛出ThreadInterruptedException 如果线程中包含一个 while(true) 循环，那么需要保证包含等待方法，如IO操作，Thread.Sleep等 不能用 Abort？ 使用 Abort 方法来强制终止线程可能导致一些严重的问题，包括资源泄漏和不可预测的行为 较新版本的 .NET 中如果使用这个方法，会报PlatformNotSupportedException 推荐使用 Thread.Interrupt 或CancellationToken 线程的挂起与恢复 Thread.Suspend 以及 Thread.Resume 较新版本的 .NET 中，这两个方法已经被标记为Obsolete，且调用会报错 推荐使用锁、信号量等方式实现这一逻辑 线程的超时 Join 方法拥有 Timeout 入参，并会在超时后返回 false 可以在这种情况下考虑使用 Interrupt 或CancellationToken 的方式终止一个线程 1234567891011121314151617181920212223线程终止var thread = new Thread(() =&gt;&#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; Thread.Sleep(1000); Console.WriteLine(&quot;Sub thread: &quot; + i); &#125; &#125; catch (ThreadInterruptedException) &#123; Console.WriteLine(&quot;Thread interrupted&quot;); &#125;&#125;);thread.Start();Thread.Sleep(3500);thread.Interrupt();thread.Join();Console.WriteLine(&quot;Done&quot;); 线程安全与同步机制Thread-Safety原子操作 Interlocked 锁与信号量 lock &amp; Monitor Mutex Semaphore WaitHandle ManualResetEvent AutoResetEvent ReaderWriterLock 轻量型 SemaphoreSlim ManualResetEventSlim ReaderWriterLockSlim 不要自己造轮子！ 线程安全的单例：Lazy 线程安全的集合类型：ConcurrentBag、ConcurrentStack、ConcurrentQueue、ConcurrentDictionary 阻塞集合：BlockingCollection 通道：Channel 原子操作：Interlocked 周期任务：PeriodicTimer 多线程练习题练习 1：基本线程创建创建一个C#控制台应用程序，实现以下功能： 创建并启动3个线程。 每个线程打印从1到10的数字。 确保所有线程都完成后，主线程打印“所有线程已完成”。 123456789101112131415161718192021222324252627282930313233343536using System;using System.Threading;class Program&#123; static object lockObject = new object(); static void Main(string[] args) &#123; Thread[] threads = new Thread[3]; for (int i = 0; i &lt; threads.Length; i++) &#123; threads[i] = new Thread(PrintNumbers); threads[i].Start(); &#125; foreach (var thread in threads) &#123; thread.Join(); // 等待所有线程完成 &#125; Console.WriteLine(&quot;所有线程已完成&quot;); &#125; static void PrintNumbers() &#123; lock (lockObject) // 确保打印操作是线程安全的 &#123; for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine($&quot;线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;i&#125;&quot;); &#125; &#125; &#125;&#125; 练习 2：线程同步在练习1的基础上，实现以下功能： 使用锁（lock）或其他同步机制（如Monitor、Mutex）确保数字打印是线程安全的。 每个线程打印数字时，应该按顺序打印（例如，线程1打印1, 2, 3…，线程2打印11, 12, 13…）。 1234567891011121314151617181920212223242526272829303132333435363738394041class TestThread&#123; static int globalNextNum = 1; static object lockObject = new object(); public static void Main() &#123; Task[] tasks = new Task[3]; for (int i = 0; i &lt; tasks.Length; i++) &#123; tasks[i] = new Task(() =&gt; &#123; PrintOneToTen(); &#125;); tasks[i].Start(); &#125; for (int i = 0; i &lt; tasks.Length; i++) &#123; tasks[i].Wait(); &#125; Console.WriteLine(&quot;所有线程已完成&quot;); &#125; static void PrintOneToTen() &#123; try &#123; Monitor.Enter(lockObject); // 安全地访问共享资源 for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine($&quot;线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;globalNextNum++&#125;&quot;); // 为了让线程之间的输出更明显，我们可以让线程稍微等待一下 Thread.Sleep(100); &#125; &#125; finally &#123; // 确保退出锁定状态 Monitor.Exit(lockObject); &#125; &#125;&#125; 练习 3：使用线程池修改练习1，使用线程池（ThreadPool）来创建和管理线程，而不是直接创建Thread对象。 1234567891011121314151617181920212223242526272829303132333435TestThread.Main();class TestThread&#123; static int globalNextNum = 1; static object lockObject = new object(); public static void Main() &#123; //WaitCallback[] waitCallBack = new WaitCallback[3]; ManualResetEvent[] doneEvents = new ManualResetEvent[3]; for (int i = 0; i &lt; 3; i++) &#123; doneEvents[i] = new ManualResetEvent(false); ThreadPool.QueueUserWorkItem(PrintOneToTen,doneEvents[i]); &#125; WaitHandle.WaitAll(doneEvents); Console.WriteLine(&quot;所有线程已完成&quot;); &#125; static void PrintOneToTen(object state) &#123; lock (lockObject) &#123; ManualResetEvent doneEvents = (ManualResetEvent)state; // 安全地访问共享资源 for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine($&quot;线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;globalNextNum++&#125;&quot;); // 为了让线程之间的输出更明显，我们可以让线程稍微等待一下 Thread.Sleep(100); &#125; // 设置事件，表示线程已完成 doneEvents.Set(); &#125; &#125;&#125; 练习 4：使用Task使用Task类重写练习1，实现相同的功能。 12345678910111213141516171819202122232425262728293031323334353637TestThread.Main();class TestThread&#123; static int globalNextNum = 1; static object lockObject = new object(); public static void Main() &#123; Task[] tasks = new Task[3]; for (int i = 0; i &lt; tasks.Length; i++) &#123; tasks[i] = new Task(() =&gt; &#123; PrintOneToTen(); &#125;); tasks[i].Start(); &#125; for (int i = 0; i &lt; tasks.Length; i++) &#123; tasks[i].Wait(); &#125; Console.WriteLine(&quot;所有线程已完成&quot;); &#125; static void PrintOneToTen() &#123; lock(lockObject) &#123; // 安全地访问共享资源 for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine($&quot;线程 &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;globalNextNum++&#125;&quot;); // 为了让线程之间的输出更明显，我们可以让线程稍微等待一下 Thread.Sleep(100); &#125; &#125; &#125;&#125; 练习 5：并行循环使用Parallel.For或Parallel.ForEach重写练习1，实现相同的功能。 1234567891011121314151617181920using System;using System.Threading.Tasks;class Program&#123; static void Main(string[] args) &#123; Parallel.For(1, 31, (i) =&gt; &#123; // 由于Parallel.For并行执行，我们需要计算每个线程应该打印的数字 int threadId = Task.CurrentId.HasValue ? Task.CurrentId.Value : -1; Console.WriteLine($&quot;线程 &#123;threadId&#125;: &#123;i&#125;&quot;); // 为了让输出更清晰，可以稍微等待 Thread.Sleep(100); &#125;); Console.WriteLine(&quot;所有线程已完成&quot;); &#125;&#125; 练习 6：线程间通信创建一个C#控制台应用程序，实现以下功能： 创建两个线程，一个线程用于生产数据，另一个线程用于消费数据。 使用BlockingCollection&lt;T&gt;或其他机制来实现生产者-消费者模式。 1234567891011121314151617181920212223242526272829303132333435class TestThread&#123; static BlockingCollection&lt;int&gt; blockingCollection = new BlockingCollection&lt;int&gt;(); public static void Main() &#123; Thread producer = new Thread(Produce); Thread consumer = new Thread(Consumer); producer.Start(); consumer.Start(); producer.Join(); consumer.Join(); &#125; static void Produce() &#123; for (int i = 0; i &lt; 10; i++) &#123; blockingCollection.Add(i); Console.WriteLine($&quot;produce:&#123;i&#125;&quot;); Thread.Sleep(100); &#125; &#125; static void Consumer() &#123; foreach (var item in blockingCollection.GetConsumingEnumerable()) &#123; Console.WriteLine($&quot;consumer:&#123;item&#125;&quot;); Thread.Sleep(100); &#125; &#125;&#125; 练习 7：线程局部存储创建一个C#控制台应用程序，实现以下功能： 创建一个线程局部存储（ThreadLocal&lt;T&gt;）变量，用于存储每个线程的计数。 启动多个线程，每个线程将自己的计数增加，并打印出增加后的值。 12345678910111213141516171819202122232425262728293031//在C#中，ThreadLocal&lt;T&gt; 是一个类，它提供了一种线程局部存储（Thread-Local Storage, TLS）机制，使得每个线程都可以拥有自己的变量副本，而不会与其他线程共享。class TestThread&#123; static ThreadLocal&lt;int&gt; threadLocal = new ThreadLocal&lt;int&gt;(()=&gt;0);//初始化为0 public static void Main() &#123; Thread[] threads = new Thread[3]; for (int i = 0; i &lt; threads.Length; i++) &#123; threads[i] = new Thread(ThreadProc); threads[i].Start(); &#125; foreach (var thread in threads) &#123; thread.Join(); &#125; &#125; static void ThreadProc() &#123; for (int i = 0; i &lt; 5; i++) &#123; threadLocal.Value++; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125;: &#123;threadLocal.Value&#125;&quot;); &#125; &#125;&#125; 练习 8：死锁演示创建一个C#控制台应用程序，演示死锁的情况： 创建两个资源（例如两个object）。 创建两个线程，每个线程分别锁定一个资源，然后尝试锁定另一个资源，以产生死锁。 1234567891011121314151617181920212223242526272829using System;using System.Threading;class Program&#123; static object lock1 = new object(); static object lock2 = new object(); static void Main(string[] args) &#123; Thread t1 = new Thread(DeadlockDemo); Thread t2 = new Thread(DeadlockDemo); t1.Start(); t2.Start(); &#125; static void DeadlockDemo() &#123; lock (lock1) &#123; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125; acquired lock1&quot;); Thread.Sleep(100); lock (lock2) &#123; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125; acquired lock2&quot;); &#125; &#125; &#125;&#125; 练习 9：解决死锁修改练习8中的代码，使用超时或其他策略来避免死锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Threading;class Program&#123; static object lock1 = new object(); static object lock2 = new object(); static void Main(string[] args) &#123; Thread t1 = new Thread(DeadlockFreeDemo); Thread t2 = new Thread(DeadlockFreeDemo); t1.Start(); t2.Start(); &#125; static void DeadlockFreeDemo() &#123; const int lockTimeout = 1000; // Timeout in milliseconds if (Monitor.TryEnter(lock1, lockTimeout)) &#123; try &#123; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125; acquired lock1&quot;); Thread.Sleep(100); if (Monitor.TryEnter(lock2, lockTimeout)) &#123; try &#123; Console.WriteLine($&quot;Thread &#123;Thread.CurrentThread.ManagedThreadId&#125; acquired lock2&quot;); &#125; finally &#123; Monitor.Exit(lock2); &#125; &#125; &#125; finally &#123; Monitor.Exit(lock1); &#125; &#125; &#125;&#125; 练习 10：线程安全的数据结构创建一个C#控制台应用程序，实现以下功能： 使用线程安全的集合（如ConcurrentBag&lt;T&gt;、ConcurrentDictionary&lt;TKey, TValue&gt;）。 多个线程同时向集合中添加和移除元素。 确保集合操作是线程安全的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;using System.Collections.Concurrent;using System.Threading;using System.Threading.Tasks;class Program&#123; // 使用 ConcurrentBag 作为线程安全的集合 static ConcurrentBag&lt;int&gt; bag = new ConcurrentBag&lt;int&gt;(); static void Main(string[] args) &#123; int numberOfThreads = 10; int itemsToAddPerThread = 100; // 创建并启动多个线程来添加元素 Task[] addingTasks = new Task[numberOfThreads]; for (int i = 0; i &lt; numberOfThreads; i++) &#123; int threadId = i; addingTasks[i] = Task.Run(() =&gt; AddItemsToBag(threadId, itemsToAddPerThread)); &#125; // 创建并启动多个线程来移除元素 Task[] removingTasks = new Task[numberOfThreads]; for (int i = 0; i &lt; numberOfThreads; i++) &#123; removingTasks[i] = Task.Run(RemoveItemsFromBag); &#125; // 等待所有添加任务完成 Task.WaitAll(addingTasks); // 等待所有移除任务完成 Task.WaitAll(removingTasks); Console.WriteLine(&quot;所有线程已完成操作。&quot;); Console.WriteLine(&quot;集合中的元素数量: &quot; + bag.Count); &#125; static void AddItemsToBag(int threadId, int count) &#123; for (int i = 0; i &lt; count; i++) &#123; bag.Add(threadId * count + i); &#125; Console.WriteLine($&quot;线程 &#123;threadId&#125; 完成添加 &#123;count&#125; 个元素。&quot;); &#125; static void RemoveItemsFromBag() &#123; int itemsRemoved = 0; int item; while (bag.TryTake(out item)) &#123; itemsRemoved++; &#125; Console.WriteLine($&quot;一个线程移除了 &#123;itemsRemoved&#125; 个元素。&quot;); &#125;&#125; 异步编程常见概念已经有多线程了，为何还要异步多线程与异步是不同的概念 异步并不意味着多线程，单线程同样可以异步 异步默认借助线程池 多线程经常阻塞，而异步要求不阻塞 多线程与异步的适用场景不同多线程 适合 CPU 密集型操作 适合长期运行的任务 线程的创建与销毁开销较大 提供更底层的控制，操作线程、锁、信号量等 线程不易于传参及返回 线程的代码书写较为繁琐 异步 适合 IO 密集型操作 适合短暂的小任务 避免线程阻塞，提高系统响应能力 什么是异步任务（Task）包含了异步任务的各种状态的一个引用类型 正在运行、完成、结果、报错等 另有 ValueTask 值类型版本 对于异步任务的抽象 开启异步任务后，当前线程并不会阻塞，而是可 以去做其他事情 异步任务（默认）会借助线程池在其他线程上运行 获取结果后回到之前的状态 任务的结果 返回值为 Task 的方法表示异步任务没有返回值 返回值为 Task 则表示有类型为 T 的返回值 异步方法（async Task） 将方法标记 async 后，可以在方法中使用 await 关键字 await 关键字会等待异步任务的结束，并获得结 果 async + await 会将方法包装成状态机，await 类似于检查点 MoveNext 方法会被底层调用，从而切换状态 async Task 返回值依旧是 Task 类型，但是在其中可以使用 await 关键字 在其中写返回值可以直接写 Task 中的 T 类 型，不用包装成 Task async void 同样是状态机，但缺少记录状态的 Task 对象 无法聚合异常（Aggregate Exception），需要谨慎处理异常 几乎只用于对于事件的注册 异步编程具有传染性（Contagious） 一处 async，处处 async 几乎所有自带方法都提供了异步的版本 重要思想：不阻塞！ await 会暂时释放当前线程，使得该线程可以执 行其他工作，而不必阻塞线程直到异步操作完成 不要在异步方法里用任何方式阻塞当前线程 常见阻塞情形 Task.Wait() &amp; Task.Result 如果任务没有完成，则会阻塞当前线程，容易导致死锁 Task.GetAwaiter().GetResult() 不会将 Exception 包装为 AggregateException Task.Delay() vs. Thread.Sleep() 后者会阻塞当前的线程，这与异步编程的理念不 符 前者是一个异步任务，会立刻释放当前的线程 IO 等操作的同步方法 较新版本的 .NET 为我们提供了一整套的异步方 法，包含 Web、IO、Stream 等 其他繁重且耗时的任务 使用 Task.Run 包装 同步上下文 一种管理和协调线程的机制，允许开发者将代码 的执行切换到特定的线程 WinForms 与 WPF 拥有同步上下文（UI 线 程），而控制台程序默认没有 ConfigureAwait(false) 配置任务通过 await 方法结束后是否会到原来的 线程，默认为 true 一般只有 UI 线程会采用这种策略 TaskScheduler 控制 Task 的调度方式和运行线程 线程池线程 Default 当前线程 CurrentThread 单线程上下文 STAThread 长时间运行线程 LongRunning 优先级、上下文、执行状态等 一发即忘（Fire-and-forget） 调用一个异步方法，但是并不使用 await 或阻塞 的方式去等待它的结束 无法观察任务的状态（是否完成、是否报错等） 简单任务如何创建异步任务？Task.Run() 在一个新的线程上执行代码 传入异步匿名方法会被包装成 Task Task.Run(async () &#x3D;&gt; await Task.Delay(100)) 保证异步方法在别的线程上运行 Task.Factory.StartNew() 提供更多功能，比如 TaskCreationOptions.LongRunning Task.Run 相当于简化版 new Task + Task.Start()看起来类似 new Thread + Thread.Start()，不 常用 如何同时开启多个异步任务？ 不要 for 循环中使用 await Task.WhenAll()、Task.WhenAny() 任务如何取消？ CancellationTokenSource + CancellationToken OperationCanceledException &amp; TaskCanceledException 推荐异步方法都带上 CancellationToken 这一传 参 「我可以不用，但你不能没有」 任务超时如何实现？在异步任务中汇报进度？如何在同步方法中调用异步方法？常见误区异步一定是多线程？ 异步编程不必需要多线程来实现 时间片轮转调度 比如可以在单个线程上使用异步 I&#x2F;O 或事件驱动 的编程模型（EAP） 单线程异步：自己定好计时器，到时间之前先去 做别的事情 。多线程异步：将任务交给不同的线程，并由自己 来进行指挥调度 异步方法一定要写成 async Task？ async 关键字只是用来配合 await 使用，从而将 方法包装为状态机 本质上仍然是 Task，只不过提供了语法糖，并 且函数体中可以直接 return Task 的泛型类型 接口中无法声明 async Task await 一定会切换同步上下文？ 在使用 await 关键字调用并等待一个异步任务 时，异步方法不一定会立刻来到新的线程上 如果 1 await 了一个已经完成的任务（包括 Task.Delay(0)），会直接获得结果 异步可以全面取代多线程？ 异步编程与多线程有一定关系，但两者并不是可 以完全互相替代 Task.Result 一定会阻塞当前线程？ 如果任务已经完成，那么 Task.Result 可以直接 得到结果 开启的异步任务一定不会阻塞当前线程？ await 关键字不一定会立刻释放当前线程，所以 如果调用的异步方法中存在阻塞（如 Thread.Sleep(0)），那么依旧会阻塞当前上下 文对应的线程 同步机制传统方法 Monitor（lock） Mutex Semaphore EventWaitHandle 轻量型 SemaphoreSlim ManualResetEventSlim 并发集合 ConcurrentBag&#x2F;Stack&#x2F;Queue BlockingCollection Channel 第三方库 AsyncManualResetEvent Microsoft.VisualStudio.Threading AsyncLock Nito.AsyncEx 还有什么？ Task.FromResult、Task.FromCanceled、 Task.FromException Task.GetAwaiter().GetResult() ContinueWith() Task.Yield() ValueTask IAsyncEnumerable？ IAsyncDisposable？ Async Stream Built-in 异步方法 HttpClient.GetAsync File.WriteAllTextAsync MemoryStream.ReadAsync Console.Out.WriteLineAsync 在异步编程中使用锁与信号量？ WPF &amp; Async 练习题练习 1: 异步读取文件内容编写一个异步方法 ReadFileAsync，该方法接收一个文件路径作为参数，异步读取文件内容，并返回读取到的字符串。 1234567public static async Task&lt;string&gt; ReadFileAsync(string filePath) &#123; using(var render = new StreamReader(filePath)) &#123; return await render.ReadToEndAsync(); &#125; &#125; 练习 2: 并发异步操作创建三个异步方法 GetDataAAsync、GetDataBAsync 和 GetDataCAsync，模拟从不同数据源获取数据。然后编写一个方法 FetchAllDataAsync，该方法并发执行这三个异步操作，并在所有操作完成后返回结果。 123456789101112public static async Task FetchAllDataAsync() &#123; Task&lt;string&gt; taskA = GetDataAAsync(@&quot;D:\\log.txt&quot;); Task&lt;string&gt; taskB = GetDataBAsync(@&quot;D:\\log.txt&quot;); Task&lt;string&gt; taskC = GetDataCAsync(@&quot;D:\\log.txt&quot;); await Task.WhenAll(taskA, taskB, taskC); Console.WriteLine($&quot;Data A: &#123;taskA.Result&#125;&quot;); Console.WriteLine($&quot;Data B: &#123;taskB.Result&#125;&quot;); Console.WriteLine($&quot;Data C: &#123;taskC.Result&#125;&quot;); &#125; 练习 3: 顺序执行异步操作编写一个异步方法 SequenceAsyncOps，该方法顺序执行以下操作：先执行 GetDataAAsync，然后根据 GetDataAAsync 的结果执行 GetDataBAsync，最后根据 GetDataBAsync 的结果执行 GetDataCAsync 并返回结果。 练习 4: 异步处理错误在练习 3 的基础上，增加错误处理功能。如果任何一步操作失败，捕获异常并打印错误信息。 123456789101112131415// 练习 3 &amp; 4: 顺序执行异步操作并处理错误 public async Task SequenceAsyncOps() &#123; try &#123; string resultA = await GetDataAAsync(); string resultB = await GetDataBAsync(resultA); string resultC = await GetDataCAsync(resultB); Console.WriteLine($&quot;Result C: &#123;resultC&#125;&quot;); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;An error occurred: &#123;ex.Message&#125;&quot;); &#125; &#125; 练习 5: 异步并发控制创建一个任务列表 tasks，其中每个任务都是一个返回 Task 的异步方法。编写一个方法 RunTasksConcurrentlyAsync，该方法可以同时执行最多5个异步操作，当一个操作完成时，自动从任务列表中取下一个任务执行。 12345678910111213141516171819202122232425262728293031// 练习 5: 异步并发控制 public async Task RunTasksConcurrentlyAsync(Task[] tasks, int limit) &#123; var semaphore = new SemaphoreSlim(limit); var runningTasks = new List&lt;Task&gt;(); foreach (var task in tasks) &#123; await semaphore.WaitAsync(); runningTasks.Add( task.ContinueWith(t =&gt; &#123; semaphore.Release(); &#125;)); &#125; await Task.WhenAll(runningTasks); &#125; Main()&#123; // 练习 5 var tasks = new Task[] &#123; exercises.GetDataAAsync(), exercises.GetDataBAsync(&quot;&quot;), exercises.GetDataCAsync(&quot;&quot;), // 添加更多任务... &#125;; await exercises.RunTasksConcurrentlyAsync(tasks, 5); &#125; 1SemaphoreSlim semaphore = new SemaphoreSlim(initialCount, maximumCount); initialCount：信号量初始化时允许的最大并发访问数。 maximumCount：信号量可以允许的最大并发访问数。 等待信号 当要进入临界区之前，需要调用 WaitAsync 方法来等待信号。 1await semaphore.WaitAsync(); 或者同步版本： 1semaphore.Wait(); 如果信号量计数大于0，则立即进入临界区。如果计数为0，则线程会阻塞，直到其他线程释放信号量。 释放信号 完成对共享资源的访问后，需要调用 Release 方法来释放信号量，增加其计数。 1semaphore.Release(); 如果释放操作导致信号量的计数超过了最大值，将会抛出异常。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"fly"},{"title":"常见面试题","slug":"Face","date":"2025-05-10T10:00:24.000Z","updated":"2025-06-19T14:17:50.725Z","comments":true,"path":"2025/05/10/Face/","permalink":"http://example.com/2025/05/10/Face/","excerpt":"","text":"接口和抽象类区别相同 都可以被继承 都不能被直接实例化 都可以包含方法的声明 不同 接口 抽象类 不能包含成员变量 可以包含成员变量 不能包含构造函数 可以包含构造函数 可以多继承 只能单继承 子类必须实现所有声明的方法 子类必须实现所有的抽象方法(必须是公有的)，普通方法可不实现 方法声明默认public 普通方法可以由其他访问修饰符修饰，抽象方法必须是public，protected 理解接口：功能的定义 抽象类：事物的共性 emp：老鹰类，抽象类：鸟类，接口：飞、吃；歼二十，抽象类：飞机，接口：飞，攻击； 多线程进程和线程进程是资源分配的最小单位，线程是CPU调度的最小单位 进程好比火车，线程好比火车的车厢 区别: 线程在进程下进行，单纯的车厢无法运行 一个进程包含多个线程，一辆火车有多个车厢 不同进程数据难共享，一辆火车乘客难以换到另一辆火车 同进程中不同线程数据易共享，a车厢乘客容易到b车厢 进程更消耗资源 进程之间不会相互影响 多线程、同步编程、异步编程、并行、并发这几者之间有什么区别？首先，**多线程是指一个程序同时运行多个线程。**C#中通过Thread类或者Task来创建和管理线程。多线程可以提高程序的性能，尤其是在多核CPU上，因为不同的线程可以在不同的核心上并行执行。但多线程也带来了线程安全的问题，比如竞态条件，所以需要同步机制。 接下来是同步编程。同步意味着调用方必须等待某个操作完成才能继续执行。比如，在C#中使用lock关键字来确保同一时间只有一个线程访问共享资源，这就是同步。同步可以保证数据的一致性，但可能会导致线程阻塞，影响性能。 然后是异步编程。异步允许调用方在发出请求后继续执行其他任务，而不需要等待操作完成。（它用单线程也能处理多个任务，靠的是非阻塞I&#x2F;O和事件循环，比如发起一个网络请求后不用干等着，可以去处理别的任务，等数据回来了再接着处理。）C#中的async和await关键字是异步编程的核心，它们允许非阻塞地执行操作，比如I&#x2F;O操作。异步编程常用于提高响应性，尤其是在UI应用或Web服务中，避免主线程被阻塞。 并行和并发这两个概念容易混淆。根据知识库，**并发指的是在同一时间段内处理多个任务，但不一定同时执行，而是通过上下文切换来实现。而并行是指真正的同时执行多个任务，通常需要多核CPU的支持。**在C#中，并行编程可以通过Task Parallel Library (TPL) 或者Parallel类来实现，利用多核处理器的优势。 在C#中，多线程、同步编程、异步编程、并行、并发 是紧密相关但又有区别的概念。以下是它们的定义、区别以及实际应用的总结： 1. 多线程（Multithreading） 定义：多线程是指一个程序同时运行多个线程（Thread），每个线程可以独立执行任务。C#中通过 System.Threading.Thread 类或 Task 类创建和管理线程。 特点： 资源共享：线程共享进程的内存和资源，但需要处理线程安全问题（如竞态条件[是指当多个线程试图同时访问和修改同一个共享资源（如变量、文件或数据库）时，由于执行顺序的不确定性导致程序的行为变得不可预测。]、死锁[一组进程或线程中，每个进程或线程都在等待另一个进程或线程释放资源，而这些资源永远不会被释放的一种状态。]）。 调度方式：线程由操作系统调度，可能并发或并行执行（取决于 CPU 核心数）。 应用场景： 需要同时处理多个任务的场景（如后台计算、UI更新、文件处理）。 示例： 12Thread thread = new Thread(DoWork);thread.Start(); 2. 同步编程（Synchronous Programming） 定义：同步编程是指调用方必须等待某个操作完成才能继续执行后续逻辑。操作是顺序执行的。 特点： 阻塞：调用方会阻塞当前线程，直到操作完成。 线程安全：通过同步机制（如锁、信号量）确保数据一致性。 应用场景： 简单的顺序任务，或需要严格保证数据一致性的场景。 示例： 1234lock (syncObject) &#123; // 只允许一个线程访问共享资源 sharedResource.Value++;&#125; 3. 异步编程（Asynchronous Programming） 定义：异步编程是指调用方在发出请求后立即返回，无需等待操作完成。操作完成后通过回调或事件通知调用方。 特点： 非阻塞：调用方不会阻塞当前线程，可继续执行其他任务。 提高响应性：特别适合 I&#x2F;O 密集型操作（如网络请求、文件读写）。 应用场景： UI 应用程序（避免界面卡顿）、Web 服务（处理高并发请求）。 示例： 12345public async Task&lt;string&gt; DownloadDataAsync(string url) &#123; using (var client = new HttpClient()) &#123; return await client.GetStringAsync(url); // 非阻塞 &#125;&#125; 4. 并行（Parallelism） 定义：并行是指多个任务同时执行，通常依赖多核 CPU 的硬件支持。C# 中通过 Task Parallel Library (TPL) 或 Parallel 类实现。 特点： 真正同时执行：多个线程分配到不同 CPU 核心上运行。 提升计算性能：适合 CPU 密集型任务（如大规模计算、数据处理）。 应用场景： 需要充分利用多核性能的场景（如科学计算、图像处理）。 示例： 1234Parallel.For(0, 100, i =&gt; &#123; // 并行执行计算任务 Console.WriteLine(i);&#125;); 5. 并发（Concurrency） 定义：并发是指多个任务交替执行，通过时间片轮转模拟“同时执行”。可以是单核 CPU 的并发，也可以是多核 CPU 的并行。 特点： 逻辑上同时执行：任务交替执行，但实际可能串行或并行。 资源竞争：需要通过同步机制避免冲突。 应用场景： 任务之间需要协作的场景（如生产者-消费者模型）。 示例： 123Task task1 = Task.Run(() =&gt; DoWork1());Task task2 = Task.Run(() =&gt; DoWork2());await Task.WhenAll(task1, task2); // 等待两个任务完成 关键区别与联系 概念 核心目标 执行方式 是否阻塞 是否需要同步 多线程 同时执行多个任务 并发或并行 通常阻塞 需要（线程安全） 同步编程 保证数据一致性 顺序执行 是 是 异步编程 提高响应性和吞吐量 非阻塞，协作执行 否 可选 并行 充分利用多核性能 真正同时执行 否 需要（线程安全） 并发 交替执行多个任务 逻辑上同时执行 否 需要（资源协调） 实际应用中的选择 I&#x2F;O 密集型任务（如网络请求、文件读写）： 优先选择异步编程（async/await），避免阻塞线程。 示例：Web API 请求处理。 CPU 密集型任务（如计算、图像处理）： 优先选择并行编程（Parallel.For、Task），充分利用多核性能。 示例：大规模数据计算。 需要严格数据一致性： 使用同步机制（lock、Monitor、Mutex）。 示例：银行账户余额更新。 简单任务或单线程环境： 直接使用同步编程，避免复杂性。 示例：单线程控制台程序。 总结 多线程是实现并行和并发的基础，但本身不直接决定任务执行方式。 同步和异步关注的是调用方的执行模式（阻塞 vs 非阻塞）。 并行和并发描述任务的执行方式（真正同时 vs 逻辑交替）。 在 C# 中，合理结合 Task、async/await、Parallel 和同步机制，可以高效处理各种多线程场景。 内存管理1. 内存管理基础 托管堆 vs 栈 栈：存储值类型（如int, struct）和方法调用上下文（参数、局部变量），由编译器自动分配&#x2F;释放。 托管堆：存储引用类型（如class实例），由垃圾回收器（GC）管理。 例外：值类型可能在堆上分配（如作为类的成员、装箱操作、静态变量）。 引用类型生命周期 对象通过new在堆上分配。 当对象不再被根对象（静态变量、局部变量、CPU寄存器等）引用时，成为垃圾。 2. 垃圾回收（GC）原理 分代回收（Generational GC） 分代策略： 第0代：新对象，GC最频繁（约每1秒）。 第1代：第0代存活的对象，GC频率较低。 第2代：长期存活对象和大对象（LOH），GC频率最低。 晋升机制：对象在GC后未被回收，则晋升到下一代。 GC触发条件 第0代空间不足。 调用GC.Collect()（通常不推荐手动触发）。 系统内存不足。 GC工作流程 标记阶段：从根对象出发，标记所有可达对象。 清理阶段：释放未被标记的对象内存。 压缩阶段（可选）：移动存活对象以减少内存碎片（仅限小对象堆）。 大对象堆（LOH） 存储大对象（如超过85KB的数组）。 不会被压缩，可能产生内存碎片。 单独回收，通常与第2代GC同时进行。 3. 资源释放与Dispose模式 Finalizer（终结器） 用~ClassName定义，由GC调用（时机不确定）。 潜在问题：延迟资源释放，影响性能。 IDisposable接口 核心方法：Dispose()，用于显式释放非托管资源（如文件句柄、数据库连接）。 使用模式： csharp 复制 1234567891011121314151617181920public class Resource : IDisposable &#123; private bool _disposed = false; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); // 避免重复调用Finalizer &#125; protected virtual void Dispose(bool disposing) &#123; if (!_disposed) &#123; if (disposing) &#123; // 释放托管资源 &#125; // 释放非托管资源 _disposed = true; &#125; &#125; ~Resource() =&gt; Dispose(false);&#125; using语句 自动调用Dispose()，确保资源释放： csharp 复制 123using (var resource = new Resource()) &#123; // 使用resource&#125; 4. 高级主题 弱引用（WeakReference） 允许引用对象的同时，允许其被GC回收。 用途：缓存、避免内存泄漏。 示例： csharp 复制 1234var weakRef = new WeakReference(myObject);if (weakRef.IsAlive) &#123; var target = weakRef.Target;&#125; 内存压力（Memory Pressure） 通知GC非托管资源的内存占用： GC.AddMemoryPressure()：提示GC额外内存压力。 GC.RemoveMemoryPressure()：释放后移除压力。 服务器GC vs 工作站GC 工作站GC：优化UI响应（默认客户端应用）。 服务器GC：多线程GC，适合高吞吐量服务端应用（通过.csproj配置）。 5. 常见问题与最佳实践 内存泄漏场景 静态引用：静态集合长期持有对象。 事件未注销：发布者持有订阅者的强引用。 解决方案：使用弱事件模式（如WeakEventManager）。 未释放非托管资源：忘记调用Dispose()。 性能优化 避免频繁分配大对象（尤其是LOH）。 减少装箱操作（如用泛型集合替代ArrayList）。 谨慎使用GC.Collect()，可能破坏分代优化。 诊断工具 Visual Studio诊断工具：内存分析器、CPU分析器。 Windbg&#x2F;SOS：分析堆转储。 dotMemory&#x2F;ANTS Memory Profiler：第三方内存分析工具。 装箱和拆箱1. 基本概念 装箱（Boxing） 将值类型（如int、struct）转换为引用类型（object或接口类型）的过程。 发生场景： 值类型赋值给object或接口变量。 值类型作为参数传递给接受object的方法。 底层行为： 在堆（托管堆）上分配内存，复制值类型数据到堆中。 返回堆上对象的引用。 csharp 复制 12int num = 42;object boxedNum = num; // 装箱 拆箱（Unboxing） 将引用类型（装箱后的对象）转换回原始值类型的过程。 底层行为： 检查目标类型是否与装箱类型一致。 将堆中的值复制到栈（或新的值类型变量）。 csharp 复制 1int unboxedNum = (int)boxedNum; // 拆箱 2. 关键特性 性能开销 装箱：涉及堆内存分配和数据复制，可能触发GC。 拆箱：需要类型检查和数据复制，但无内存分配。 高频操作需谨慎：例如在循环中对值类型频繁装箱。 类型安全 拆箱时必须显式指定目标类型，否则抛出InvalidCastException： csharp 复制 12object boxed = 42;double num = (double)boxed; // 运行时错误 与泛型的关系 泛型（如List&lt;T&gt;）可避免装箱拆箱： csharp 复制 12List&lt;int&gt; list = new List&lt;int&gt;(); // 无装箱list.Add(42); // 直接存储值类型 3. 常见场景与示例 示例1：非泛型集合中的装箱 csharp 复制 123ArrayList list = new ArrayList();list.Add(42); // int装箱为objectint num = (int)list[0]; // 拆箱 示例2：接口转换 csharp 复制 1IFormattable formattable = 10; // int装箱为IFormattable 示例3：错误拆箱 csharp 复制 12object boxed = &quot;123&quot;;int num = (int)boxed; // InvalidCastException 4. 如何避免装箱&#x2F;拆箱 使用泛型集合如List&lt;T&gt;、Dictionary&lt;TKey, TValue&gt;替代ArrayList、Hashtable。 避免不必要的object参数使用泛型方法约束（where T : struct）： csharp 复制 1public void Process&lt;T&gt;(T value) where T : struct &#123; &#125; // 无需装箱 使用Nullable&lt;T&gt;代替object处理可能为null的值类型： csharp 复制 1int? nullableInt = null; // 值类型语义，无需装箱 字符串格式化优化使用$&quot;&quot;或String.Format时，优先调用值类型的ToString()方法（不触发装箱）： csharp 复制 12int num = 42;string s = $&quot;&#123;num&#125;&quot;; // num.ToString()被调用，无装箱 5. 常见问题 GetType()是否需要装箱？ csharp 复制 12int num = 42;Type type = num.GetType(); // 装箱！因为GetType()是object的方法 is和as操作符的拆箱行为 is检查类型时不拆箱： csharp 复制 12object obj = 42;if (obj is int) &#123; &#125; // 检查类型，不拆箱 as操作符不可用于值类型： csharp 复制 12object obj = 42;int? num = obj as int?; // 合法（Nullable&lt;T&gt;） 模式匹配中的拆箱优化 csharp 复制 1if (obj is int num) &#123; &#125; // 安全拆箱，避免重复操作 6. 性能分析工具 IL代码查看使用ildasm或ILSpy查看装箱指令（box和unbox）。 性能分析器 Visual Studio性能分析器（检测堆分配）。 BenchmarkDotNet：测量高频装箱的性能损耗。 总结 装箱&#x2F;拆箱本质：值类型与引用类型间的转换，伴随堆内存分配和性能开销。 优化核心：通过泛型、避免object参数、使用值类型方法（如ToString()）减少操作。 高频场景需警惕：如循环、集合操作和非泛型API调用。 回调函数回调函数本质就是函数参数，也就是把A函数作为B函数的参数传到B函数里使用，那么这个A函数就是回调函数。 在C#中，实现回调的方式是通过委托来实现回调函数。即把A函数赋值给委托，然后把这个委托作为B函数的参数。 委托和事件在 C# 中，委托（Delegate） 是一个非常重要的概念，我们可以用生活中的例子来理解它：委托就像一个”方法容器”，允许你把方法当作参数传递。下面我会用通俗易懂的方式解释你的问题： 一、什么时候用委托？日常使用场景： 事件处理（比如按钮点击） 回调方法（比如异步操作完成后的通知） LINQ 查询（比如 Where 方法中的过滤条件） 策略模式（运行时动态改变算法） 多线程（比如 Thread 的启动方法） 典型需求：当你想把方法当作参数传递，或者需要动态决定调用哪个方法时。 二、委托的好处 解耦：调用方不需要知道具体实现，只需关心方法签名 灵活性：运行时动态改变方法逻辑 代码复用：通用逻辑+可插拔的具体实现 多播：一个委托可以绑定多个方法（+= 操作符） 三、委托 vs 事件 事件本质是封装后的委托，事件是基于 event 关键字修饰的委托实例 安全区别： 委托可以直接被调用（比如 myDelegate()） 事件只能通过 += 和 -= 订阅&#x2F;取消，且只能在声明它的类中触发 设计用途： 委托更通用，用于传递方法 事件专门用于实现发布-订阅模式 四、简单易懂的例子示例 1：基础委托（排序策略）1234567891011121314151617// 1. 定义委托public delegate int CompareDelegate(int a, int b);// 2. 使用委托的方法public void Sort(int[] arr, CompareDelegate compare)&#123; // 使用 compare 方法进行排序...&#125;// 3. 定义具体方法int Ascending(int a, int b) =&gt; a.CompareTo(b);int Descending(int a, int b) =&gt; b.CompareTo(a);// 4. 使用var arr = new int[] &#123; 3, 1, 4 &#125;;Sort(arr, Ascending); // 升序Sort(arr, Descending); // 降序 示例 2：事件（按钮点击）123456789101112131415161718// 1. 定义委托（实际开发中常用 EventHandler）public delegate void ClickEventHandler();// 2. 按钮类public class Button&#123; public event ClickEventHandler Clicked; // 事件 public void Press() &#123; Clicked?.Invoke(); // 只能在 Button 类内部触发 &#125;&#125;// 3. 使用var button = new Button();button.Clicked += () =&gt; Console.WriteLine(&quot;按钮被点了！&quot;);button.Press(); // 输出提示 五、关键总结 特性 委托 事件 直接调用 ✔️ (myDelegate()) ❌ 只能在声明类中触发 外部订阅 ✔️ ✔️ (+=&#x2F;-= 操作符) 多播支持 ✔️ ✔️ 典型用途 传递方法、回调 实现发布-订阅模式 实际开发建议：优先使用事件来实现通知机制，用委托来实现需要灵活传递方法的场景。在 GUI 编程（如 WPF&#x2F;WinForms）和异步编程（如 Task）中，委托和事件无处不在。","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"author":"fly"}],"categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"面试系列","slug":"C/面试系列","permalink":"http://example.com/categories/C/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"面试系列","slug":"面试系列","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"},{"name":"Log4Net","slug":"Log4Net","permalink":"http://example.com/tags/Log4Net/"},{"name":"LINQ","slug":"LINQ","permalink":"http://example.com/tags/LINQ/"},{"name":"GIT","slug":"GIT","permalink":"http://example.com/tags/GIT/"},{"name":"EF","slug":"EF","permalink":"http://example.com/tags/EF/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"},{"name":"语言语法","slug":"语言语法","permalink":"http://example.com/tags/%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/"},{"name":"面向对象","slug":"面向对象","permalink":"http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"WPF","slug":"WPF","permalink":"http://example.com/tags/WPF/"},{"name":"编程","slug":"编程","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"WPF - 编程","slug":"WPF-编程","permalink":"http://example.com/tags/WPF-%E7%BC%96%E7%A8%8B/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]}